<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LINE Notify 排程通知</title>
    <url>/2023/08/02/LINE-Notify-%E6%8E%92%E7%A8%8B%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<p><a href="https://notify-bot.line.me/" target="_blank" rel="noopener">LINE Notify</a> 是一個官方帳號<br>你可以在任何 Line 群組中加入 <strong>Line Notify</strong><br>並運用它來進行通知相關的服務</p>
<p>底下介紹如何搭配 <a href="https://script.google.com/" target="_blank" rel="noopener">Google Apps Script</a> 和 <a href="https://docs.google.com/spreadsheets" target="_blank" rel="noopener">Google Sheets</a><br>來完成一個簡單的自動排程通知服務：</p>
<ul>
<li>取得 Line Notify 的存取權杖</li>
<li>建立 Google Apps Script</li>
<li>建立 Google Sheets</li>
</ul>
<a id="more"></a>

<h2 id="取得-Line-Notify-的存取權杖"><a href="#取得-Line-Notify-的存取權杖" class="headerlink" title="取得 Line Notify 的存取權杖"></a>取得 Line Notify 的存取權杖</h2><h3 id="1-登入LINE-Notify"><a href="#1-登入LINE-Notify" class="headerlink" title="1.登入LINE Notify"></a>1.登入<a href="https://notify-bot.line.me/" target="_blank" rel="noopener">LINE Notify</a></h3><h3 id="2-點選右上角：個人帳號-gt-個人頁面-gt-發行權杖"><a href="#2-點選右上角：個人帳號-gt-個人頁面-gt-發行權杖" class="headerlink" title="2.點選右上角：個人帳號 -&gt; 個人頁面 -&gt; 發行權杖"></a>2.點選右上角：<strong>個人帳號</strong> -&gt; <strong>個人頁面</strong> -&gt; <strong>發行權杖</strong></h3><h3 id="3-填寫權杖名稱"><a href="#3-填寫權杖名稱" class="headerlink" title="3.填寫權杖名稱"></a>3.填寫權杖名稱</h3><p><font color="lightcoral">註：此名稱會在通知時作為標題顯示</font></p>
<h3 id="4-選擇接受通知的群組"><a href="#4-選擇接受通知的群組" class="headerlink" title="4.選擇接受通知的群組"></a>4.選擇接受通知的群組</h3><p><font color="lightcoral">註：記得該群組也要把 Line Notify 拉進去喔，不然沒有作用</font></p>
<h3 id="5-紀錄已發行的權杖"><a href="#5-紀錄已發行的權杖" class="headerlink" title="5.紀錄已發行的權杖"></a>5.紀錄已發行的權杖</h3><p><font color="lightcoral">註：權杖代碼只會顯示一次，離開會面前務必先複製</font></p>
<h2 id="建立-Google-Apps-Script"><a href="#建立-Google-Apps-Script" class="headerlink" title="建立 Google Apps Script"></a>建立 Google Apps Script</h2><h3 id="1-登入-Google-Apps-Script"><a href="#1-登入-Google-Apps-Script" class="headerlink" title="1.登入 Google Apps Script"></a>1.登入 <a href="https://script.google.com/" target="_blank" rel="noopener">Google Apps Script</a></h3><h3 id="2-點選左上角：新專案"><a href="#2-點選左上角：新專案" class="headerlink" title="2.點選左上角：新專案"></a>2.點選左上角：<strong>新專案</strong></h3><h3 id="3-撰寫-GAS-代碼"><a href="#3-撰寫-GAS-代碼" class="headerlink" title="3.撰寫 GAS 代碼"></a>3.撰寫 GAS 代碼</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> line_notify_token = <span class="string">"Line Notify 的權杖代碼"</span>;</span><br><span class="line">  sendMsg(<span class="string">"想要傳送的訊息"</span>, line_notify_token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params">msg, token</span>) </span>&#123;</span><br><span class="line">  UrlFetchApp.fetch(<span class="string">"https://notify-api.line.me/api/notify"</span>, &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      Authorization: <span class="string">"Bearer "</span> + token,</span><br><span class="line">    &#125;,</span><br><span class="line">    method: <span class="string">"post"</span>,</span><br><span class="line">    payload: &#123;</span><br><span class="line">      message: msg,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="lightcoral">註：doPost 這個方法是 GAS 定義的 API，<br>表示外部用 Post 方法 call 這隻網址時會執行這個方法。</font></p>
<p>但基本上自動排程不需要從外部呼叫<br>可以直接從<strong>內部設定</strong></p>
<h3 id="4-部署"><a href="#4-部署" class="headerlink" title="4.部署"></a>4.部署</h3><h4 id="點擊右上方：部署-gt-部署作業"><a href="#點擊右上方：部署-gt-部署作業" class="headerlink" title="點擊右上方：部署 -&gt; 部署作業"></a>點擊右上方：部署 -&gt; 部署作業</h4><h4 id="網頁應用程式下方會有兩個欄位"><a href="#網頁應用程式下方會有兩個欄位" class="headerlink" title="網頁應用程式下方會有兩個欄位"></a>網頁應用程式下方會有兩個欄位</h4><table>
<thead>
<tr>
<th>欄位</th>
<th>選項與選擇</th>
</tr>
</thead>
<tbody><tr>
<td>執行身份</td>
<td>我</td>
</tr>
<tr>
<td>誰可以存取</td>
<td>所有人</td>
</tr>
</tbody></table>
<h3 id="5-設定觸發條件"><a href="#5-設定觸發條件" class="headerlink" title="5.設定觸發條件"></a>5.設定觸發條件</h3><h4 id="點擊左側選單：觸發條件"><a href="#點擊左側選單：觸發條件" class="headerlink" title="點擊左側選單：觸發條件"></a>點擊左側選單：<strong>觸發條件</strong></h4><h4 id="點擊右下角：新增觸發條件"><a href="#點擊右下角：新增觸發條件" class="headerlink" title="點擊右下角：新增觸發條件"></a>點擊右下角：<strong>新增觸發條件</strong></h4><h4 id="設定觸發條件的欄位"><a href="#設定觸發條件的欄位" class="headerlink" title="設定觸發條件的欄位"></a>設定觸發條件的欄位</h4><table>
<thead>
<tr>
<th>欄位</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td>選擇您要執行的功能</td>
<td>就是要執行的 function，這邊就選 doPost</td>
</tr>
<tr>
<td>選擇應執行的部署作業</td>
<td>上端，就是指最後部署的程式代碼，這邊選上端。<br><strong>這樣每次重新部署就會套用最新的代碼</strong></td>
</tr>
<tr>
<td>選取活動來源</td>
<td>時間驅動或是日曆驅動</td>
</tr>
<tr>
<td>選取時間型觸發條件類型</td>
<td>時間驅動可以選擇：特定，分鐘，小時，日，週，月</td>
</tr>
<tr>
<td>選取時段</td>
<td>根據時間類型的結果選擇</td>
</tr>
</tbody></table>
<p><font color="lightcoral">註：時間驅動的日行程有一個大坑。</font><br>你會發現選項都是區間而不是整點<br>像是下午 1 點到下午 2 點這樣</p>
<p>那到底觸發的時間會是？？？</p>
<p>我之前網上查的結果是會在這區間內的一個時間點執行！？<br>那我自己實測的結果是剛好都會落在<strong>某整點的 35 分鐘</strong>…</p>
<h2 id="建立-Google-Sheets"><a href="#建立-Google-Sheets" class="headerlink" title="建立 Google Sheets"></a>建立 Google Sheets</h2><h3 id="1-登入-Google-Sheets"><a href="#1-登入-Google-Sheets" class="headerlink" title="1.登入 Google Sheets"></a>1.登入 <a href="https://docs.google.com/spreadsheets" target="_blank" rel="noopener">Google Sheets</a></h3><h3 id="2-建立表單並記錄-SPREADSHEET-ID"><a href="#2-建立表單並記錄-SPREADSHEET-ID" class="headerlink" title="2.建立表單並記錄 SPREADSHEET_ID"></a>2.建立表單並記錄 SPREADSHEET_ID</h3><p>SPREADSHEET_ID 可以直接看網址列得知：</p>
<p><code>https://docs.google.com/spreadsheets/d/SPREADSHEET_ID/</code></p>
<h3 id="3-建立表單欄位"><a href="#3-建立表單欄位" class="headerlink" title="3.建立表單欄位"></a>3.建立表單欄位</h3><p>一個簡單的範例：</p>
<table>
<thead>
<tr>
<th>主題</th>
<th>內容</th>
</tr>
</thead>
<tbody><tr>
<td>訊息 1</td>
<td>早安</td>
</tr>
<tr>
<td>訊息 2</td>
<td>午安</td>
</tr>
<tr>
<td>訊息 3</td>
<td>一起說</td>
</tr>
</tbody></table>
<h3 id="4-更新-GAS-內容"><a href="#4-更新-GAS-內容" class="headerlink" title="4.更新 GAS 內容"></a>4.更新 GAS 內容</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> line_notify_token = <span class="string">"Line Notify 權杖代碼"</span>;</span><br><span class="line">  <span class="keyword">var</span> SPREADSHEET_ID = <span class="string">"SPREADSHEET_ID"</span>;</span><br><span class="line">  <span class="comment">// 選取試算表</span></span><br><span class="line">  <span class="keyword">var</span> spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);</span><br><span class="line">  <span class="comment">// 選取試算表中的工作表</span></span><br><span class="line">  <span class="keyword">var</span> sheet = spreadsheet.getSheets()[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 選取工作表中除第一列的所有填寫內容</span></span><br><span class="line">  <span class="keyword">var</span> range = sheet.getRange(</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    sheet.getLastRow() - <span class="number">1</span>,</span><br><span class="line">    sheet.getLastColumn()</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 取值</span></span><br><span class="line">  <span class="keyword">var</span> rows = range.getValues();</span><br><span class="line">  <span class="comment">// 將每一列內容以單個訊息發送</span></span><br><span class="line">  rows.forEach(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    sendMsg(<span class="string">"\n"</span> + i[<span class="number">0</span>] + <span class="string">"\n"</span> + i[<span class="number">1</span>], line_notify_token);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params">msg, token</span>) </span>&#123;</span><br><span class="line">  UrlFetchApp.fetch(<span class="string">"https://notify-api.line.me/api/notify"</span>, &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      Authorization: <span class="string">"Bearer "</span> + token,</span><br><span class="line">    &#125;,</span><br><span class="line">    method: <span class="string">"post"</span>,</span><br><span class="line">    payload: &#123;</span><br><span class="line">      message: msg,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>到這裡就完成了一個簡易自動排程的通知功能<br>接下來就是等待設定好的觸發時間<br>然後收已經在 Google Sheet 裡面寫好的訊息！</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/08/02/LINE-Notify-排程通知/">https://davidblog.github.io/2023/08/02/LINE-Notify-排程通知/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>Data URL vs Blob URL</title>
    <url>/2023/06/08/Data-URL-vs-Blob-URL/</url>
    <content><![CDATA[<p>網頁應用常見的資源網址除了 http URL 外,<br>還有 Data URL 及 Blob URL</p>
<p>這兩種類型的網址，也很常用在資源下載及顯示<br>內文將介紹這兩種 URL 的基本使用方法</p>
<ul>
<li>Data URL (資料網址)</li>
<li>Blob URL (二進制大型物件網址)</li>
<li>附註常見的 MIME 類型 （Media Type）</li>
</ul>
<a id="more"></a>

<h2 id="Data-URL-資料網址"><a href="#Data-URL-資料網址" class="headerlink" title="Data URL (資料網址)"></a>Data URL (資料網址)</h2><p>Data URL 可以使資源以文本格式直接鑲嵌在 HTML 中使用<br>如常見的圖片以 base64 置入於 img 標籤的 src 內<br>也可以將其放入 a 標籤的 href 內供使用者下載</p>
<p>Data URL 的基本編碼格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data:[media type][;編碼格式],編碼</span><br></pre></td></tr></table></figure>

<p>圖片範例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data:image&#x2F;png;base64,[base64代碼]</span><br></pre></td></tr></table></figure>

<p>純文字範例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data:text&#x2F;plain;charset&#x3D;utf-8,[字串符]</span><br></pre></td></tr></table></figure>

<p>圖片資源加載範例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;data:image&#x2F;png;base64,[base64代碼]&quot; alt&#x3D;&quot;圖片描述&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>圖片資源下載範例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;data:image&#x2F;png;base64,[base64代碼]&quot; download&#x3D;&quot;檔案名稱&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Blob-URL-二進制大型物件網址"><a href="#Blob-URL-二進制大型物件網址" class="headerlink" title="Blob URL (二進制大型物件網址)"></a>Blob URL (二進制大型物件網址)</h2><p>Blob URL 可以生成一個暫時的網址<br>並將其資源暫放在瀏覽器的記憶體中</p>
<p>創建 Blob URL 範例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const string &#x3D; &#39;Hello Blob URL&#39;;</span><br><span class="line">const file &#x3D; new Blob([string], &#123;type: text&#x2F;plain&#125;);</span><br><span class="line">const BlobURL &#x3D; URL.createObjectURL(file); &#x2F;&#x2F; 這個就是Blob URL</span><br></pre></td></tr></table></figure>

<p>使用 Blob URL 下載檔案的範例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const link &#x3D; document.createElement(&#39;a&#39;);</span><br><span class="line">link.href &#x3D; BlobURL;</span><br><span class="line">link.download &#x3D; &#39;檔案名稱&#39;;</span><br><span class="line">link.click();</span><br></pre></td></tr></table></figure>

<p>清除下載連結及釋放記憶體</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link.href &#x3D; &quot;&quot;;</span><br><span class="line">URL.revokeObjectURL(BlobURL);</span><br></pre></td></tr></table></figure>

<h2 id="附註常見的-MIME-類型-（Media-Type）"><a href="#附註常見的-MIME-類型-（Media-Type）" class="headerlink" title="附註常見的 MIME 類型 （Media Type）"></a>附註常見的 MIME 類型 （Media Type）</h2><table>
<thead>
<tr>
<th>MIME 類型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>text/plain</td>
<td>純文本檔案的 MIME 類型</td>
</tr>
<tr>
<td>text/html</td>
<td>HTML 檔案的 MIME 類型</td>
</tr>
<tr>
<td>text/css</td>
<td>CSS 檔案的 MIME 類型</td>
</tr>
<tr>
<td>text/markdown</td>
<td>Markdown 檔案的 MIME 類型</td>
</tr>
<tr>
<td>application/javascript</td>
<td>JavaScript 檔案的 MIME 類型</td>
</tr>
<tr>
<td>application/json</td>
<td>JSON 檔案的 MIME 類型</td>
</tr>
<tr>
<td>application/xml</td>
<td>XML 檔案的 MIME 類型</td>
</tr>
<tr>
<td>image/jpeg</td>
<td>JPEG 圖像檔案的 MIME 類型</td>
</tr>
<tr>
<td>image/png</td>
<td>PNG 圖像檔案的 MIME 類型</td>
</tr>
<tr>
<td>image/gif</td>
<td>GIF 圖像檔案的 MIME 類型</td>
</tr>
<tr>
<td>audio/mpeg</td>
<td>MPEG 音訊檔案的 MIME 類型</td>
</tr>
<tr>
<td>audio/wav</td>
<td>WAV 音訊檔案的 MIME 類型</td>
</tr>
<tr>
<td>video/mp4</td>
<td>MP4 視訊檔案的 MIME 類型</td>
</tr>
<tr>
<td>video/mpeg</td>
<td>MPEG 視訊檔案的 MIME 類型</td>
</tr>
<tr>
<td>application/pdf</td>
<td>PDF 檔案的 MIME 類型</td>
</tr>
<tr>
<td>application/zip</td>
<td>ZIP 壓縮檔案的 MIME 類型</td>
</tr>
</tbody></table>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/06/08/Data-URL-vs-Blob-URL/">https://davidblog.github.io/2023/06/08/Data-URL-vs-Blob-URL/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>AJAX 動態資料串接</title>
    <url>/2020/06/20/ajax/</url>
    <content><![CDATA[<p>A: 這個是用 ajax 作的嗎<br>B: ajax 還是 $.ajax 呢</p>
<p>AJAX 可以說是前端最重要的技術沒有之一<br>主要功用是在不重刷頁面下作局部資料的動態更新</p>
<p>底下介紹常用的 ajax 技術</p>
<p>內文</p>
<ul>
<li>xhr</li>
<li>$.ajax</li>
<li>fetch</li>
<li>axios</li>
</ul>
<a id="more"></a>

<h1 id="xhr"><a href="#xhr" class="headerlink" title="xhr"></a>xhr</h1><br>

<p>xhr 是最古老的 Ajax 技術 現在已經很少使用<br>但如果是為了支援一些古老的版本的瀏覽器 可以稍微認識一下<br>先來看一下簡單的代碼範例<br>此範例用於 get 方法請求取得隨機狗狗圖片的 JSON 資料</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宣告請求成功和失敗的函式 (此函式為請求成功或失敗後的 callback)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reqOnload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.responseText);</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reqError</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 XMLHttpRequest 物件 (在 console 裡 type 此物件即可以見當前狀態所有屬性內容)</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 設定方法與 url</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"https://dog.ceo/api/breeds/image/random"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 送出</span></span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line">xhr.onload = reqOnload;</span><br><span class="line">xhr.onerror = reqError;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;message: "https://images.dog.ceo/breeds/groenendael/n02105056_4591.jpg", status: "success"&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>補充 (設定標頭)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">"token"</span>, <span class="string">"wefuni2hu43f9hr"</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json; charset=utf-8"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>補充 (post 方法下設定 payload)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.send(<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">key</span>: <span class="string">"value"</span> &#125;));</span><br></pre></td></tr></table></figure>

<h1 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax"></a>$.ajax</h1><br>

<p>此方法為 jQuery 所提供的 ajax 方法 實際上由 xhr 所封裝的<br>如果專案下以有引用此 library<br>則可以直接使用此方法<br>底下為代碼的部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建立 請求物件</span></span><br><span class="line"><span class="keyword">const</span> requestOptions = &#123;</span><br><span class="line">  url: <span class="string">"https://dog.ceo/api/breeds/image/random"</span>,</span><br><span class="line">  type: <span class="string">"get"</span>, <span class="comment">//</span></span><br><span class="line">  dataType: <span class="string">"json"</span>, <span class="comment">// server的回傳格式</span></span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 請求成功的callback</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 請求失敗的callback</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 送出請求</span></span><br><span class="line">$.ajax(requestOptions);</span><br></pre></td></tr></table></figure>

<p><strong>補充(post 方法的 payload)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">requestOptions.type = <span class="string">"post"</span>; <span class="comment">// 請求方法</span></span><br><span class="line">requestOptions.data = payload; <span class="comment">// payload</span></span><br></pre></td></tr></table></figure>

<h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><br>

<p>fetch 是一個 HTML5 的 API 會回傳一個 es6 的 promise 物件<br>如果是在主流瀏覽器的執行環境下是可以直接使用的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">"https://dog.ceo/api/breeds/image/random"</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> res.json())</span><br><span class="line">  .then(<span class="function">(<span class="params">json</span>) =&gt;</span> <span class="built_in">console</span>.log(json))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>

<p><strong>補充 (加入其他 options)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  method: <span class="string">"POST"</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    email: <span class="string">"xxx@mail.com"</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fetch(url, options)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> res.json())</span><br><span class="line">  .then(<span class="function">(<span class="params">json</span>) =&gt;</span> <span class="built_in">console</span>.log(json))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>

<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><br>

<p>一個非常流行的三方套件<br>支持瀏覽器中發送 XMLHttpRequests 與 Promise API<br>底下為參考的代碼範例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  method: <span class="string">"get"</span>,</span><br><span class="line">  url: <span class="string">"https://dog.ceo/api/breeds/image/random"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">axios.request(options);</span><br></pre></td></tr></table></figure>

<p><strong>補充 (post payload)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">options.method = <span class="string">"post"</span>;</span><br><span class="line">options.headers = &#123; <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span> &#125;;</span><br><span class="line">options.data = payload;</span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/20/ajax/">https://davidblog.github.io/2020/06/20/ajax/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>Babel JS編譯器</title>
    <url>/2020/06/21/babel/</url>
    <content><![CDATA[<p>JavaScript 的語法主要由 ECMA 組織所訂定<br>而語法上的支援則由各家瀏覽器來實作</p>
<p>Babel 是 JavsScript 的編譯器<br>可以用來將 ES5+ 的版本轉譯為兼容各瀏覽器可運行的語法</p>
<p>工作實務上則是為了能讓腳本兼容低階瀏覽器所造成的問題</p>
<p>本篇介紹 babel 的簡單使用方式</p>
<p>內文</p>
<ul>
<li>babel 相依套件</li>
<li>babel 基本安裝</li>
<li>babel 基本設定</li>
<li>babel 基本使用</li>
</ul>
<a id="more"></a>

<h1 id="babel-相依套件"><a href="#babel-相依套件" class="headerlink" title="babel 相依套件"></a>babel 相依套件</h1><br>

<ul>
<li>babel-core</li>
</ul>
<p>babel 的核心模組</p>
<ul>
<li>babel-loader</li>
</ul>
<p>提供 webpack 在讀取腳本時, 使用 baebl 讀取</p>
<ul>
<li>babel-preset-env</li>
</ul>
<p>為轉譯的預設<br>決定 babel 如何轉譯<br>如果沒有設定 preset<br>轉譯的代碼會原封不動的複製一份</p>
<ul>
<li>babel-cli</li>
</ul>
<p>能夠在 CLI 上直接使用 babel</p>
<ul>
<li>babel-polyfill</li>
</ul>
<p>babel 主要只提供語法轉換<br>像是新版的 API (Promise, Array.from, Object.assign …)<br>則需要此套件來協助處理</p>
<h1 id="babel-基本安裝"><a href="#babel-基本安裝" class="headerlink" title="babel 基本安裝"></a>babel 基本安裝</h1><br>

<p>本篇介紹最基本的使用<br>只需要安裝以下兩項套件即可</p>
<ul>
<li>babel-cli</li>
<li>babel-preset-env</li>
</ul>
<p><code>npm i -D babel-cli babel-preset-env</code></p>
<h1 id="babel-基本設定"><a href="#babel-基本設定" class="headerlink" title="babel 基本設定"></a>babel 基本設定</h1><br>

<p>有多種方式可以設定 babel<br>底下介紹常用的兩種方式(選其中一種即可):</p>
<p><strong>第一種</strong></p>
<p>在 <code>package.json</code> 內新增以下設定</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"babel": &#123;</span><br><span class="line">    "presets": ["env"]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二種</strong></p>
<p>在專案目錄下新增 <code>.babelrc</code> 檔案並作以下設定</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="babel-基本使用"><a href="#babel-基本使用" class="headerlink" title="babel 基本使用"></a>babel 基本使用</h1><br>

<p>有多種使用方式<br>底下介紹常用的兩種方式</p>
<p><strong>直接在 CLI 下指令</strong></p>
<p><code>npx babel &lt;檔案&gt; --out-dir &lt;資料夾&gt;</code></p>
<p>p.s. 如果加上參數 –presets=babel-preset-env 則可以不用設定另外設定 preset</p>
<p><strong>在 package.json 中設定指令後提供 CLI 使用</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "build": "babel &lt;檔案&gt; --out-dir &lt;資料夾&gt;"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p><code>npm run build</code></p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/21/babel/">https://davidblog.github.io/2020/06/21/babel/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>Open Graph 開放社交關係圖</title>
    <url>/2023/08/31/Open-Graph-%E9%96%8B%E6%94%BE%E7%A4%BE%E4%BA%A4%E9%97%9C%E4%BF%82%E5%9C%96/</url>
    <content><![CDATA[<p>認識 Open Graph，<br>讓你的網站在社交媒體上漂亮的分享!<br>或是避免被當成詐騙網站 (&gt;﹏&lt;)</p>
<ul>
<li>Open Graph 介紹</li>
<li>OG 設定與解說<blockquote>
<ul>
<li>代碼範例</li>
<li>og:type 的種類</li>
<li>套用 Open Graph 設定的社交媒體網站</li>
<li>常見社群的 Open Graph (OG) 預覽圖片尺寸推薦</li>
<li>測試工具</li>
</ul>
</blockquote>
</li>
</ul>
<a id="more"></a>

<h2 id="Open-Graph-介紹"><a href="#Open-Graph-介紹" class="headerlink" title="Open Graph 介紹"></a>Open Graph 介紹</h2><p>Open Graph 是一種協議，<br>讓你的網站在社交媒體上分享時能呈現更好的預覽內容。</p>
<p>這邊附上官方的資訊 <a href="https://ogp.me/" target="_blank" rel="noopener">The Open Graph protocol</a></p>
<blockquote>
<p>The Open Graph protocol enables any web page to become a rich object in a social graph.<br>For instance, this is used on Facebook to allow any web page to have the same functionality as any other object on Facebook.</p>
</blockquote>
<h2 id="OG-設定與解說"><a href="#OG-設定與解說" class="headerlink" title="OG 設定與解說"></a>OG 設定與解說</h2><h3 id="代碼範例"><a href="#代碼範例" class="headerlink" title="代碼範例"></a>代碼範例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Open Graph 設定 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:title"</span> <span class="attr">content</span>=<span class="string">"你的網頁標題"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:description"</span> <span class="attr">content</span>=<span class="string">"網頁的描述內容"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:image"</span> <span class="attr">content</span>=<span class="string">"網頁的分享圖片 URL"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:type"</span> <span class="attr">content</span>=<span class="string">"website"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:url"</span> <span class="attr">content</span>=<span class="string">"你的網頁 URL"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- SEO 設定 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>你的網頁標題<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"網頁的描述內容"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="og-type-的種類"><a href="#og-type-的種類" class="headerlink" title="og:type 的種類"></a>og:type 的種類</h3><table>
<thead>
<tr>
<th align="center">類型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">website</td>
<td align="center">整個網站的類型。通常用於網站首頁。</td>
</tr>
<tr>
<td align="center">article</td>
<td align="center">文章類型的內容，如新聞、部落格文章等。</td>
</tr>
<tr>
<td align="center">video</td>
<td align="center">影片類型的內容，可以是影片網址或頁面。</td>
</tr>
<tr>
<td align="center">music.song</td>
<td align="center">音樂單曲或歌曲的類型。</td>
</tr>
<tr>
<td align="center">music.album</td>
<td align="center">音樂專輯的類型。</td>
</tr>
<tr>
<td align="center">music.playlist</td>
<td align="center">音樂播放清單的類型。</td>
</tr>
<tr>
<td align="center">book</td>
<td align="center">書籍類型的內容，如小說、散文等。</td>
</tr>
<tr>
<td align="center">profile</td>
<td align="center">個人或專頁類型的內容，如社交媒體資料。</td>
</tr>
<tr>
<td align="center">place</td>
<td align="center">地點類型的內容，如商家、餐廳、景點等。</td>
</tr>
<tr>
<td align="center">product</td>
<td align="center">實物或數位產品類型的內容，如商品頁面。</td>
</tr>
</tbody></table>
<h3 id="套用-Open-Graph-設定的社交媒體網站"><a href="#套用-Open-Graph-設定的社交媒體網站" class="headerlink" title="套用 Open Graph 設定的社交媒體網站"></a>套用 Open Graph 設定的社交媒體網站</h3><ul>
<li>Facebook</li>
<li>Line</li>
<li>Instagram (透過分享到 Facebook)</li>
<li>Twitter</li>
<li>LinkedIn</li>
<li>Pinterest</li>
<li>WhatsApp</li>
</ul>
<h3 id="常見社群的-Open-Graph-OG-預覽圖片尺寸推薦"><a href="#常見社群的-Open-Graph-OG-預覽圖片尺寸推薦" class="headerlink" title="常見社群的 Open Graph (OG) 預覽圖片尺寸推薦"></a>常見社群的 Open Graph (OG) 預覽圖片尺寸推薦</h3><table>
<thead>
<tr>
<th>平台</th>
<th>圖片尺寸（像素）</th>
<th>最小尺寸（像素）</th>
<th>最大圖片大小</th>
<th>備註</th>
</tr>
</thead>
<tbody><tr>
<td>Facebook</td>
<td>1200 x 630</td>
<td>600 x 315</td>
<td>5 MB</td>
<td></td>
</tr>
<tr>
<td>Twitter</td>
<td>1200 x 675</td>
<td>300 x 157</td>
<td>5 MB</td>
<td></td>
</tr>
<tr>
<td>LinkedIn</td>
<td>1200 x 627</td>
<td>80 x 150</td>
<td>5 MB</td>
<td></td>
</tr>
<tr>
<td>Instagram</td>
<td>1080 x 1080</td>
<td>–</td>
<td>5 MB</td>
<td>方形圖片推薦</td>
</tr>
<tr>
<td></td>
<td>1080 x 566</td>
<td>–</td>
<td></td>
<td>橫向圖片推薦</td>
</tr>
<tr>
<td></td>
<td>1080 x 1350</td>
<td>–</td>
<td></td>
<td>直向圖片推薦</td>
</tr>
<tr>
<td>Pinterest</td>
<td>600 x 900</td>
<td>100 x 200</td>
<td>20 MB</td>
<td></td>
</tr>
<tr>
<td>LINE</td>
<td>1200 x 627</td>
<td>–</td>
<td>10 MB</td>
<td>方形圖片推薦</td>
</tr>
</tbody></table>
<h3 id="測試工具"><a href="#測試工具" class="headerlink" title="測試工具"></a>測試工具</h3><ul>
<li><a href="https://developers.facebook.com/tools/debug/" target="_blank" rel="noopener">Facebook Object Debugger</a></li>
<li><a href="https://www.opengraph.xyz/" target="_blank" rel="noopener">Free Open Graph Generator and Preview</a></li>
</ul>
<h4 id="Facebook-Object-Debugger"><a href="#Facebook-Object-Debugger" class="headerlink" title="Facebook Object Debugger"></a><a href="https://developers.facebook.com/tools/debug/" target="_blank" rel="noopener">Facebook Object Debugger</a></h4><p>Facebook 提供的測試工具，<br>可以檢視網站分享時的預覽內容。</p>
<p><strong>預覽圖：</strong></p>
<p><img src="/images/blog/og-1.png" alt=""></p>
<h4 id="Free-Open-Graph-Generator-and-Preview"><a href="#Free-Open-Graph-Generator-and-Preview" class="headerlink" title="Free Open Graph Generator and Preview"></a><a href="https://www.opengraph.xyz/" target="_blank" rel="noopener">Free Open Graph Generator and Preview</a></h4><p>這個網站能夠同時看到：Facebook, Twitter, Linkedin, Discord 的分享連結預覽內容。</p>
<p><strong>預覽圖：</strong></p>
<p><img src="/images/blog/og-2.png" alt=""></p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/08/31/Open-Graph-開放社交關係圖/">https://davidblog.github.io/2023/08/31/Open-Graph-開放社交關係圖/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>久違的更新</title>
    <url>/2023/05/20/blogHistory/</url>
    <content><![CDATA[<p>部落格近3年久違的更新<br>回憶起這個部落格只有在建立初起比較常使用<br>後續就默默的擺著  </p>
<p>幾乎所有應用只要一陣子沒更新就會出問題<br>這個部落格也不例外</p>
<p>底下就來講講這裡曾經發生過的事吧</p>
<ul>
<li>部落格起源</li>
<li>Hexo 選用的主題不再更新 而導致版面出問題</li>
<li>網域沒有續約 網址失效 導致網站無法正常訪問</li>
<li>google 搜尋引擎找不到部落格的文章了</li>
</ul>
<a id="more"></a>

<h2 id="部落格起源"><a href="#部落格起源" class="headerlink" title="部落格起源"></a>部落格起源</h2><p>最初建立這個部落格<br>除了想記錄自己的學習歷程<br>也想留下一個類似作品集的東西  </p>
<p>不過沒有選擇作品集而是部落格<br>是因為部落格更務實<br>而且使用上更方便  </p>
<p>這個部落格始終是放在 github page 上的<br>但當初為了讓這個網站看起來更專業<br>就去 GoDaddy 租了個兩年的網域<br>然後用 CloudFlare 來做網站託管<br>這樣就有一個專門的網址可以連到我的網站<br>也可以在 google 上搜尋到這格部落格裡的文章</p>
<p>CloudFlare 除了可以免費託管網站<br>還提供了免費的CDN和SSL憑證相當不錯</p>
<p>印象中這個部落格有出現過幾次問題</p>
<h2 id="Hexo-選用的主題不再更新-而導致版面出問題"><a href="#Hexo-選用的主題不再更新-而導致版面出問題" class="headerlink" title="Hexo 選用的主題不再更新 而導致版面出問題"></a>Hexo 選用的主題不再更新 而導致版面出問題</h2><p>這個部落格是用 Hexo 這個框架來做的<br>裡面有提供很多很棒的版型稱為主題<br>我當初選了一個挺熱門的主題滿多工程師在用的<br>不過後續這個主題沒有更新<br>版面就出現一些奇怪的問題<br>後來上網查很多人都有遇到這個問題<br>幸運的是有找到他們提供解決的辦法<br>不過我有點忘記solution是直接換一個主題<br>還是根據原本的主題進行了局部的修改才把它搞好…<br>總之現在的版面是一個叫 next 的主題</p>
<h2 id="網域沒有續約-網址失效-導致網站無法正常訪問"><a href="#網域沒有續約-網址失效-導致網站無法正常訪問" class="headerlink" title="網域沒有續約 網址失效 導致網站無法正常訪問"></a>網域沒有續約 網址失效 導致網站無法正常訪問</h2><p>當初是把部落格設置在github page主頁<br>另外有設置CNAME及一些自動轉址的功能<br>例如你從github page進來也會直接換到我的網域<br>讓人看不出這個網站是放在github上面<br>不過網域沒有續約就要把CNAME和自動轉址的功能拿掉<br>這樣才能在github page上正常的讓人訪問</p>
<h2 id="google-搜尋引擎找不到部落格的文章了"><a href="#google-搜尋引擎找不到部落格的文章了" class="headerlink" title="google 搜尋引擎找不到部落格的文章了"></a>google 搜尋引擎找不到部落格的文章了</h2><p>最近有在研究一些關於 seo 的東西<br>有發現我的部落格在 google 引擎上已經找不到了<br>據我目前搜集的資訊了解<br>是因為 google 爬蟲不會特別去爬 github 上的 github page<br>可是可以用 google 提供的 search console 主動提供網站資訊<br>讓爬蟲建立網站索引<br>所以我就小小的更新了一下 Blog 順便發篇文<br>順利的話之後這裡的文章也可以在 google 上直接找到囉~</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/05/20/blogHistory/">https://davidblog.github.io/2023/05/20/blogHistory/</a> </p>
]]></content>
      <categories>
        <category>部落格歷史</category>
      </categories>
  </entry>
  <entry>
    <title>VR 遊戲介紹</title>
    <url>/2023/08/09/VR-%E9%81%8A%E6%88%B2%E4%BB%8B%E7%B4%B9/</url>
    <content><![CDATA[<p>之前的文章有介紹過<a href="/2023/08/06/%E6%88%91%E7%9A%84%E9%81%8A%E6%88%B2%E4%B8%BB%E6%A9%9F">我的遊戲機</a><br>裡面有提到我在 Oculus Quest 2 玩過的遊戲</p>
<table>
<thead>
<tr>
<th><img alt="遊戲大廳" src="/images/vr/lobby.jpg" style="margin-bottom: 0" /></th>
<th><img alt="遊戲大廳" src="/images/vr/lobby2.jpg" style="margin-bottom: 0" /></th>
</tr>
</thead>
</table>
<p>這篇是遊戲心得與介紹：</p>
<ul>
<li>Beat Saber</li>
<li>REAL VR FISHING</li>
<li>THRILL OF THE FIGHT</li>
<li>Warplanes: Battles over Pacific</li>
<li>Netflix</li>
<li>Mondly:在 VR 中練習語言</li>
<li>Eleven Table Tennis</li>
<li>The Room VR: A Dark Matter</li>
<li>Zenith: The Last City</li>
</ul>
<a id="more"></a>

<h2 id="Beat-Saber"><a href="#Beat-Saber" class="headerlink" title="Beat Saber"></a>Beat Saber</h2><p><img src="/images/vr/beat-saber.jpg" alt=""></p>
<h3 id="個人評價"><a href="#個人評價" class="headerlink" title="個人評價"></a>個人評價</h3><ul>
<li>舒適度：★★★★☆</li>
<li>推薦度：★★★★☆</li>
</ul>
<h3 id="遊玩心得"><a href="#遊玩心得" class="headerlink" title="遊玩心得"></a>遊玩心得</h3><p>這是一款光劍的節奏打擊遊戲，<br>應該也是很多入門玩家的第一款遊戲，<br>簡單好上手又可以聽音樂，<br>除了單機還可以多人一起玩。<br>(比分模式，看誰 combo 的多 ↖(^ω^)↗)</p>
<p>打擊的難易度可以自行設定，<br>困難模式就是節奏會變很快，<br>看到方塊不斷飛來，<br>如果無法接招，<br>就會進入遊戲失敗 ╮(￣ ▽ ￣””)╭</p>
<p>最重要的是這款遊戲不會 VR 暈<br>所以可以在 VR 使用上有很良好的初體驗！</p>
<p><strong>註：遊戲本體音樂附贈的有限，<br>不過這款遊戲有非常多的擴充包，<br>而且都是熱門音樂，<br>但就是要另外買(很適合燒錢 d(^_^o))</strong></p>
<h2 id="REAL-VR-FISHING"><a href="#REAL-VR-FISHING" class="headerlink" title="REAL VR FISHING"></a>REAL VR FISHING</h2><p><img src="/images/vr/real-vr-fishing.jpg" alt=""></p>
<h3 id="個人評價-1"><a href="#個人評價-1" class="headerlink" title="個人評價"></a>個人評價</h3><ul>
<li>舒適度：★★★★★</li>
<li>推薦度：★★★★★</li>
</ul>
<h3 id="遊玩心得-1"><a href="#遊玩心得-1" class="headerlink" title="遊玩心得"></a>遊玩心得</h3><p>這款遊戲做得真的很棒，<br>也是唯一一款我玩過還特地去官方留言給好評的遊戲，<br>據說是真實場景拍攝所以畫面特別擬真。</p>
<p>你可以在這款遊戲裡做什麼呢？<br>釣魚，賺錢，升級，聊天，認識新朋友，看 Youtube 聽音樂，遊覽世界風景<br>把你釣到的魚放在自家大魚缸，佈置魚缸，邀請朋友來看<br>更衣室可以客製化個人的虛擬角色風格<br>可以用釣魚賺得錢升級釣魚設備，或是買傢俱佈置家裡<br>領取每週獎勵獲得新服裝<br>參加比賽獲得獎品<br>總之～很有潛力的一款遊戲！</p>
<p><strong>註：遊戲內的玩家主要英語居多，<br>有遇過韓語，中文，西班牙語的玩家，<br>年齡層小朋友或是退休的老人，或是青壯年。（老少皆宜）</strong></p>
<h2 id="THRILL-OF-THE-FIGHT"><a href="#THRILL-OF-THE-FIGHT" class="headerlink" title="THRILL OF THE FIGHT"></a>THRILL OF THE FIGHT</h2><p><img src="/images/vr/thrill-of-the-fight.jpg" alt=""></p>
<h3 id="個人評價-2"><a href="#個人評價-2" class="headerlink" title="個人評價"></a>個人評價</h3><ul>
<li>舒適度：★★☆☆☆</li>
<li>推薦度：★★☆☆☆</li>
</ul>
<h3 id="遊玩心得-2"><a href="#遊玩心得-2" class="headerlink" title="遊玩心得"></a>遊玩心得</h3><p>可以和裡面的 AI 打或是打沙包練習<br>和 AI 對打基本上一場下來會爆累 Orz<br>對打時會有點壓迫感因為貼很近<br>那基本上就是一直出拳直到對手倒下<br>可是對手不會輕易倒下( ̀⌄ ́)<br>所以很有氧運動</p>
<p>理論上是一款可以排汗的好遊戲<br>但 Quest2 的頭盔重量會在運動下不斷降低舒適度…  </p>
<h2 id="Warplanes-Battles-over-Pacific"><a href="#Warplanes-Battles-over-Pacific" class="headerlink" title="Warplanes: Battles over Pacific"></a>Warplanes: Battles over Pacific</h2><p><img src="/images/vr/warplanes.jpg" alt=""></p>
<h3 id="個人評價-3"><a href="#個人評價-3" class="headerlink" title="個人評價"></a>個人評價</h3><ul>
<li>舒適度：★☆☆☆☆</li>
<li>推薦度：★☆☆☆☆</li>
</ul>
<h3 id="遊玩心得-3"><a href="#遊玩心得-3" class="headerlink" title="遊玩心得"></a>遊玩心得</h3><p>想要體驗開飛機射擊，<br>選這款遊戲就對了！</p>
<p>想要體驗 VR 暈，<br>也選這款遊戲就對了！</p>
<p>起飛的瞬間，<br>真的很刺激，<br>也很有趣，<br>可是當飛機在上頭轉向時，<br>真的是太恐怖了（VR暈）<br>這款算是我玩過 VR 遊戲中最暈的<br>撐不了幾分鐘就得把遊戲關了</p>
<p>如果沒有 VR 暈體質的人又想開飛機可以嘗試看看<br>說不定其實是一款有趣的遊戲</p>
<p>但我個人有 VR 暈的經驗所以就不太推薦了<br>畢竟人一暈接下來就玩不動了啊！</p>
<h2 id="Netflix"><a href="#Netflix" class="headerlink" title="Netflix"></a>Netflix</h2><p>場景是居家小影廳<br>可以在沙發上看電影！<br>不能截圖ＱＱ</p>
<h3 id="個人評價-4"><a href="#個人評價-4" class="headerlink" title="個人評價"></a>個人評價</h3><ul>
<li>舒適度：★★★☆☆</li>
<li>推薦度：★★★☆☆</li>
</ul>
<h3 id="遊玩心得-4"><a href="#遊玩心得-4" class="headerlink" title="遊玩心得"></a>遊玩心得</h3><p>居家小影廳的氛圍<br>有嘗試在裡面看過幾部電影<br>大螢幕是真的滿爽的<br>畢竟自家的房間不會有那麼大的螢幕</p>
<p>缺點 Quest2 頭盔戴久了還是會疲勞(主要是重量)<br>這讓我感覺 Quest2 頭盔還是適合玩遊戲<br>要看影片的話可能要選其它的VR設備(重量輕的)    </p>
<h2 id="Mondly-在-VR-中練習語言"><a href="#Mondly-在-VR-中練習語言" class="headerlink" title="Mondly:在 VR 中練習語言"></a>Mondly:在 VR 中練習語言</h2><p><img src="/images/vr/mondly.jpg" alt=""></p>
<h3 id="個人評價-5"><a href="#個人評價-5" class="headerlink" title="個人評價"></a>個人評價</h3><ul>
<li>舒適度：★★★★☆</li>
<li>推薦度：★★★★☆</li>
</ul>
<h3 id="遊玩心得-5"><a href="#遊玩心得-5" class="headerlink" title="遊玩心得"></a>遊玩心得</h3><p>可以訓練說外語的膽量<br>裡面有很多不同語言可以選擇<br>我不確定每一個語言都是精準的<br>（就是如果AI聽不懂，是我發音不到位還是AI不給力XD）<br>但我認為英文的精準度還可以  </p>
<p>裡面會有很多主題<br>然後根據主題會有一系列的場景讓你進行對話<br>所以可以學到不同場景的應用對話<br>另外可以自選難度<br>難度高就是沒有文字的輔助提示<br>簡單的就是你答不出來會給你參考的回答選項  </p>
<p>這款遊戲也是挺有潛力的<br>可以看到持續再更新<br>所以就算破完了<br>過一陣子再開可以在破一次<br>因為會有新的內容  </p>
<h2 id="Eleven-Table-Tennis"><a href="#Eleven-Table-Tennis" class="headerlink" title="Eleven Table Tennis"></a>Eleven Table Tennis</h2><p><img src="/images/vr/eleven-table-tennis.jpg" alt=""></p>
<h3 id="個人評價-6"><a href="#個人評價-6" class="headerlink" title="個人評價"></a>個人評價</h3><ul>
<li>舒適度：★★★☆☆</li>
<li>推薦度：★★★☆☆</li>
</ul>
<h3 id="遊玩心得-6"><a href="#遊玩心得-6" class="headerlink" title="遊玩心得"></a>遊玩心得</h3><p>可以和AI打桌球或是和真人打桌球<br>和真人打桌球還會有積分  </p>
<p>我的想法是打休閒娛樂還可以<br>但是比較有造詣的人來打<br>可能會覺得物理引擎有落差  </p>
<p>另外這款遊戲很特別是<br>目前玩過遇到玩家都是講中文的！  </p>
<h2 id="The-Room-VR-A-Dark-Matter"><a href="#The-Room-VR-A-Dark-Matter" class="headerlink" title="The Room VR: A Dark Matter"></a>The Room VR: A Dark Matter</h2><p><img src="/images/vr/the-room-vr.jpg" alt=""></p>
<h3 id="個人評價-7"><a href="#個人評價-7" class="headerlink" title="個人評價"></a>個人評價</h3><ul>
<li>舒適度：★★★★☆</li>
<li>推薦度：★★★★☆</li>
</ul>
<h3 id="遊玩心得-7"><a href="#遊玩心得-7" class="headerlink" title="遊玩心得"></a>遊玩心得</h3><p>很像是密室逃脫的遊戲<br>有詭譎黑暗的神秘氣氛<br>多半時間在解迷<br>和感受神秘氣氛<br>整體來說不錯  </p>
<p>成功解謎會很有成就感</p>
<p>但害怕詭譎氣氛的人可能就不適合  </p>
<p><strong>註：我自己就是有點會害怕詭譎氣氛的人<br>但還是很推薦<br>覺得自己推薦標準非常矛盾</strong></p>
<h2 id="Zenith-The-Last-City"><a href="#Zenith-The-Last-City" class="headerlink" title="Zenith: The Last City"></a>Zenith: The Last City</h2><p><img src="/images/vr/zenith.jpg" alt=""></p>
<h3 id="個人評價-8"><a href="#個人評價-8" class="headerlink" title="個人評價"></a>個人評價</h3><ul>
<li>舒適度：★★☆☆☆</li>
<li>推薦度：★★★★★</li>
</ul>
<h3 id="遊玩心得-8"><a href="#遊玩心得-8" class="headerlink" title="遊玩心得"></a>遊玩心得</h3><p>這款遊戲是我會VR暈但依舊5星推薦的<br>也是即便VR暈也硬著頭皮玩的！  </p>
<p>VR世界的RPG遊戲能給人帶來很多趣味<br>戰鬥系統，寵物系統，任務系統，交易系統，料理系統等等  </p>
<p>另外還會讓人聯想到刀劍神域的動漫  </p>
<p>我在遊戲初期有非常好的體驗<br>裡面的玩家雖然都是講英文居多<br>但是對新玩家都非常友善<br>如果不會玩(像是如何使用魔法，抓寵物，解任務等等)<br>都可以在路上隨機抓玩家求助<br>即便用破破的英文溝通<br>大家也會耐性地幫你解答  </p>
<p>還可以組隊一起打血超厚的BOSS<br>這款遊戲很有潛力<br>更新完也會讓人眼睛為之一亮  </p>
<hr>
<p>後記：</p>
<p>歸納我的推薦標準主要是基於舒適度，<br>畢竟舒適度決定後續玩不玩得下去。</p>
<p>然後再根據遊戲內容有沒有潛力來加分！<br>當然，如果太好玩的話，就別管暈不暈了，快去買暈車藥吧ＸＤ    </p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/08/09/VR-遊戲介紹/">https://davidblog.github.io/2023/08/09/VR-遊戲介紹/</a> </p>
]]></content>
      <categories>
        <category>生活札記</category>
      </categories>
  </entry>
  <entry>
    <title>Bookmarklet 書籤小程式</title>
    <url>/2020/05/31/bml/</url>
    <content><![CDATA[<p>javascript 在客戶端瀏覽器上, 除了console內可以執行外, 也可以在網址列URL上執行, 只需要將協定的部分改為 <code>javascript:</code> 即可, 如: <code>javascript: alert(&#39;Hello Bookmarklet&#39;)</code>, 之前在工作上會寫給一些非開發人員做產品上簡單的測試, 如在CMS後台添加測試資料, 或是在前後台快速登入並執行相關功能, 通常會把書籤程式寫進匿名函式並壓縮成一行, 然後存在 chrome 的書籤裡, 接下來只要在程式要執行的頁面點擊書籤就可以執行程式了</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/05/31/bml/">https://davidblog.github.io/2020/05/31/bml/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>CORS 跨域</title>
    <url>/2020/06/29/cors/</url>
    <content><![CDATA[<p>A: 預檢不過 …<br>B: … postman 沒問題啊<br>A: Ummm…瀏覽器不太一樣…</p>
<p>內文</p>
<ul>
<li>關於跨域<ul>
<li>同源政策</li>
<li>請求類型</li>
<li>preflight</li>
</ul>
</li>
<li>如何解決跨域<ul>
<li>設置正確標頭</li>
<li>使用套件</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h1 id="關於跨域"><a href="#關於跨域" class="headerlink" title="關於跨域"></a>關於跨域</h1><br>

<blockquote>
<p>瀏覽器基於安全性的考量<br>有所謂的同源政策<br>即以 Ajax 發送請求時 默認情況只有同域名下才能互相存取<br>若 port 不同, 子域名不同或協定不同 皆屬於跨域</p>
</blockquote>
<p>一般來說跨域只發生在瀏覽器<br>用伺服器直接發 Request 是沒問題的 (除非 API 本身就有問題 XD)</p>
<p>所以跨域實際上要解決的問題是瀏覽器機制的問題<br>為了解決此問題 我們會需要先知道瀏覽器發送 Request 的機制</p>
<p>當在瀏覽器發送 Request 時<br>主要分兩種類型的請求:</p>
<ul>
<li>簡單請求</li>
<li>複雜請求</li>
</ul>
<p>簡單請求包含以下兩點要素</p>
<ul>
<li>方法為<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
</ul>
</li>
</ul>
<br>

<ul>
<li>只含有簡單請求的標頭<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-type:<ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>

<p>除了簡單請求<br>…<strong>就是複雜請求</strong></p>
<p>而簡單請求與非簡單請求最大的差別就在於…!?</p>
<p><strong>Preflight</strong></p>
<p>如果是複雜請求的話<br>需要特別留意瀏覽器在正式請求前<br>會先發送一個 HTTP OPTIONS 的選項請求<br>當對應的標頭都正確無誤才會發送正式的 Request<br>這個行為被稱為 <strong>預檢</strong></p>
<h1 id="如何解決跨域"><a href="#如何解決跨域" class="headerlink" title="如何解決跨域"></a>如何解決跨域</h1><br>

<p>根據簡單請求與非簡單請求有不同處理方式<br>底下以 node express 來做示範</p>
<ul>
<li>簡單請求跨域:<ul>
<li>API 設定 Access-Control-Allow-Origin 的跨域來源</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>); <span class="comment">// "*" 表示皆開放</span></span><br><span class="line">  res.send(<span class="string">"Success!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`App listening on port <span class="subst">$&#123;port&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>非簡單請求跨域:<ul>
<li>API 設定 Access-Control-Allow-Origin 的跨域來源</li>
<li>外加設定 OPTIONS 的端口<ul>
<li>設定 “Access-Control-Allow-Origin”</li>
<li>設定 “Access-Control-Allow-Headers” (加上額外的 header)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.options(<span class="string">"/test"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type"</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">"/test"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  res.send(<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">token</span>: <span class="string">"Z29vZG1hbg=="</span> &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`App listening on port <span class="subst">$&#123;port&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用套件 cors (簡單請求與複雜請求都可以)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">"cors"</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.use(cors());</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">"/test"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">token</span>: <span class="string">"Z29vZG1hbg=="</span> &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`App listening on port <span class="subst">$&#123;port&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/29/cors/">https://davidblog.github.io/2020/06/29/cors/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>圖片預覽 (FileReader/Data URL)</title>
    <url>/2023/07/12/fileReader/</url>
    <content><![CDATA[<p>之前介紹過 <a href="/2023/06/08/Data-URL-vs-Blob-URL/#more">Data URL</a><br>而這篇文章將補充一個常見的應用場景：圖片預覽</p>
<p>先說明實現圖片預覽的主要流程：</p>
<ul>
<li>根據 input 元素 來上傳圖片</li>
<li>根據 FileReader 物件來讀取圖片的 Data URL</li>
<li>根據 Data URL 將圖片顯示在畫面上</li>
</ul>
<a id="more"></a>

<h2 id="根據-input-元素-來上傳圖片"><a href="#根據-input-元素-來上傳圖片" class="headerlink" title="根據 input 元素 來上傳圖片"></a>根據 input 元素 來上傳圖片</h2><p>內文以 JSX 為範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">"file-upload"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">"file-upload"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">accept</span>=<span class="string">"image/*"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">multiple</span>=<span class="string">&#123;true&#125;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">type</span>=<span class="string">"file"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">display:</span> "<span class="attr">none</span>" &#125;&#125;</span></span><br><span class="line"><span class="tag">          <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> &#123;</span><br><span class="line">            handleFileInputChange(e);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>新增圖片<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>這裡用了一個小技巧隱藏原本的 input 欄位<br>並以 label 的點擊來觸發 input 的點擊效果(for 屬性可以觸發相同 id)<br><strong>備註：JSX 的 for 屬性需要寫成 htmlFor</strong></p>
<p>當選取圖片上傳便會觸發 onChange</p>
<h2 id="根據-FileReader-物件來讀取圖片的-Data-URL"><a href="#根據-FileReader-物件來讀取圖片的-Data-URL" class="headerlink" title="根據 FileReader 物件來讀取圖片的 Data URL"></a>根據 FileReader 物件來讀取圖片的 Data URL</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleFileInputChange</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> files = event.target.files;</span><br><span class="line">  <span class="keyword">const</span> convertedImages = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> file = files[i];</span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> dataURL = e.target.result;</span><br><span class="line">      convertedImages.push(dataURL);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (convertedImages.length === files.length) &#123;</span><br><span class="line">        setPhotoList(convertedImages);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上就是根據迴圈 搭配 FileReader 讀取每個檔案的 Data URL<br>並根據 setPhotoList 將轉換好的 URL 陣列放入 photoList 來重新渲染視圖<br><strong>如果有防呆邏輯也可以在這裡加上(如上傳圖片數量限制等等…)</strong></p>
<h2 id="根據-Data-URL-將圖片顯示在畫面上"><a href="#根據-Data-URL-將圖片顯示在畫面上" class="headerlink" title="根據 Data URL 將圖片顯示在畫面上"></a>根據 Data URL 將圖片顯示在畫面上</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;photoList.map(<span class="function">(<span class="params">url, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;img key=&#123;index&#125; src=&#123;url&#125; alt=<span class="string">""</span> /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;)&#125;</span><br></pre></td></tr></table></figure>

<p>最後一步很單純<br>在專案需要的地方將 photoList 給渲染出來就好了</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/07/12/fileReader/">https://davidblog.github.io/2023/07/12/fileReader/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>React Debounce 去抖動</title>
    <url>/2020/09/26/debounce/</url>
    <content><![CDATA[<p>最近在 app 上寫一個簡單的欄位試算功能<br>有用到去抖動這個小技巧<br>和大家簡單分享一下</p>
<p>內文:</p>
<ul>
<li>Debounce</li>
</ul>
<a id="more"></a>

<h1 id="Debounce"><a href="#Debounce" class="headerlink" title="Debounce"></a>Debounce</h1><br>
去抖動這個技巧
主要是用在避免短時間內重複觸發事件而造成過多不必要的運算

<p>可以利用 useEffect 在原件卸載時 執行 return function 把計時器清除<br>在 update 元件時 重新設定計時器要執行的代碼<br>代碼可參考如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ... 省略 ...</span></span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = amount * rate;</span><br><span class="line">      setResultAmount(result);</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearTimeout(timer);</span><br><span class="line">  &#125;, [amount]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 省略 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/09/26/debounce/">https://davidblog.github.io/2020/09/26/debounce/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>Google AdSense 審查通過了</title>
    <url>/2023/08/29/Google-AdSense-%E5%AF%A9%E6%9F%A5%E9%80%9A%E9%81%8E%E4%BA%86/</url>
    <content><![CDATA[<p>AdSense 是很多部落格的收益來源之一！<br>上個月我也開始嘗試申請，<br>再耐心漫長的等待下…<br>終於！審核通過啦 ↖(^ω^)↗</p>
<p><img src="/images/blog/ad.png" alt=""></p>
<p>底下分享一下這段時間發生的事情吧：</p>
<ul>
<li>歷程</li>
<li>注意事項</li>
<li>感想</li>
<li>後記</li>
</ul>
<a id="more"></a>

<h2 id="歷程"><a href="#歷程" class="headerlink" title="歷程"></a>歷程</h2><p>這邊先列一下表格比較清楚：</p>
<table>
<thead>
<tr>
<th>日期</th>
<th>事件</th>
</tr>
</thead>
<tbody><tr>
<td>0713</td>
<td>開始申請 Google AdSense</td>
</tr>
<tr>
<td>0714</td>
<td>收到提醒尚未完成付款資訊</td>
</tr>
<tr>
<td>0716</td>
<td>完成付款資訊的填寫並開始審查</td>
</tr>
<tr>
<td>0808</td>
<td>收到審查通過的信件</td>
</tr>
<tr>
<td>0828</td>
<td>發現審查通過的信件</td>
</tr>
</tbody></table>
<p>關於驗證所需要的時間，<br>根據 Google 官方的說法如下：</p>
<blockquote>
<p>審查完成後，我們會以電子郵件通知您啟用狀態的相關詳情。<br><strong>這項程序通常會在幾天內完成，但有時最久可能需要 2 週。</strong></p>
</blockquote>
<p>參考網路的上各路資訊，<br>有人是幾天就通過了，<br>也有人要等幾個月。</p>
<p>而我這邊很幸運，<br>經過三周就通過哩！<br><strong>從申請到通過總共是 24 天</strong></p>
<p>但是我是一直到昨天才發現通過的信件 Orz…</p>
<h2 id="注意事項"><a href="#注意事項" class="headerlink" title="注意事項"></a>注意事項</h2><p>最好一開始申請就確定所有資訊都填寫完畢，<br>像是我就是因為<strong>沒有填到付款資訊</strong>，<br>所以把完成申請的時間硬是<strong>延了3 天</strong>…</p>
<p>然後申請通過了以後也要記得：</p>
<ul>
<li>公開賣家資訊</li>
<li>網站根目錄加上 ads.txt 檔案</li>
</ul>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>開始申請兩週內的心情其實還滿忐忑的，<br>因為文章數量不多，<br>SEO的變化又很大 囧，<br>很多文章只被收錄個幾天，<br>就又消失了，<br>完全不知道為什麼ＱＱ  </p>
<p>然後有些頁面已經刪掉了～<br>卻還是被收錄，<br>看了也是有些無言。  </p>
<p>過程中，<br>也嘗試日更，<br>並慢慢的增加文章質量，<br>像是加上圖片 ╮(￣▽￣””)╭<br>還有更多的表格讓文章變得容易閱讀與理解。  </p>
<p>也會去看看不同部落客的申請教學與歷程，<br>有些部落客都會說自己的文章不多，<br>然後幾天就通過了，<br>真是很厲害！</p>
<p>但又讓人備感壓力，<br>想說是不是自己的部落格是不是有什麼潛在的問題 囧<br>像是文章質量太低又沒啥流量…<br>好在沒啥問題，<br>只是時候未到而已  d(^_^o)</p>
<h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>申請 Google AdSense 後，<br>對於部落格的經營與規劃，<br>開始有了比較多深層的想法，<br>不單單只是局限於撰寫技術文章來記錄自身的學習歷程，<br>而是希望能夠充實更多不同類型的內容與功能，<br>讓這裡變得更有趣！  </p>
<p>也開始思考要不要有固定的更新頻率，<br>像是日更，週更還是月更！<br>雖然目前階段還是比較彈性，<br>但相信一定會找到一個比較適合自己的模式！  </p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/08/29/Google-AdSense-審查通過了/">https://davidblog.github.io/2023/08/29/Google-AdSense-審查通過了/</a> </p>
]]></content>
      <categories>
        <category>部落格歷史</category>
      </categories>
  </entry>
  <entry>
    <title>如何擁有一個網站</title>
    <url>/2020/09/13/createWebsite/</url>
    <content><![CDATA[<p>將一個<code>網頁</code>放到一個<code>網頁空間</code><br>再用一個<code>網域</code>指向你的<code>網頁空間</code>即可<br>現在你有一個網站了,只要在瀏覽器的網址列輸入網址,人人都可以連到你的網站囉!</p>
<p>內文</p>
<ul>
<li>如何擁有網頁</li>
<li>如何擁有網域</li>
<li>如何擁有網頁空間</li>
</ul>
<a id="more"></a>

<h1 id="如何擁有網頁"><a href="#如何擁有網頁" class="headerlink" title="如何擁有網頁"></a>如何擁有網頁</h1><p>網頁會是一個副檔名為html的檔案,<br>裡面通常會包含樣式檔css, 與腳本檔案js,<br>這會是組成一個基本網頁的三元素,</p>
<p>我們可以參考 <a href="https://templated.co/" target="_blank" rel="noopener">templated</a> 這個網站<br>裡面提供了非常多的免費模板可供使用, 許可通常是使用模板時在footer附註來源即可,<br>下載下來的模板已經完成了這個部分, 所以基本上可以直接使用,</p>
<p>如何編輯呢,<br>基本上可以使用電腦內建的文字編輯器就可以囉,<br>如果想學習基本網頁的寫法或修改模板內容可以參考 <a href="https://www.w3schools.com/" target="_blank" rel="noopener">w3cschools</a><br>這個網站提供了很棒的入門教學</p>
<h1 id="如何擁有網域"><a href="#如何擁有網域" class="headerlink" title="如何擁有網域"></a>如何擁有網域</h1><p>網域是網站的最重要要素之一,<br>像是一個地址可以讓每個人知道到何處拜訪你,</p>
<p>通常我們會註冊一個頂級域名(如: .com, .io, .org, .tw etc.)<br>然後我們就擁有了這個域名底下的一個二級域名 如 myweb.com<br>這樣你就可以用這個域名來指向你的網站<br>當然你會擁有這個二級域名底下的所有三級域名及N及域名<br>而每個域名你都可以指向一個網站<br>所以當你註冊了一個域名 你可以提供給無數的網站使用XD</p>
<p>底下介紹一個免費的網域註冊網站及一個付費的網域註冊網站</p>
<ul>
<li><a href="https://freenom.com" target="_blank" rel="noopener">freenom</a></li>
<li><a href="https://godaddy.com/" target="_blank" rel="noopener">GoDaddy</a></li>
</ul>
<p>免費的網域可以用來簡單為小網站做測試或練習,<br>但不建議當作正式網站的網域,<br>因為有可能有隨時被停用的風險,<br>或是不能被一些網頁空間作為CNAME使用</p>
<h1 id="如何擁有網頁空間"><a href="#如何擁有網頁空間" class="headerlink" title="如何擁有網頁空間"></a>如何擁有網頁空間</h1><p>網頁空間基本上也分為免費及付費的, 靜態的和動態的<br>如果是靜態網站要使用的, 基本上就是一個網頁伺服器(html server), 相對單純</p>
<p>免費的網頁空間, 通常會有CANME的限制(能不能設定自己的網域), 及可能會有其他廣告的狀況<br>所以申請時需要特別留意此空間的規範是否符合自身的需求</p>
<p>這部分這搜尋引擎上可以找大量的結果<br>所以這邊就不一一介紹了</p>
<p>當然如果熟悉終端機使用的話<br>就可以使用 <a href="https://github.com" target="_blank" rel="noopener">Github</a><br>這個網站是很多工程師常用的代碼倉 裡面也提供 github page 可以用來呈現靜態網站</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/09/13/createWebsite/">https://davidblog.github.io/2020/09/13/createWebsite/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>Docker 虛擬化技術</title>
    <url>/2023/07/29/docker-%E8%99%9B%E6%93%AC%E5%8C%96%E6%8A%80%E8%A1%93/</url>
    <content><![CDATA[<p>Docker 是一個虛擬化技術<br>可以<span style="color: lightcoral">根據映像檔製作獨立的容器來模擬特定環境</span></p>
<p>很多人認識 docker 是為了部署作業<br>不過除了部署還有很多的學習價值<br>像是用來認識不同的作業系統與環境  </p>
<p>底下就來說明 Docker 的基本使用方式吧！</p>
<ul>
<li>用 homebrew 來安裝 Docker</li>
<li>Docker 中的 image 和 container</li>
<li>Docker 的基本指令</li>
<li>替 React 專案撰寫 Dockerfile</li>
</ul>
<a id="more"></a>

<h2 id="用-homebrew-來安裝-Docker"><a href="#用-homebrew-來安裝-Docker" class="headerlink" title="用 homebrew 來安裝 Docker"></a>用 homebrew 來安裝 Docker</h2><p>首先這是 <a href="https://www.docker.com/" target="_blank" rel="noopener">Docker 的官網</a><br>進去可以直接下載 Docker Desktop</p>
<p>因為本身是使用 macOS 作業系統<br>順便推廣一下 <a href="https://brew.sh/index_zh-tw" target="_blank" rel="noopener">homebrew</a><br>homebrew 是一個 macOS 的套件管理工具<br>能以指令的方式統一且輕鬆的管理電腦上安裝的軟體</p>
<p>基本上安裝的軟體都會被放在 <code>/opt/homebrew</code> 下面<br>另外使用 <code>brew list</code> 就可以看見自己安裝過的軟體有哪些</p>
<p>使用 <code>brew search docker</code> 在列表中查看 docker 軟體</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&gt; Formulae</span><br><span class="line">docker                                   docker-machine-driver-vmware</span><br><span class="line">docker-buildx                            docker-machine-driver-vultr</span><br><span class="line">docker-clean                             docker-machine-driver-xhyve</span><br><span class="line">docker-completion                        docker-machine-nfs</span><br><span class="line">docker-compose                           docker-machine-parallels</span><br><span class="line">docker-compose-completion                docker-slim</span><br><span class="line">docker-credential-helper                 docker-squash</span><br><span class="line">docker-credential-helper-ecr             docker-swarm</span><br><span class="line">docker-gen                               docker2aci</span><br><span class="line">docker-ls                                dockerize</span><br><span class="line">docker-machine                           lazydocker</span><br><span class="line">docker-machine-completion                powerman-dockerize</span><br><span class="line">docker-machine-driver-hyperkit           mockery</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; Casks</span><br><span class="line">docker ✔            docker-toolbox      dockey              dozer</span><br></pre></td></tr></table></figure>

<p>可以注意到有兩個分類都有 docker<br>這兩個分類分別是：</p>
<ul>
<li>Formulae</li>
<li>Casks</li>
</ul>
<p>中文名稱是配方(Formulae)和酒桶(Casks)<br>是 homebrew 裡面的術語<br>配方代表的是 CLI 工具(文字指令行介面)<br>酒桶則是 GUI 工具(圖形化使用者介面)</p>
<p>GUI 使用上比較親民也和官網直接下載的一樣<br>另外也同時包含了 CLI 的用法<br>所以可以直接安裝 Casks 裡面的 docker<br>當安裝過後再搜尋時就會看見小勾勾<br>代表這是已經安裝過的軟體</p>
<p>使用 homebrew 安裝 GUI 版本的 docker：</p>
<p><code>brew install --cask docker</code></p>
<h2 id="Docker-中的-image-和-container"><a href="#Docker-中的-image-和-container" class="headerlink" title="Docker 中的 image 和 container"></a>Docker 中的 image 和 container</h2><p>在使用 Docker 前要先認識的兩個術語</p>
<ul>
<li>image 映像檔/鏡像</li>
<li>container 容器</li>
</ul>
<p>image 可以理解為包含了特定服務及環境的模板檔案<br>而 container 則是 image 的運行實例並且和原先的系統有所分隔</p>
<p>至於映像檔有哪些呢？<br>可以到 <a href="https://hub.docker.com/" target="_blank" rel="noopener">docker hub</a> 上面搜索</p>
<h2 id="Docker-的基本指令"><a href="#Docker-的基本指令" class="headerlink" title="Docker 的基本指令"></a>Docker 的基本指令</h2><p>安裝完成後<br>如果直接下 docker 的相關指令會發現無法運行<br>而且會得到底下的訊息：</p>
<blockquote>
<p>Cannot connect to the Docker daemon at unix:///var/run/docker.sock.<br>Is the docker daemon running?</p>
</blockquote>
<p>這則訊息是在說明 daemon 尚未運行<br>翻譯查了一下 daemon 可以叫做<strong>守護進程</strong>或是<strong>常駐程式</strong><br>指在電腦後台運行的程式<br>為使其運行可以直接點擊 docker 圖像啟動<br>或是使用指令 <code>open --background -a docker</code></p>
<p>當安裝完 docker 並確認將其在後台運行後<br>接下來就可以安裝 image 了</p>
<hr>
<p>這邊以下載 nginx 的 image 為例</p>
<p><code>docker pull nginx</code></p>
<p>這樣就可以下載最新版的 nginx image 到本地</p>
<hr>
<p>如果要查看本地已經有的 image 可以使用下面指令</p>
<p><code>docker images</code></p>
<hr>
<p>運行容器方式</p>
<p><code>docker run -d -p 80:80 nginx</code></p>
<table>
<thead>
<tr>
<th>參數</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>daemon -&gt; 守護進程</td>
</tr>
<tr>
<td>-p</td>
<td>port -&gt; local:container -&gt; 表示本機的 80 port 會映射到容器裡的 80 port</td>
</tr>
</tbody></table>
<hr>
<p>另外因為 nginx 是網頁伺服器<br>預設 80port 為其根目錄<br>所以此時本機網址用 localhost 可以看到 nginx 的歡迎畫面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome to nginx!</span><br><span class="line">If you see this page, the nginx web server is successfully installed and working. Further configuration is required.</span><br><span class="line"></span><br><span class="line">For online documentation and support please refer to nginx.org.</span><br><span class="line">Commercial support is available at nginx.com.</span><br><span class="line"></span><br><span class="line">Thank you for using nginx.</span><br></pre></td></tr></table></figure>

<hr>
<p>確認運行中的容器</p>
<p><code>docker ps</code></p>
<table>
<thead>
<tr>
<th>CONTAINER ID</th>
<th>IMAGE</th>
<th>COMMAND</th>
<th>CREATED</th>
<th>STATUS</th>
<th>PORTS</th>
<th>NAMES</th>
</tr>
</thead>
<tbody><tr>
<td>4d251324d169</td>
<td>nginx</td>
<td>“/docker-entrypoint…”</td>
<td>5 minutes ago</td>
<td>Up 5 minutes</td>
<td>0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp</td>
<td>recursing_wilson</td>
</tr>
</tbody></table>
<p>註：<code>docker ps -a</code> 可以查看所有容器包含未運行的</p>
<hr>
<p>再來是進入容器的終端機</p>
<p><code>docker exec -it 4d251324d169 /bin/bash</code></p>
<p>4d251324d169 為上一步驟查到的 CONTAINER ID</p>
<p>-it 每次查這兩個參數都覺得很深奧<br>總之是開啟可以從本機和容器間互動的介面所需要的參數<br>/bin/bash 則是要開啟的終端機</p>
<hr>
<p>離開容器終端機：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@4d251324d169:&#x2F;# exit</span><br></pre></td></tr></table></figure>

<hr>
<p>關閉容器</p>
<p><code>docker stop 4d251324d169</code></p>
<hr>
<p>刪除容器</p>
<p><code>docker rm 4d251324d169</code></p>
<hr>
<p>刪除本地 image</p>
<p><code>docker rmi &lt;image&gt;</code></p>
<hr>
<p>OK..以上的一輪說明已經包含：</p>
<ul>
<li>下載 image</li>
<li>啟動 container</li>
<li>使用 container</li>
<li>關閉 container</li>
<li>刪除 image 和 container</li>
</ul>
<p>真的是又臭又長…</p>
<p><strong>不過恭喜你已經對 docker 的基本使用方式有所了解了</strong></p>
<h2 id="替-React-專案撰寫-Dockerfile"><a href="#替-React-專案撰寫-Dockerfile" class="headerlink" title="替 React 專案撰寫 Dockerfile"></a>替 React 專案撰寫 Dockerfile</h2><p>Dockerfile 是啥呢？<br>主要是一份文檔可以用來製作 image<br>裡面會敘述 image 要包含的指令與配置</p>
<p>底下先提供一份範例：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 Node.js 作為基礎映像</span></span><br><span class="line"><span class="keyword">FROM</span> node:latest as builder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定工作目錄</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 複製整個專案文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安裝依賴項</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行編譯</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Nginx 作為基礎映像</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 React 打包生成的檔案複製到 Nginx 預設的檔案目錄</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/build /usr/share/nginx/html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 複製自定義的 Nginx 配置檔案</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> nginx.conf /etc/nginx/conf.d/default.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定義容器運行時的指令（Nginx 伺服器會自動啟動）</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]</span></span><br></pre></td></tr></table></figure>

<p>這份 dockerfile 會被放在專案的根目錄</p>
<p>最後一步是建構映像檔</p>
<p><code>docker build -t name:version -f Dockerfile .&quot;</code></p>
<ul>
<li>-t: 用來打標籤名稱和版本號</li>
<li>-f Dockerfile 表示套用的檔案</li>
<li>. 表示當前目錄</li>
</ul>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/07/29/docker-虛擬化技術/">https://davidblog.github.io/2023/07/29/docker-虛擬化技術/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>hosts 主機表</title>
    <url>/2020/06/08/hosts/</url>
    <content><![CDATA[<p>A: 網址好像連不對地方!?<br>B: 你要不要檢查一下你的主機表..</p>
<p>內文:</p>
<ul>
<li>主機表介紹</li>
<li>檔案位置</li>
</ul>
<a id="more"></a>

<h1 id="hosts-主機表"><a href="#hosts-主機表" class="headerlink" title="hosts 主機表"></a>hosts 主機表</h1><h2 id="主機表介紹"><a href="#主機表介紹" class="headerlink" title="主機表介紹"></a>主機表介紹</h2><br>

<blockquote>
<p>這隻檔案其實就是本地的 DNS,<br>主要記載著 IP 與 Domain 的對應關係,<br>當輸入網址時就會根據 hosts 上的紀錄做解析,<br>當遇到本地沒有的紀錄時, 電腦才會上 DNS server 作詢問,</p>
</blockquote>
<p>雖然說這隻檔案現在很少會用到,<br>但有些專案在開發過程中,<br>還是會將內部網路的 IP 設定在主機表裡,<br>以便專案開發與測試</p>
<p>下面附註檔案位置, 有興趣的話可以打開來看看</p>
<h2 id="檔案位置"><a href="#檔案位置" class="headerlink" title="檔案位置"></a>檔案位置</h2><p><strong>Mac</strong>: <code>/private/etc/hosts</code></p>
<p>在 CLI 上輸入 <code>sudo vim /private/etc/hosts</code><br>就可以用 vim 編輯器打開來了</p>
<p>以下是我mac打開主機表的內容, 給大家參考一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##</span><br><span class="line"># Host Database</span><br><span class="line">#</span><br><span class="line"># localhost is used to configure the loopback interface</span><br><span class="line"># when the system is booting.  Do not change this entry.</span><br><span class="line">##</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">255.255.255.255 broadcasthost</span><br><span class="line">::1             localhost</span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/08/hosts/">https://davidblog.github.io/2020/06/08/hosts/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>如何在 Nginx 上面部署 React App</title>
    <url>/2023/07/11/nginx/</url>
    <content><![CDATA[<p>Nginx 是常見的網頁伺服器<br>預設的情況下會將客戶端的所有請求轉發到後端的真實路徑<br>部署多頁式的網頁應用並沒有什麼問題 但是如果是單頁式應用呢</p>
<p>React 是典型的單頁式應用 SPA (Single App Application)<br>React Router 提供多種類型的路由 如 BrowserRouter, HashRouter, MemoryRouter etc.<br>其中 React Router 官方最推薦的 Router 就是 <a href="https://reactrouter.com/en/main/routers/create-browser-router" target="_blank" rel="noopener">BrowserRouter</a></p>
<p>BrowserRouter 會根據每次路徑的變化都和後端發送請求</p>
<p>但實際上 React 只會有一個 index.html 位於 Nginx 的網站根目錄<br>此時如果 Nginx 嘗試將每個前端路由的的請求都轉發到後端的真實路徑<br>就會因為找不到實際的檔案可以回傳 而發生 404 Not Found</p>
<p>底下就來說明如何解決這個問題</p>
<ul>
<li>nginx 設定檔配置</li>
</ul>
<a id="more"></a>

<h2 id="nginx-設定檔配置"><a href="#nginx-設定檔配置" class="headerlink" title="nginx 設定檔配置"></a>nginx 設定檔配置</h2><p>Nginx 的配置檔案預設位置為：<br><code>/etc/nginx/conf.d/default.conf</code>  </p>
<p>內容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">listen</span>       <span class="number">80</span><span class="string">;</span></span><br><span class="line">    <span class="string">listen</span>  <span class="string">[::]:80;</span></span><br><span class="line">    <span class="string">server_name</span>  <span class="string">localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">root</span>   <span class="string">/usr/share/nginx/html;</span></span><br><span class="line">        <span class="string">index</span>  <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>需要將 try_files 加入 location / 下<br>代碼如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">listen</span>       <span class="number">80</span><span class="string">;</span></span><br><span class="line">    <span class="string">listen</span>  <span class="string">[::]:80;</span></span><br><span class="line">    <span class="string">server_name</span>  <span class="string">localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">root</span>   <span class="string">/usr/share/nginx/html;</span></span><br><span class="line">        <span class="string">index</span>  <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line">        <span class="comment"># url 切換時始终返回index.html</span></span><br><span class="line">        <span class="string">try_files</span> <span class="string">$uri</span> <span class="string">/index.html;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>此時你在馬上打開網站<br>你會發先還是 404 Not Found</p>
<p>記得當修改完配置要在執行</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">nginx</span> <span class="string">-s</span> <span class="string">reload</span></span><br></pre></td></tr></table></figure>

<p>這樣才能重新讀取並套用新的配置<br>然後在開網站 就正常囉～</p>
<p>另外如果發現 React 有些頁面抓不到靜態資源<br>可以檢查專案下的 package.json<br>並確認 homepage 設定是否正確<br>如果專案是部署在網站根目錄下 設定如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">"homepage":</span> <span class="string">"/"</span></span><br></pre></td></tr></table></figure>

<p>以上就是將 React App 部署在 Nginx 網頁伺服器的方法哩</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/07/11/nginx/">https://davidblog.github.io/2023/07/11/nginx/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 實用的小技巧（一）</title>
    <url>/2020/06/13/js-tips/</url>
    <content><![CDATA[<p>這個主題打算寫系列文章<br>主要是記錄 javascript 一些實用的小技巧</p>
<p>內文</p>
<ul>
<li>取數字千分位</li>
<li>建立時間戳記</li>
<li>將字串轉為數字</li>
<li>數字加總</li>
<li>去除陣列重複項目</li>
<li>科學計數法</li>
<li>陣列內項目隨機交換</li>
<li>處理貨幣單位</li>
<li>取得陣列中最大值與最小值</li>
<li>建立連續數字陣列</li>
</ul>
<a id="more"></a>

<p><strong>JavaScript 十個實用的小技巧（一）</strong></p>
<h1 id="取數字千分位"><a href="#取數字千分位" class="headerlink" title="取數字千分位"></a>取數字千分位</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> number = <span class="number">1000000</span>;</span><br><span class="line">number.toLocaleString();</span><br><span class="line"><span class="comment">// "1,000,000"</span></span><br></pre></td></tr></table></figure>

<h1 id="建立時間戳記"><a href="#建立時間戳記" class="headerlink" title="建立時間戳記"></a>建立時間戳記</h1><p>常用時間戳記為至今距離 1970年 1 月 1 日 的毫秒數<br>為什麼是 1970年 1 月 1 日<br>根據維基百科說明: 1970 年 為 Unix 紀元<br>也就是紀念 Unix 誕生的元年 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// 1592030768175</span></span><br></pre></td></tr></table></figure>

<h1 id="將字串轉為數字"><a href="#將字串轉為數字" class="headerlink" title="將字串轉為數字"></a>將字串轉為數字</h1><p>提供一個比 parseInt 更簡潔的寫法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">"1000000"</span>;</span><br><span class="line">+string;</span><br><span class="line"><span class="comment">// 1000000</span></span><br></pre></td></tr></table></figure>

<h1 id="數字加總"><a href="#數字加總" class="headerlink" title="數字加總"></a>數字加總</h1><p>寫法一</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="built_in">eval</span>(array.join(<span class="string">"+"</span>));</span><br><span class="line"><span class="comment">// 55</span></span><br></pre></td></tr></table></figure>

<p>寫法二</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">array.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// 55</span></span><br></pre></td></tr></table></figure>

<h1 id="去除陣列重複項目"><a href="#去除陣列重複項目" class="headerlink" title="去除陣列重複項目"></a>去除陣列重複項目</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"banana"</span>, <span class="string">"apple"</span>, <span class="string">"banana"</span>];</span><br><span class="line">[...new <span class="built_in">Set</span>(array)];</span><br><span class="line"><span class="comment">// ["apple", "banana"]</span></span><br></pre></td></tr></table></figure>

<h1 id="科學計數法"><a href="#科學計數法" class="headerlink" title="科學計數法"></a>科學計數法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1e6</span>;</span><br><span class="line"><span class="comment">// 1000000</span></span><br></pre></td></tr></table></figure>

<h1 id="陣列內項目隨機交換"><a href="#陣列內項目隨機交換" class="headerlink" title="陣列內項目隨機交換"></a>陣列內項目隨機交換</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">array.sort(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br><span class="line"><span class="comment">// [3, 7, 9, 4, 2, 5, 6, 8, 10, 1]</span></span><br></pre></td></tr></table></figure>

<h1 id="處理貨幣單位"><a href="#處理貨幣單位" class="headerlink" title="處理貨幣單位"></a>處理貨幣單位</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">1e6</span>).toLocaleString(<span class="string">"zh-tw"</span>, &#123; <span class="attr">style</span>: <span class="string">"currency"</span>, <span class="attr">currency</span>: <span class="string">"TWD"</span> &#125;);</span><br><span class="line"><span class="comment">// "$1,000,000.00"</span></span><br></pre></td></tr></table></figure>

<h1 id="取得陣列中最大值與最小值"><a href="#取得陣列中最大值與最小值" class="headerlink" title="取得陣列中最大值與最小值"></a>取得陣列中最大值與最小值</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="built_in">Math</span>.max(...array);</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">Math</span>.min(...array);</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h1 id="建立連續數字陣列"><a href="#建立連續數字陣列" class="headerlink" title="建立連續數字陣列"></a>建立連續數字陣列</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="number">10</span>)</span><br><span class="line">  .fill()</span><br><span class="line">  .map(<span class="function">(<span class="params">i, id</span>) =&gt;</span> id + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/13/js-tips/">https://davidblog.github.io/2020/06/13/js-tips/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>Frontend 前端免費資源匯集（ㄧ）</title>
    <url>/2020/06/27/free-sources/</url>
    <content><![CDATA[<p>工程師不造輪胎 一個好的開始 就是直接站在巨人的肩膀上 這樣最快 最輕鬆 最開心!!!<br>所以這篇文章主要是彙整一些 優質 好用 而且<strong>免費</strong>的前端資源 感謝網路上巨人們的貢獻!!!</p>
<p>p.s. 很多資源可以免費使用在商業上 但需不需要 credit 作者 記得還是先看一下 license</p>
<p>內文</p>
<ul>
<li>圖片</li>
<li>模板</li>
<li>字型</li>
<li>API</li>
<li>CSS Animation</li>
</ul>
<a id="more"></a>

<h1 id="圖片"><a href="#圖片" class="headerlink" title="圖片"></a>圖片</h1><h2 id="Unsplash"><a href="#Unsplash" class="headerlink" title="Unsplash"></a><a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a></h2><p>以前這個網站所有提供的圖片都是 CC0<br>真正的免費 可以完全任意的使用 無需標明出處來源 是一個非常受到歡迎的圖庫</p>
<p>現在呢 許可改為 Unsplash 自己的許可 多了一些限制</p>
<ul>
<li>不能以 Unsplash 的圖片和 Unsplash 競爭</li>
<li>圖片在未經過大幅度修改下不能直接進行販售</li>
</ul>
<p>但依然是可以進行商業或非商業使用 也無需標明出處來源<br>重點是品質都有相當高得水準 直接拿個一張圖片放在網頁上當 banner<br>你的網頁就直接昇華到了下一個檔次</p>
<p>缺點是因為免費高品質 容易有撞衫的機會</p>
<br>

<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="TEMPLATED"><a href="#TEMPLATED" class="headerlink" title="TEMPLATED"></a><a href="https://templated.co/" target="_blank" rel="noopener">TEMPLATED</a></h2><p>裡面超過 800 種版型 每種版型都包含了完整的 HTML, CSS 甚至是 RWD<br>可以做為商業與個人使用 主要的許可是 CC-by 簡單來說只要在網站上著名出處就可以了<br>如在 footer 上寫 <code>Designed by &lt;出處&gt;</code></p>
<p>細部點進去看 還會發現有一些其實是 CC0 !!! 超級棒 !!!</p>
<br>

<h1 id="字型"><a href="#字型" class="headerlink" title="字型"></a>字型</h1><h2 id="Google-Fonts"><a href="#Google-Fonts" class="headerlink" title="Google Fonts"></a><a href="https://fonts.google.com/" target="_blank" rel="noopener">Google Fonts</a></h2><p>字型推薦 Google Fonts<br>主要的許可是 Open Font License<br>可以自由地使用在產品 專案 及商業上 限制是不能直接去賣這個字型</p>
<p>字型的使用上非常的便利<br>可以用 CDN 或是下載</p>
<p>通常在網頁加上字型的話 可以大幅度的提升網頁的質感</p>
<p>p.s. 如果網站地區是在大陸的話 要注意 CDN 可能會連不到 建議直接下載</p>
<br>

<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="public-apis"><a href="#public-apis" class="headerlink" title="public-apis"></a><a href="https://github.com/public-apis/public-apis" target="_blank" rel="noopener">public-apis</a></h2><p>在 github 上有厲害的人們 彙整了相當多的 API<br>詳細可以直接閱讀 README 的部分<br>上面註明了是否需要授權以及可不可以跨域使用 etc.<br>另外 API 的種類還有分門別類 非常的用心</p>
<p>如果前端應用需要一些動態資源 很適合來這邊尋找靈感</p>
<br>

<h1 id="CSS-Animation"><a href="#CSS-Animation" class="headerlink" title="CSS Animation"></a>CSS Animation</h1><h2 id="animate-style"><a href="#animate-style" class="headerlink" title="animate.style"></a><a href="https://animate.style/" target="_blank" rel="noopener">animate.style</a></h2><p>Animated.css 一個老牌的動畫 Library<br>不知道這個網站什麼時候改版了<br>一開始進去還有點認不出來<br>但看到熟悉的動畫效果馬上就認出來了<br>裡面提供非常多好用的 CSS Animation<br>許可為 MIT License</p>
<p>以前只能使用 CDN 現在也提供了 npm 的使用方法<br>這個庫可以非常方便的在網頁上套用現成好看的動畫效果</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/27/free-sources/">https://davidblog.github.io/2020/06/27/free-sources/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>前端路由之導航狀態 (React Hook - useNavigate)</title>
    <url>/2023/07/12/navigate/</url>
    <content><![CDATA[<p>導航狀態常用於頁面間的資料傳遞<br>特別適合單向的數據傳遞(只管數據帶到下一頁,不管帶回上一頁)<br>使用上直觀且簡單<br>另外現代瀏覽器多半有緩存機制可以保存各頁面的狀態<br>即便客戶端進行 Reload, 或點擊上下頁依然可以保存狀態</p>
<p>應用上像是商品目錄頁進到商品內頁<br>可以藉由導航狀態先將部分資訊帶入內頁渲染<br>剩餘的資訊再藉由動態請求補齊<br>可以有效提升使用者體驗</p>
<p>底下以 React Router v6 為例<br>來說明導航狀態的實際應用：</p>
<ul>
<li>useNavigate</li>
</ul>
<a id="more"></a>

<h2 id="useNavigate"><a href="#useNavigate" class="headerlink" title="useNavigate"></a>useNavigate</h2><p>這是一個頁面級別的元件代碼範例<br>包含接收來自上一頁的 state<br>和將 state 帶入新頁面的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Page = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> navigate = useNavigate();</span><br><span class="line">  <span class="keyword">const</span> location = useLocation();</span><br><span class="line">  <span class="keyword">const</span> &#123; state &#125; = location;</span><br><span class="line">  <span class="keyword">const</span> [viewModel, setViewModel] = useState(state || &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onNextPageClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> state = &#123; <span class="attr">data</span>: <span class="string">'example'</span> &#125;;</span><br><span class="line">    navigate(<span class="string">"頁面路徑"</span>, &#123; state &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fetchPageData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">"url"</span>);</span><br><span class="line">       <span class="keyword">const</span> json = <span class="keyword">await</span> res.json();</span><br><span class="line">       <span class="keyword">const</span> &#123; data &#125; = json;</span><br><span class="line">       setViewModel(<span class="function"><span class="params">p</span> =&gt;</span> (&#123;...p, ...data&#125;))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(err.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetchPageData()</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (頁面JSX代碼);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>從上面的代碼可以看到導航狀態來自於 location 的 state<br>可將其作為 viewModel 的預設值 之後主要用來更新視圖<br>當元件掛載完成後 便會觸發 fetchPageData 進行動態數據請求和視圖更新</p>
<p>如果需要將狀態帶入新頁面 則可以參考 onNextPageClick 函式</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/07/12/navigate/">https://davidblog.github.io/2023/07/12/navigate/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>PWA 漸進式網頁應用程式</title>
    <url>/2020/06/03/pwa/</url>
    <content><![CDATA[<p>讓你的 Web 直接變 APP?! …當然沒那麼誇張, 但除了一些限制外, 看起來就和 APP 一樣…</p>
<p><strong>內文備註：</strong></p>
<ul>
<li>基本設定</li>
<li>插件推薦</li>
<li>Tips</li>
</ul>
<a id="more"></a>

<h1 id="Progressive-Web-App"><a href="#Progressive-Web-App" class="headerlink" title="Progressive Web App"></a>Progressive Web App</h1><h2 id="基本設定"><a href="#基本設定" class="headerlink" title="基本設定"></a>基本設定</h2><p>這裏你只需放兩隻檔案在網頁根目錄並在 html 檔中引入相關設定即可完成</p>
<p><strong>檔案說明</strong></p>
<ul>
<li><code>manifest.json</code><blockquote>
<p>作用: 網頁加入手機桌面的必要資訊<br>引入: <code>&lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot; /&gt;</code></p>
</blockquote>
</li>
<li><code>service-worker.js</code><blockquote>
<p>作用: 離線快取機制<br>引入:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">if</span> (<span class="string">"serviceWorker"</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">     <span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, () =&gt; &#123;</span><br><span class="line">       navigator.serviceWorker.register(<span class="string">"./service-worker.js"</span>).then(</span><br><span class="line">         (registration) =&gt; &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(</span><br><span class="line">             <span class="string">`ServiceWorker registration successful with scope: <span class="subst">$&#123;registration.scope&#125;</span>`</span></span><br><span class="line">           );</span><br><span class="line">         &#125;,</span><br><span class="line">         (error) =&gt; &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">`ServiceWorker registration failed: <span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">         &#125;</span><br><span class="line">       );</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>至於這兩隻檔案怎麼寫呢???</strong><br>除了 Google 一下基本範例來自己寫…<br>底下提供好用插件可以直接產出這兩隻檔案!!!</p>
<h2 id="插件推薦"><a href="#插件推薦" class="headerlink" title="插件推薦"></a>插件推薦</h2><p><a href="https://www.npmjs.com/package/create-pwa" target="_blank" rel="noopener">create-pwa</a></p>
<blockquote>
<p>照裡面的文件使用就對了<br>好了, 現在你已經有所有該具備的檔案了<br>接下來就可以試試安裝在電腦桌面或手機桌面上了</p>
</blockquote>
<p><strong>什麼?!.. 安裝不了?!…</strong><br>底下附註一些 Tips 幫你解決常見的問題</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>基本上安裝不了,主要和三個地方有關係, 檢查過後就可以安裝了!!!</p>
<ol>
<li>pwa 在 localhost 或 https 下, 才能安裝</li>
<li>快取檔案路徑不正確</li>
<li>ios 手機只能用 safari 隱晦的方式加入桌面</li>
</ol>
<p><strong>什麼?!.. 安裝好了可是沒有東西?!…</strong></p>
<p>別緊張, 檢查一下 manifest.json 內的 start_url 是否正確</p>
<blockquote>
<p>其位置為 manifest.json 所在目錄的相對路徑</p>
</blockquote>
<p><strong>好了, 恭喜!!! 現在你有一個 PWA 了</strong></p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/03/pwa/">https://davidblog.github.io/2020/06/03/pwa/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>PWA 偽裝術</title>
    <url>/2020/06/07/pwa2/</url>
    <content><![CDATA[<p>A: 你看我做了一個 APP!<br>B: 那是 WEB 好嗎?<br>A: 露餡了…</p>
<p>內文:</p>
<ul>
<li>隱藏 PWA 在手機上的縮放</li>
<li>隱藏跳出的 GOOGLE 翻譯</li>
<li>BONUS: 更新快取內容</li>
</ul>
<a id="more"></a>

<h1 id="PWA-偽裝術"><a href="#PWA-偽裝術" class="headerlink" title="PWA 偽裝術"></a>PWA 偽裝術</h1><br>

<blockquote>
<p>即便 PWA 可以安裝在手機上,<br>打開後沒有網址列,<br>但畢竟還是一個網頁,<br>故使用上會出現一些網頁的特有行為,<br>為了讓網頁在手機上的體驗更像原生 APP,<br>底下提供一些實用的小 tips</p>
</blockquote>
<h2 id="隱藏-PWA-在手機上的縮放"><a href="#隱藏-PWA-在手機上的縮放" class="headerlink" title="隱藏 PWA 在手機上的縮放"></a>隱藏 PWA 在手機上的縮放</h2><p>meta 標籤位於 html 檔的 head 標籤裡頭,<br>主要功能是記載著網頁內的相關資訊,<br>我們可以使用 meta viewport 來解決網頁可根據使用者自由縮放的問題,<br>只需要將底下代碼即可:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=no"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下來說明 content 屬性內容作用</p>
<ul>
<li><code>width=device-width</code>: 將畫面寬度設定為符合裝置畫面寬度</li>
<li><code>initial-scale=1</code>: 畫面初始的縮放比例</li>
<li><code>shrink-to-fit=no</code>:<br>針對 iOS9 畫面自適應寬度需要加上, 否則 Safari 在畫面上會發生 scale down (縮小)</li>
<li><code>user-scalable=no</code>: <font color="#ff0000">解決畫面可縮放問題</font></li>
</ul>
<h2 id="隱藏跳出的-GOOGLE-翻譯"><a href="#隱藏跳出的-GOOGLE-翻譯" class="headerlink" title="隱藏跳出的 GOOGLE 翻譯"></a>隱藏跳出的 GOOGLE 翻譯</h2><p>這個問題主要是針對 Android 會發生的,<br>如果網頁內是用到其他語言,<br>一樣利用 meta 標籤可以解決此問題,<br>這此我們所使用的是 meta google 這個標籤,<br>以下為代碼, 加上即可:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"google"</span> <span class="attr">content</span>=<span class="string">"notranslate"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>content 內容從字面上即可看出來是不用翻譯的意思</p>
<h2 id="BONUS-更新快取內容"><a href="#BONUS-更新快取內容" class="headerlink" title="BONUS: 更新快取內容"></a>BONUS: 更新快取內容</h2><p>首先需要先簡單講一下 service-worker 主要的幾個事件,</p>
<ul>
<li>register<blockquote>
<p>註冊 service-worker (sw)</p>
</blockquote>
</li>
<li>install<blockquote>
<p>當 sw 成功註冊後, 即會觸發此事件, 在背景執行安裝, 白話就是快取設定的內容</p>
</blockquote>
</li>
<li>active<blockquote>
<p>當完成安裝後, 即為啟動狀態, 這裡可以設定清除舊快取 (filter 快取名稱來 clean)</p>
</blockquote>
</li>
<li>fetch<blockquote>
<p>當在 sw scope 下發生任何請求都會觸發此事件, 並從快取中檢查是否已有相同項目</p>
</blockquote>
</li>
</ul>
<p>基本上 sw 在檢查所有快取上都是依照 CACHE NAME 來判定的,<br>而 CACHE NAME 基本上是我們一開始命名的字串變數,<br>所以要讓 PWA 自動更新, 最簡單快速的方法就是將 CACHE NAME 重新命名即可</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/07/pwa2/">https://davidblog.github.io/2020/06/07/pwa2/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 如何重構代碼（一）</title>
    <url>/2020/06/15/refactor/</url>
    <content><![CDATA[<p>這個主題打算寫系列文<br>先簡單介紹三個 if else 的重構方法</p>
<p>內文</p>
<ul>
<li>更好的 if else 寫法 (三元運算子)</li>
<li>更好的 if else 寫法（return）</li>
<li>更好的 if else 寫法（物件）</li>
</ul>
<a id="more"></a>

<h1 id="更好的-if-else-三元運算子"><a href="#更好的-if-else-三元運算子" class="headerlink" title="更好的 if else (三元運算子)"></a>更好的 if else (三元運算子)</h1><h2 id="if-else-寫法"><a href="#if-else-寫法" class="headerlink" title="if else 寫法"></a>if else 寫法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (id === <span class="number">1</span>) &#123;</span><br><span class="line">  alert(<span class="string">"ID 是 1"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">"ID 不是 1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三元運算子"><a href="#三元運算子" class="headerlink" title="三元運算子"></a>三元運算子</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">id === <span class="number">1</span> ? alert(<span class="string">"ID 是 1"</span>) : alert(<span class="string">"ID 不是 1"</span>);</span><br></pre></td></tr></table></figure>

<h1 id="更好的-if-else（return-寫法）"><a href="#更好的-if-else（return-寫法）" class="headerlink" title="更好的 if else（return 寫法）"></a>更好的 if else（return 寫法）</h1><h2 id="if-else-寫法-1"><a href="#if-else-寫法-1" class="headerlink" title="if else 寫法"></a>if else 寫法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (id === <span class="number">1</span>) &#123;</span><br><span class="line">  alert(<span class="string">"ID 是 1"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (id === <span class="number">2</span>) &#123;</span><br><span class="line">  alert(<span class="string">"ID 是 2"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (id === <span class="number">3</span>) &#123;</span><br><span class="line">  alert(<span class="string">"ID 是 3"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">"ID 不是 1, 2, 3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="retrun"><a href="#retrun" class="headerlink" title="retrun"></a>retrun</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (id === <span class="number">1</span>) <span class="keyword">return</span> alert(<span class="string">"ID 是 1"</span>);</span><br><span class="line">  <span class="keyword">if</span> (id === <span class="number">2</span>) <span class="keyword">return</span> alert(<span class="string">"ID 是 2"</span>);</span><br><span class="line">  <span class="keyword">if</span> (id === <span class="number">3</span>) <span class="keyword">return</span> alert(<span class="string">"ID 是 3"</span>);</span><br><span class="line">  <span class="keyword">return</span> alert(<span class="string">"ID 不是 1, 2, 3"</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h1 id="更好的-if-else（物件寫法）"><a href="#更好的-if-else（物件寫法）" class="headerlink" title="更好的 if else（物件寫法）"></a>更好的 if else（物件寫法）</h1><h2 id="if-else-寫法-2"><a href="#if-else-寫法-2" class="headerlink" title="if else 寫法"></a>if else 寫法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (id === <span class="number">1</span>) &#123;</span><br><span class="line">  alert(<span class="string">"ID 是 1"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (id === <span class="number">2</span>) &#123;</span><br><span class="line">  alert(<span class="string">"ID 是 2"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (id === <span class="number">3</span>) &#123;</span><br><span class="line">  alert(<span class="string">"ID 是 3"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">"ID 不是 1, 2, 3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="物件"><a href="#物件" class="headerlink" title="物件"></a>物件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"ID 不是 1, 2, 3"</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">"ID 是 1"</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">"ID 是 2"</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">"ID 是 3"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> selectedID = obj[id] || obj[<span class="number">0</span>];</span><br><span class="line">alert(selectedID);</span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/15/refactor/">https://davidblog.github.io/2020/06/15/refactor/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>語言學習應用</title>
    <url>/2023/08/03/recalling-lang-topic/</url>
    <content><![CDATA[<p>之前嘗試做過一個簡單的語言學習應用<br>網址已經關閉了，不過還是可以把當初實作的一些想法放在這裡！٩(๑❛ᴗ❛๑)۶</p>
<img src="/images/lang-topic/preview-01.jpeg" width="75%" alt="語言學習應用封面" />

<p>底下來聊聊這段歷史軌跡吧：</p>
<ul>
<li>緣起</li>
<li>實作</li>
</ul>
<a id="more"></a>

<h2 id="緣起"><a href="#緣起" class="headerlink" title="緣起"></a>緣起</h2><p>以前有一陣子很常玩 VR 遊戲<br>因為 VR 遊戲裡面的玩家主要都是講英文居多</p>
<p><strong>註：有玩 VR 遊戲的人可以找我一起玩喔！</strong></p>
<p>為了能夠順利玩遊戲<br>就找了幾位語言夥伴來練習英文</p>
<p>這個應用的場景是來自其中一位語言夥伴</p>
<p>當初交流主要在 <a href="https://meet.google.com/" target="_blank" rel="noopener">Google Meet</a> 進行<br>互動的模式挺固定的</p>
<p>雙方先簡單的寒暄<br>30 分鐘的中文練習<br>和 30 分鐘的英文練習</p>
<p>練習的方式就是會從一個現成的題庫抽題目讓對方回答<br>題目有分難度：簡單，中等，高級這樣<br>根據難度不一樣對方回答能夠使用的時間也不一樣<br>對方需要在指定的時間內完成回答<br>然後另一方給予反饋</p>
<p>固定的模式有幾個好處就是<br>比較容易進入狀況且不容易緊張<br>題庫裡面的題目也可以先事前練習</p>
<p><strong>然後感覺好像特別適合做成一個應用( ﾟ ▽ ﾟ)/</strong></p>
<p>當初完成這個應用有先給這位語言夥伴看過<br>雖然題庫都是很常見的問題<br>但據說是來自於網路上的其它網站<br>基於未知的版權問題<br>最後這個網站就沒有公開了</p>
<h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><p>UI 元件當初使用 mui 和 antd</p>
<p>其實 antd 裡面滿多現成的元件我都覺得還不錯用<br>只是 antd 提供的元件能夠客製化調整的程度比較小<br>所以比較適合用在後台或像是不需要太在意樣式的個人項目 Ψ(｀ ∀´#)ﾉ</p>
<p>為了方便說明功能這邊先貼一下應用的預覽圖：</p>
<p><img src="/images/lang-topic/preview-02.jpeg" alt="語言學習應用功能預覽"></p>
<p>主要功能大概有底下這些：</p>
<ul>
<li>選擇題庫難度</li>
<li>是否顯示中英文</li>
<li>倒數計時</li>
<li>錄音</li>
<li>播放錄音</li>
<li>切換題目</li>
</ul>
<p>大部分功能算是比較常見的基本功能<br>裡面比較值得提的應該就是錄音和播放錄音</p>
<h3 id="錄音"><a href="#錄音" class="headerlink" title="錄音"></a>錄音</h3><p>錄音是這個應用裡面最複雜的部分<br>主要會用到<code>navigator.mediaDevices</code>這個瀏覽器物件<br>這個物件有提供<code>getUserMedia</code>這個方法<br>可以選擇性來調用硬體設備的錄音和攝像功能<br>調用錄音功能的時候會紀錄<code>Media Stream</code><br>並在停止錄音時需要將它轉為大型物件網址(blob url)</p>
<h3 id="播放錄音"><a href="#播放錄音" class="headerlink" title="播放錄音"></a>播放錄音</h3><p>播放錄音使用 audio 元素<br>至於 src 的網址則是在錄音完成時放入其 blob 網址</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/08/03/recalling-lang-topic/">https://davidblog.github.io/2023/08/03/recalling-lang-topic/</a> </p>
]]></content>
      <categories>
        <category>學習歷程</category>
      </categories>
  </entry>
  <entry>
    <title>SSH 金鑰與遠端連線</title>
    <url>/2020/06/09/ssh/</url>
    <content><![CDATA[<p>遠端推送不用帳密了!! (撒花</p>
<p>內文</p>
<ul>
<li>SSH 介紹</li>
<li>如何產生金鑰</li>
<li>金鑰檔案位置</li>
</ul>
<a id="more"></a>

<h1 id="SSH-金鑰與遠端連線"><a href="#SSH-金鑰與遠端連線" class="headerlink" title="SSH 金鑰與遠端連線"></a>SSH 金鑰與遠端連線</h1><h2 id="SSH-介紹"><a href="#SSH-介紹" class="headerlink" title="SSH 介紹"></a>SSH 介紹</h2><br>

<blockquote>
<p>一種加密的網路傳輸協定,<br>常見的用途為遠端登入</p>
</blockquote>
<p>使用方法為先在本地產生一對金鑰,<br>將公鑰放上遠端的 server,<br>私鑰則留在本地電腦妥善保管,<br>當開始進行 ssh 連線時,<br>遠端公鑰則會和本地私鑰進行比對,<br>比對成功即可連線</p>
<h2 id="如何產生金鑰"><a href="#如何產生金鑰" class="headerlink" title="如何產生金鑰"></a>如何產生金鑰</h2><p>CLI 輸入以下指令即可:<br><code>ssh-keygen</code></p>
<p>或是可以加上參數:<br><code>ssh-keygen -t rsa -C &lt;comment&gt;</code></p>
<p>參數說明:</p>
<ul>
<li>-t 指定生成密鑰的類型</li>
<li>-C 提供一個新註釋</li>
</ul>
<h2 id="金鑰檔案位置"><a href="#金鑰檔案位置" class="headerlink" title="金鑰檔案位置"></a>金鑰檔案位置</h2><p><strong>Mac</strong>: <code>/Users/&lt;使用者名稱&gt;/.ssh/</code></p>
<p>在金鑰產生後 .ssh 資料夾下會有兩隻檔案</p>
<ul>
<li>公鑰: <code>id_rsa.pub</code></li>
<li>私鑰: <code>id_rsa</code></li>
</ul>
<p><strong>最後把公鑰放上遠端 server 即可完成 ssh 連線前設定</strong></p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/09/ssh/">https://davidblog.github.io/2020/06/09/ssh/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>Shell Script 程式化指令碼</title>
    <url>/2020/05/31/sh/</url>
    <content><![CDATA[<p>在一些架構較大的專案中, 會時常使用到 <code>command line</code> 來執行相關的指令, 如: 啟動開發伺服器, 打包檔案, 部署檔案 etc. 通常會將單一功能的命令寫在 <code>package.json</code> 內的 <code>scripts</code> 裡, 但如果一次需要執行的命令不只一條, 其實可以將相關指令寫成腳本(.sh)放在專案根目錄下, 往後只要執行這隻檔案, 就可以按照腳本順序來執行一連串的相關指令, 以達到程式自動化的效果, 優點是減少重複行為並下錯指令的可能性</p>
<p>另外建立的腳本檔案會需要修改權限才能執行<br>以下備註檔案修改權限的方法:</p>
<a id="more"></a>

<h1 id="將檔案執行權限打開"><a href="#將檔案執行權限打開" class="headerlink" title="將檔案執行權限打開"></a>將檔案執行權限打開</h1><p><strong><code>chmod 777 文件名</code></strong></p>
<ul>
<li><h2 id="chmod-為修改文件權限的指令"><a href="#chmod-為修改文件權限的指令" class="headerlink" title="chmod 為修改文件權限的指令"></a>chmod 為修改文件權限的指令</h2></li>
<li><h2 id="第一個參數為操作文件的用戶權限"><a href="#第一個參數為操作文件的用戶權限" class="headerlink" title="第一個參數為操作文件的用戶權限"></a>第一個參數為操作文件的用戶權限</h2><p>三個數字分別代表:</p>
<blockquote>
<p>文件所有用戶<br>群組用戶<br>其他用戶</p>
</blockquote>
<p>每一個數字表示該用戶的權限:</p>
<blockquote>
<p>r: 讀取權限 (4)<br>w: 撰寫權限 (2)<br>x: 執行權限 (1)</p>
<blockquote>
<p>e.g. r(4)+w(2)+x(1) = rwx(7)</p>
</blockquote>
</blockquote>
</li>
<li><h2 id="第二個參數表示欲修改權限的檔案"><a href="#第二個參數表示欲修改權限的檔案" class="headerlink" title="第二個參數表示欲修改權限的檔案"></a>第二個參數表示欲修改權限的檔案</h2></li>
</ul>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/05/31/sh/">https://davidblog.github.io/2020/05/31/sh/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 實用的小技巧（二）</title>
    <url>/2020/07/04/tips2/</url>
    <content><![CDATA[<p>耶 第二彈 !!</p>
<p>內文</p>
<ul>
<li>取連續陣列 方法一</li>
<li>取連續陣列 方法二</li>
<li>log 開關</li>
<li>undefined 簡寫</li>
<li>取外部 IP</li>
</ul>
<a id="more"></a>

<h1 id="取連續陣列-方法一"><a href="#取連續陣列-方法一" class="headerlink" title="取連續陣列 方法一"></a>取連續陣列 方法一</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...Array(<span class="number">10</span>).keys()];</span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>

<h1 id="取連續陣列-方法二"><a href="#取連續陣列-方法二" class="headerlink" title="取連續陣列 方法二"></a>取連續陣列 方法二</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="built_in">Array</span>(<span class="number">10</span>), (item, id) =&gt; id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>

<h1 id="log-開關"><a href="#log-開關" class="headerlink" title="log 開關"></a>log 開關</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ifDebug = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> oldLog = <span class="built_in">console</span>.log;</span><br><span class="line"><span class="built_in">console</span>.log = <span class="function"><span class="params">()</span> =&gt;</span> ifDebug &amp;&amp; oldLog.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>

<h1 id="undefined-簡寫"><a href="#undefined-簡寫" class="headerlink" title="undefined 簡寫"></a>undefined 簡寫</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>undefined 不是保留字 可以重新被賦值<br>故用 void 0 來取代 undefined 會更嚴謹</p>
<p>void 後面接任何代碼都會執行 但只回 undefined</p>
<h1 id="取外部-IP"><a href="#取外部-IP" class="headerlink" title="取外部 IP"></a>取外部 IP</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">"https://api.ipify.org?format=json"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>補充</strong></p>
<p>終端機取法 (Mac OS)</p>
<p>外部 IP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl ifconfig.me</span><br></pre></td></tr></table></figure>

<p>內部 IP </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<p><strong>內部 ip 會寫在 en0 那邊</strong></p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/07/04/tips2/">https://davidblog.github.io/2020/07/04/tips2/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>WebView 內崁式瀏覽器</title>
    <url>/2020/06/25/webview/</url>
    <content><![CDATA[<p>前兩週有遇到 webview 的問題 還沒來得及紀錄一下<br>(其實一直以來都有遇到各式各樣的坑… 隕石坑…)</p>
<p>內文就先來簡單介紹一下 webview 是什麼</p>
<p>內文</p>
<ul>
<li>webview 介紹</li>
<li>webview 版本</li>
<li>webview 如何除錯</li>
</ul>
<a id="more"></a>

<h1 id="webview-介紹"><a href="#webview-介紹" class="headerlink" title="webview 介紹"></a>webview 介紹</h1><br>

<p>webview 主要應用在手機上作為內崁瀏覽器<br>以便在使用任何 APP 點開外連網址時可以不用跳出去<br>優點是使用 APP 的驗感佳 缺點是外連網站的體驗感不佳 XD<br>因為 webview 使用的瀏覽器往往不是主流瀏覽器 所以語法支持上較差…</p>
<p>底下先筆記重點:</p>
<ul>
<li>webview 不是手機上默認的瀏覽器</li>
<li>webview 不是手機上自帶的瀏覽器</li>
</ul>
<p><strong>webview 是手機上的系統瀏覽器</strong></p>
<h1 id="webview-版本"><a href="#webview-版本" class="headerlink" title="webview 版本"></a>webview 版本</h1><br>

<p>在對 webview 有了基本的認識以後 接下來要談到如何分別版本<br>分辨版本對於 webview 除錯有相當大的幫助</p>
<p>先講重點:</p>
<p><strong>Android 和 iOS 是不一樣的路線</strong></p>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>Android 在 Android 5 以後 webview 從核心系統裡獨立出來<br>一般手機可能可以在: 設定 -&gt; 應用程式 -&gt; 全部 -&gt; 裡面找到 <code>Android System WebView</code><br>(實際上要看你手機是哪一個牌子… 才能知道他在哪裏 XD)</p>
<p><code>Android System WebView</code> 就是 Android 的系統瀏覽器啦<br>主要是跟隨 Chrome 的核心技術 用的是基於 Chromium 的瀏覽器 (google 下開源的項目)<br>點開此應用就可以看到版本了 但是版本前顯示的不一定是 Chromium/googel/chrome 相關字樣<br>而是顯示 package name , 此 package name 和廠商訂定有關<br>如需升級版本也需要找到對應 package name 的更高版本才行</p>
<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><p>單純很多</p>
<ul>
<li>iOS2 ~ iOS7 : UIWebView</li>
<li>iOS8+ : WKWebView</li>
</ul>
<p>如果本地開 Server 讓手機打開 webview 連線<br>其實從終端機其實就可以看到設備的瀏覽器版本資訊了<br>顯示的內容就和平常瀏覽器讀取<code>navigator.userAgent</code> 是一樣的</p>
<p>底下 iPhone 上示範</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Mozilla&#x2F;5.0 (iPhone; CPU iPhone OS 13_5_1 like Mac OS X) AppleWebKit&#x2F;605.1.15 (KHTML, like Gecko) Version&#x2F;13.1.1 Mobile&#x2F;15E148 Safari&#x2F;604.1&quot;</span><br></pre></td></tr></table></figure>

<p>底下 Chrome 上示範</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;83.0.4103.106 Safari&#x2F;537.36&quot;</span><br></pre></td></tr></table></figure>

<p>在這邊 Andorid 和 iOS 都是一樣的<br>不難看出使用者的設備與使用的瀏覽器版本</p>
<h1 id="webview-如何除錯"><a href="#webview-如何除錯" class="headerlink" title="webview 如何除錯"></a>webview 如何除錯</h1><br>

<p>這個答案要看 webview 連到哪邊</p>
<p>如果是連到三方有問題 就是三方的問題 請相關人士去處理 XD</p>
<p>如果連到的網站屬於需要自行維護範圍內的網站 就得自行處理 Orz..</p>
<p>可以先在 APP 端將 webview 連到 localhost 打包成 apk / ipa 另訂版本號<br>或直接使用 adb 連手機安裝應用</p>
<p>接下來連本地 Server 查看對應的 webview 版本<br>確認版本後 就可以上網找到對應的版本下載<br>然後開始在本地 console 除錯</p>
<p>通常就是 ES 版本問題, polyfill 加上的墊片不夠或沒有加到關鍵的墊片 XD</p>
<p>最後用手機 webview 連 localhost 做最後的結果確認<br>沒問題就可以把 webview 線上的網址給改回去了 (撒花)</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/25/webview/">https://davidblog.github.io/2020/06/25/webview/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>資策會小專作品</title>
    <url>/2023/08/01/recalling-small-topic/</url>
    <content><![CDATA[<p>一些原因把之前小專作品的網址給關掉了<br>但我覺得還是可以用另一種形式展示<br>像是放到 Blog 上面 ヽ(✿ ﾟ ▽ ﾟ)ノ</p>
<p><img src="/images/magic-guide/preview-01.jpeg" alt="魔術指南"></p>
<p>底下聊聊這段悠久的歷史軌跡吧：</p>
<ul>
<li>緣起</li>
<li>設計構想</li>
<li>實作成果</li>
</ul>
<a id="more"></a>

<h2 id="緣起"><a href="#緣起" class="headerlink" title="緣起"></a>緣起</h2><p>當初課程要順利結業必須完成小專和大專</p>
<blockquote>
<p>小專題： 個人作品 (4 頁 RWD 靜態網站)<br>大專題： 團隊作品 (設計 + 前端 + 後端 + 資料庫)</p>
</blockquote>
<p>印象中小專作品的標準是 4 頁手刻 RWD</p>
<p>需要 1 週內完成的樣子(・∀・)<br>還是 2 週內完成(´⊙ω⊙`)</p>
<p>記憶錯亂中…</p>
<h2 id="設計構想"><a href="#設計構想" class="headerlink" title="設計構想"></a>設計構想</h2><p>實作的階段是被安排在基礎課程後<br>所以基本的 HTML, CSS, JS 不是問題</p>
<p>但是第一次做網站實在沒有什麼概念<br>像是要如何選題目?<br>網站要長怎樣?<br>頁面要有哪一些?<br>等等…</p>
<p>我當初的思路是：</p>
<p>1.先決定題目<br>2.把已經學到的東西套在這個題目上<br>3.最後上網參照一般的網站是如何做 Layout</p>
<p>現在看我以前的思路其實挺怪的<br>為什麼不是先參照一般的網站是如何做？？？</p>
<p>也許是我當初更著重於練習吧</p>
<p>與其做一個看上去常規的網站<br>我更想把已經學過的東西寫出來<br>不管這樣究竟合不合理 ლ(´ڡ`ლ)</p>
<h2 id="實作成果"><a href="#實作成果" class="headerlink" title="實作成果"></a>實作成果</h2><h3 id="前導頁"><a href="#前導頁" class="headerlink" title="前導頁"></a>前導頁</h3><p><img src="/images/magic-guide/preview-01.jpeg" alt="魔術指南-1"></p>
<p>一進來會有個類似電影字幕淡入淡出的效果<br>再來會出現開始的按鈕<br>點擊之後便可以進到迷宮的場景<br>可以用鍵盤控制前後左右移動與旋轉<br>直到使用者走到盡頭會才切換到驗證頁的場景！</p>
<p>其實原本想要做多層場景<br>並在裡面放寶箱之類的<br>但用 CSS 作 3D 的場景真的很燒腦 囧</p>
<p>最後沒有寶箱</p>
<p>但有個替代方案<br>就是在網頁不同的元素添加點擊事件<br>觸發可以打開彩蛋<br>彩蛋用 alert 的方式打開<br>會透露一些網頁的設計資訊</p>
<h3 id="驗證頁"><a href="#驗證頁" class="headerlink" title="驗證頁"></a>驗證頁</h3><p><img src="/images/magic-guide/preview-02.jpeg" alt="魔術指南-2"></p>
<p>旋轉的牌盒<br>可以根據使用者的操作變色<br>點擊後牌盒將會打開<br>裡面的卡片可以輸入驗證碼<br>驗證成功之後便會導入內部的首頁</p>
<p>話說靜態頁面有沒有辦法做出無法看代碼就找到驗證碼的方式<br><strong>用你要導過去的頁面網址或路徑當作密碼吧!</strong></p>
<h3 id="內頁"><a href="#內頁" class="headerlink" title="內頁"></a>內頁</h3><p><img src="/images/magic-guide/preview-03.jpeg" alt="魔術指南-3"></p>
<p>終於來到的 4 頁 RWD 的部分了<br>裡面的圖片都是來自<a href="https://unsplash.com/" target="_blank" rel="noopener">unsplash</a></p>
<p>幻燈片效果是用<a href="https://vegas.jaysalvat.com/" target="_blank" rel="noopener">vegas</a></p>
<p>裡面還有一些互動的小遊戲<br>像是抽對子, Q&amp;A<br>主要是為了練習 js</p>
<p>(っ^_^)っ 這邊也是看起來最像常規網站的部分了！  </p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/08/01/recalling-small-topic/">https://davidblog.github.io/2023/08/01/recalling-small-topic/</a> </p>
]]></content>
      <categories>
        <category>學習歷程</category>
      </categories>
  </entry>
  <entry>
    <title>Vim 古老編輯器的簡明使用方法</title>
    <url>/2020/06/13/vim/</url>
    <content><![CDATA[<p>A: 這裡是哪裡???為什麼進得去出不來?!<br>B: <code>:q</code><br>A: 那我每次都 <code>:q</code> 可以嗎?<br>B: 恩… 也是可以…</p>
<p>內文</p>
<ul>
<li>基本操作</li>
</ul>
<a id="more"></a>

<h1 id="Vim-古老編輯器的簡明使用方法"><a href="#Vim-古老編輯器的簡明使用方法" class="headerlink" title="Vim 古老編輯器的簡明使用方法"></a>Vim 古老編輯器的簡明使用方法</h1><br>

<blockquote>
<p>如果你有使用 git 的話<br>你一定見過 vim<br>像是 merge 別人的分支<br>或是 commit 的時候</p>
</blockquote>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>以下介紹:</p>
<h3 id="如何使用-vim-開啟文檔"><a href="#如何使用-vim-開啟文檔" class="headerlink" title="如何使用 vim 開啟文檔"></a>如何使用 vim 開啟文檔</h3><p>使用 vim 開啟文檔的方法非常簡單,<br>只需要在 CLI 上輸入以下指令即可:</p>
<p><code>vim /&lt;path&gt;/&lt;file&gt;</code></p>
<p>for instance:</p>
<p>打開所在目錄下 file.txt 文檔</p>
<p><code>vim file.txt</code></p>
<h3 id="模式切換與編輯文件"><a href="#模式切換與編輯文件" class="headerlink" title="模式切換與編輯文件"></a>模式切換與編輯文件</h3><p>一開始進入 vim 編輯器的時候為<strong>普通模式</strong><br>在任何模式下按<code>esc</code>皆可以退至<strong>普通模式</strong></p>
<p>在<strong>普通模式</strong>按下<code>i</code>可以進入<strong>插入模式</strong><br>此模式可以開始進行文檔上的編輯</p>
<p>在<strong>普通模式</strong>下按下 <code>:</code> 可以進入<strong>指令模式</strong><br>此模式可以退出文檔</p>
<h3 id="編輯器離開方式"><a href="#編輯器離開方式" class="headerlink" title="編輯器離開方式"></a>編輯器離開方式</h3><p>離開前必須進入指令模式<br>相關指令如下:</p>
<ul>
<li><code>q</code> : 離開編輯器</li>
<li><code>q!</code> : 不存檔強制離開編輯器</li>
<li><code>w</code> : 存檔</li>
<li><code>wq</code> : 存檔離開編輯器</li>
</ul>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/13/vim/">https://davidblog.github.io/2020/06/13/vim/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 如何重構代碼（二）</title>
    <url>/2020/06/28/refactor2/</url>
    <content><![CDATA[<p>重構代碼第二彈!!!<br>在沒有寫第二彈前…<br>我ㄧ直在想會不會所有規劃好的系列文 都只有一回…XD</p>
<p>內文</p>
<ul>
<li>更好的 function (參數給予預設值)</li>
<li>更好的 array callback（ function 獨立拆出並給予命名）</li>
<li>更好的 邏輯運算子 || (改用陣列過濾)</li>
</ul>
<a id="more"></a>

<h1 id="更好的-function-參數給予預設值"><a href="#更好的-function-參數給予預設值" class="headerlink" title="更好的 function (參數給予預設值)"></a>更好的 function (參數給予預設值)</h1><br>

<blockquote>
<p>處理動態資料時<br>將 function 給予預設值是一個好選擇<br>以免 API 未回傳正確資料時 APP 閃退<br>或發生各種不必要的悲劇</p>
</blockquote>
<p>當參數遇到 <strong>undefined</strong> 時則會給予預設值</p>
<h2 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getAPlusB = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line">getAPlusB();</span><br><span class="line"><span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="Better-寫法一"><a href="#Better-寫法一" class="headerlink" title="Better 寫法一"></a>Better 寫法一</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getAPlusB = <span class="function">(<span class="params">a = <span class="number">0</span>, b = <span class="number">0</span></span>) =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line">getAPlusB();</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="Better-寫法二"><a href="#Better-寫法二" class="headerlink" title="Better 寫法二"></a>Better 寫法二</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getAPlusB = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  a = a || <span class="number">0</span>;</span><br><span class="line">  b = b || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getAPlusB();</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h1 id="更好的-array-callback（-function-獨立拆出並給予命名）"><a href="#更好的-array-callback（-function-獨立拆出並給予命名）" class="headerlink" title="更好的 array callback（ function 獨立拆出並給予命名）"></a>更好的 array callback（ function 獨立拆出並給予命名）</h1><br>

<blockquote>
<p>當 array 方法裡面的 callback function 較複雜的時候<br>將其獨立出來給予命名是一個好選擇<br>因為可以更直觀的了解其作用與功能</p>
</blockquote>
<h2 id="Normal-1"><a href="#Normal-1" class="headerlink" title="Normal"></a>Normal</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">array.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item * <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Better"><a href="#Better" class="headerlink" title="Better"></a>Better</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> doubleEachNumber = <span class="function">(<span class="params">number</span>) =&gt;</span> number * <span class="number">2</span>;</span><br><span class="line">array.map(doubleEachNumber);</span><br></pre></td></tr></table></figure>

<h1 id="更好的-邏輯運算子-改用陣列過濾"><a href="#更好的-邏輯運算子-改用陣列過濾" class="headerlink" title="更好的 邏輯運算子 || (改用陣列過濾)"></a>更好的 邏輯運算子 || (改用陣列過濾)</h1><br>

<blockquote>
<p>這邊範例是用 indexOf 來重構<br>但實際上用 includes 會更直觀<br>但使用上需要注意 indexOf 存在於 ES5<br>而 includes 則為 ES6 所加上的</p>
</blockquote>
<h2 id="Normal-2"><a href="#Normal-2" class="headerlink" title="Normal"></a>Normal</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getIdInfo = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (id === <span class="number">1</span> || id === <span class="number">2</span> || id === <span class="number">3</span> || id === <span class="number">4</span> || id === <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"id 介於 1 到 5 之間"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id === <span class="number">6</span> || id === <span class="number">7</span> || id === <span class="number">8</span> || id === <span class="number">9</span> || id === <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"id 介於 6 到 10 之間"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"id 不存在"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Better-1"><a href="#Better-1" class="headerlink" title="Better"></a>Better</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayOne = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arrayTwo = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getIdInfo = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (arrayOne.indexOf(id) !== <span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"id 介於 1 到 5 之間"</span>);</span><br><span class="line">  <span class="keyword">if</span> (arrayTwo.indexOf(id) !== <span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"id 介於 6 到 10 之間"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"id 不存在"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/28/refactor2/">https://davidblog.github.io/2020/06/28/refactor2/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>Wget 強大的檔案下載工具</title>
    <url>/2020/06/26/wget/</url>
    <content><![CDATA[<p>最近有一個需求 需要把瀏覽的整個網站給抓下來</p>
<p>在瀏覽器上打開開發人員工具 點選 Sources<br>你可以看到 Server 下面 滿滿的資料夾與各種靜態資源</p>
<p>但怎麼抓呢 那就是用… <strong>Wget</strong></p>
<p>內文</p>
<ul>
<li>Wget 介紹</li>
<li>如何安裝 Wget</li>
<li>如何使用 Wget</li>
</ul>
<a id="more"></a>

<h1 id="Wget-介紹"><a href="#Wget-介紹" class="headerlink" title="Wget 介紹"></a>Wget 介紹</h1><br>

<p>Wget 全名 : <strong>World Wide Web Get</strong></p>
<p>在 Linux 作業系統上為內建的指令之一<br>是一個功能非常強大的檔案自動下載工具<br>雖然你知道 curl 也可以用來下載檔案<br>但有別於 curl 的地方在於 Wget 可以進行遞迴下載<br>所以特別適合抓取整個網站 以取得所有目錄及其檔案</p>
<p>但 Mac 本身並未預設安裝此工具<br>所以如需使用需要另行安裝</p>
<p>底下介紹安裝方式</p>
<h1 id="如何安裝-Wget"><a href="#如何安裝-Wget" class="headerlink" title="如何安裝 Wget"></a>如何安裝 Wget</h1><br>

<p>首先 安裝 MacOS 的套件管理工具 <a href="https://brew.sh/index_zh-tw" target="_blank" rel="noopener">Homebrew</a></p>
<p>安裝方式 CLI 輸入以下指令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;bash -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure>

<p>Homebrew 是什麼呢<br>如官網所提的 他就是 <strong>macOS 缺少套件的管理工具</strong></p>
<p>你可以使用這個套件管理工具來安裝您 Mac 所需要用到的軟體<br>如 google chrome, adobe, nvm, 當然包括 <strong>Wget</strong> etc.</p>
<ul>
<li>確認你想安裝的軟體</li>
</ul>
<p><code>brew search wget</code></p>
<ul>
<li>安裝 Wget</li>
</ul>
<p><code>brew install wget</code></p>
<p>OK 這樣就安裝完成了</p>
<p>最後來說明使用 Wget 的方式</p>
<h1 id="如何使用-Wget"><a href="#如何使用-Wget" class="headerlink" title="如何使用 Wget"></a>如何使用 Wget</h1><br>

<p>Wget 的用法如下</p>
<p><code>wget &lt;Options&gt; &lt;URL&gt;</code></p>
<p>假設我要抓取 google 的網站到桌面</p>
<p>那我就分別輸入以下指令</p>
<p><code>cd ~/Desktop</code></p>
<p><code>wget -r www.google.com</code></p>
<p>最後介紹常用的參數</p>
<ul>
<li>-r (-recursive) : 用來表示遞迴下載</li>
<li>-np (–no-parent) : 用來表示不向上遞迴下載</li>
</ul>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/26/wget/">https://davidblog.github.io/2020/06/26/wget/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>上拉加載</title>
    <url>/2023/06/17/%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BC%89/</url>
    <content><![CDATA[<p>上拉加載 下拉更新 原本是 APP 很常見的功能<br>現在 Web 也很常見 因為越來越多的 Web 得做得和 APP 越來越像 …</p>
<p>今天這篇先講上拉加載的部分：</p>
<ul>
<li>scrollHeight + clientHeight + scrollTop</li>
</ul>
<a id="more"></a>

<h2 id="scrollHeight-clientHeight-scrollTop"><a href="#scrollHeight-clientHeight-scrollTop" class="headerlink" title="scrollHeight + clientHeight + scrollTop"></a>scrollHeight + clientHeight + scrollTop</h2><p>實現加載的關鍵就在滾動事件  </p>
<p>當長清單列表的元素滾動到底部時<br>得觸發一個 Callback function 來獲取新的資料<br>並將此資料加入原清單列表的陣列當中  </p>
<p>這邊先看一下偵測滾動到底部的代碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> detectScrollToBottom = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; clientHeight, scrollHeight, ScrollTop &#125; = <span class="built_in">document</span>.querySelector(<span class="string">'#el'</span>);</span><br><span class="line">    <span class="keyword">if</span>(clientHeight + ScrollTop &gt;= scrollHeight) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'已滑動至底部'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#el'</span>).addEventListener(<span class="string">'scroll'</span>, () =&gt; detectScrollToBottom());</span><br></pre></td></tr></table></figure>

<p>首先解釋一下元素解構出來的這幾個屬性意思</p>
<table>
<thead>
<tr>
<th>scrollHeight</th>
<th>clientHeight</th>
<th>scrollTop</th>
</tr>
</thead>
<tbody><tr>
<td>元素可視與不可視區的高度</td>
<td>元素可視區的高度</td>
<td>元素可視區頂部到元素不可視區頂部的距離</td>
</tr>
</tbody></table>
<p>基本上 scrollHeight 與 clientHeight 都是固定的高度<br>只有 scrollTop 會隨著滾動而改變數值<br>當 clientHeight + ScrollTop 的數值 大於等於 scrollHeight 就表示到了底部</p>
<p><strong>但實際上</strong></p>
<p>這樣寫會有問題<br>因為scrollTop 在滾動時會有浮點數(0.5)<br>而浮點數可能會造成計算的不精準<br>像是明明已經滑動到底部了<br>但是因為差0.5而沒有偵測到底部去觸發回函  </p>
<p>所以這邊可以加上 1 來作為緩衝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> detectScrollToBottom = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; clientHeight, scrollHeight, ScrollTop &#125; = <span class="built_in">document</span>.querySelector(<span class="string">'#el'</span>);</span><br><span class="line">    <span class="keyword">if</span>(clientHeight + ScrollTop + <span class="number">1</span> &gt;= scrollHeight) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'已滑動至底部'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#el'</span>).addEventListener(<span class="string">'scroll'</span>, () =&gt; detectScrollToBottom());</span><br></pre></td></tr></table></figure>

<p>或是多加一些 range 可以讓元素快到底部時就觸發回函</p>
<p><strong>但是… 這樣又會有一些問題</strong></p>
<p>因為加上了緩衝的range就有可能讓回函重複觸發</p>
<p><strong>所以</strong></p>
<p>為了避免事件重複觸發而不斷請求資料<br>可以加上一個 isLoading 的 Flag 來防呆<br>如果已經偵測到底部並請求資料時<br>就必須等到 timeout 或資料獲取完畢才能夠再觸發請求的回函</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/06/17/上拉加載/">https://davidblog.github.io/2023/06/17/上拉加載/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>多步驟頁面的狀態管理 (React Hook - useContext)</title>
    <url>/2023/07/27/%E5%A4%9A%E6%AD%A5%E9%A9%9F%E9%A0%81%E9%9D%A2%E7%9A%84%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>很常見的一個應用場景<br>就是讓用戶完成多步驟的表單頁面並在最後送出<br>中間的過程中用戶可以自由返回上一頁<br>並對尚未提交的內容進行修改</p>
<p>之前有寫一篇<a href="/2023/07/12/navigate/">前端路由的導航狀態</a><br>是講前端如何在不同的頁面之間傳遞數據的方法<br>雖然可以實現這個功能<br>但相當不方便<br>因為需要在每一頁重複設定一樣的方法將數據帶來帶去<br>這種情況如果將狀態統一管理就會輕鬆很多</p>
<p>狀態統一管理最常聽到的就是 <strong>Redux</strong><br>然而在 React 裡頭還有 <strong>Context</strong> 這個方法<br>如果要說這兩個的差別在哪裡<br>我想 <strong>Context</strong> 更符合 React 的元件思維<br>也特別適合簡單的應用場景</p>
<p>所以這篇主要講 React 的 useContext：</p>
<ul>
<li>用 createContext 方法建立 Provider 元件</li>
<li>在前端路由的 Layout 置放 Provider 元件</li>
<li>在需要使用共同狀態的步驟頁面使用 useContext</li>
</ul>
<a id="more"></a>

<h2 id="用-createContext-方法建立-Provider-元件"><a href="#用-createContext-方法建立-Provider-元件" class="headerlink" title="用 createContext 方法建立 Provider 元件"></a>用 createContext 方法建立 Provider 元件</h2><p>createContext 創建出來的 Context.Provider 是元件容器的概念<br>裡面的設定的 value 是可以和底下元件共享的</p>
<p>另外因為是要做頁面級別的元件容器<br>所以還需要使用 react-router-dom 裡面的 Outlet</p>
<p><strong>註：在 context 中用 setState 方法時所有子元件也會重新渲染,</strong><br><strong>如果應用場景較為複雜可加上 useReducer, 來更好的控制子元件更新以節省效能</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext, useState, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Outlet, useLocation &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> StepsContext = createContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StepsProvider = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isMounted = useRef(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> location = useLocation();</span><br><span class="line">  <span class="keyword">const</span> [info, setInfo] = useState(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stepsInit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setInfo(&#123;&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMounted.current) &#123;</span><br><span class="line">      isMounted.current = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果有頁面需要將數據初始化可以這邊設定</span></span><br><span class="line">      <span class="keyword">if</span> ([<span class="string">"/path1"</span>, <span class="string">"/path2"</span>].includes(location.pathname)) &#123;</span><br><span class="line">        stepsInit();</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [location, info]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;StepsContext.Provider</span><br><span class="line">      value=&#123;&#123;</span><br><span class="line">        info,</span><br><span class="line">        setInfo,</span><br><span class="line">        stepsInit,</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;Outlet /&gt;</span><br><span class="line">    &lt;<span class="regexp">/StepsContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default StepsProvider;</span></span><br></pre></td></tr></table></figure>

<h2 id="在前端路由的-Layout-置放-Provider-元件"><a href="#在前端路由的-Layout-置放-Provider-元件" class="headerlink" title="在前端路由的 Layout 置放 Provider 元件"></a>在前端路由的 Layout 置放 Provider 元件</h2><p>這邊挺單純的<br>直接看代碼就可以了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Routes&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"multiple-steps"</span> element=&#123;&lt;StepProvider /&gt;&#125;&gt;</span><br><span class="line">    &lt;Route index element=&#123;&lt;multipleStep /&gt;&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"step1"</span> element=&#123;&lt;Step1 /&gt;&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"step2"</span> element=&#123;&lt;Step2 /&gt;&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"step3"</span> element=&#123;&lt;Step3 /&gt;&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"step4"</span> element=&#123;&lt;Step4 /&gt;&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"step5"</span> element=&#123;&lt;Step5 /&gt;&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Routes&gt;</span><br></pre></td></tr></table></figure>

<h2 id="在需要使用共同狀態的步驟頁面使用-useContext"><a href="#在需要使用共同狀態的步驟頁面使用-useContext" class="headerlink" title="在需要使用共同狀態的步驟頁面使用 useContext"></a>在需要使用共同狀態的步驟頁面使用 useContext</h2><p>這邊有個小技巧<br>可以將 setState 的觸發時機放在 componentWillUnmount 裡面<br>因為不論用戶按上一頁或下一頁都會觸發元件卸載<br>可以藉此來更新狀態！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Step3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; info, setInfo &#125; = useContext(StepsContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    register,</span><br><span class="line">    formState: &#123; erros &#125;,</span><br><span class="line">    handleSubmit,</span><br><span class="line">  &#125; = useForm(&#123; <span class="attr">defaultValues</span>: info &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      handleSubmit(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        setInfo(data);</span><br><span class="line">      &#125;)();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [handleSubmit, setInfo]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// JSX 元件代碼</span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Step3;</span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/07/27/多步驟頁面的狀態管理/">https://davidblog.github.io/2023/07/27/多步驟頁面的狀態管理/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>我的遊戲主機</title>
    <url>/2023/08/06/%E6%88%91%E7%9A%84%E9%81%8A%E6%88%B2%E4%B8%BB%E6%A9%9F/</url>
    <content><![CDATA[<p>記錄一下買過的遊戲主機還有規格<br>這樣以後要買不同主機可以回顧參考 (￣ ▽ ￣)</p>
<ul>
<li>ACER Aspire7 A715-75G-52MV</li>
<li>Oculus Quest 2</li>
<li>Switch 紅藍電力加強版</li>
</ul>
<a id="more"></a>

<h2 id="ACER-Aspire7-A715-75G-52MV"><a href="#ACER-Aspire7-A715-75G-52MV" class="headerlink" title="ACER Aspire7 A715-75G-52MV"></a>ACER Aspire7 A715-75G-52MV</h2><h3 id="購機緣由"><a href="#購機緣由" class="headerlink" title="購機緣由"></a>購機緣由</h3><p>當初很想玩 Steam 的遊戲<br>發現很多遊戲都會註記最低硬體規格需求<br>包括硬碟容量，記憶體，還有獨立顯示卡等級</p>
<p>所以就想辦法找了一台能夠符合大部分遊戲最低運行標準的主機<br>最後找到的就是 ACER Aspire7 A715-75G-52MV<br>它配有 GTX 1650<br>雖然也不是什麼很厲害的顯卡<br>但確實堪用</p>
<p><strong>註：獨顯跑分列表可以查 <a href="https://www.videocardbenchmark.net/gpu_list.php" target="_blank" rel="noopener">videocardbenchmark</a></strong></p>
<h3 id="入手管道"><a href="#入手管道" class="headerlink" title="入手管道"></a>入手管道</h3><p>之前這一台是在光華商場附近的<strong>科大電腦股份有限公司</strong>買的<br>當初入手的價格是 NTD 19,900<br>時間為：2020/10/30</p>
<p><strong>註：去光華商場附近買東西一定要先做功課 不然容易買貴<br>很多店家同樣的商品不同價錢 而且可能會貴很多</strong></p>
<h3 id="硬體規格"><a href="#硬體規格" class="headerlink" title="硬體規格"></a>硬體規格</h3><table>
<thead>
<tr>
<th>處理器</th>
<th>記憶體</th>
<th>磁碟</th>
<th>顯示器</th>
<th>獨顯</th>
</tr>
</thead>
<tbody><tr>
<td>Intel(R) Core(TM) i5-9300H</td>
<td>8.00 GB</td>
<td>512 GB SSD</td>
<td>15.6 吋 IPS</td>
<td>NVIDIA GeForce GTX 1650</td>
</tr>
</tbody></table>
<h3 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h3><p>購機也沒啥特別的要求<br>基本上可以在 Steam 玩遊戲就很開心了<br>然後開始在 Steam 上玩收集遊戲的遊戲</p>
<p>雖然大部分遊戲都沒有破完 Orz<br>但重點是體驗！體驗！哈哈！(<del>就是浪費錢</del>)</p>
<p>底下分享一些用 GTX1650 玩過的遊戲：</p>
<ul>
<li>電馭叛客 Cyberpunk 2077</li>
<li>侏羅紀世界進化</li>
<li>惡靈古堡：村莊</li>
<li>霍格華滋的傳承</li>
<li>異塵餘生 4</li>
<li>上古卷軸 5</li>
<li>神諭 2</li>
<li>古墓奇兵：暗影</li>
<li>魔物獵人：世界</li>
<li>GTA 5</li>
<li>模擬市民 4</li>
</ul>
<h2 id="Oculus-Quest-2"><a href="#Oculus-Quest-2" class="headerlink" title="Oculus Quest 2"></a>Oculus Quest 2</h2><h3 id="購機緣由-1"><a href="#購機緣由-1" class="headerlink" title="購機緣由"></a>購機緣由</h3><p>媒體上看到這台 VR 設備<br>看別人在網上玩 Beat Saber 很好玩<br>發現不太貴而且又是獨立設備<br>就很想體驗看看玩 VR 遊戲是什麼感覺</p>
<h3 id="入手管道-1"><a href="#入手管道-1" class="headerlink" title="入手管道"></a>入手管道</h3><p>從 Facebook 的官網直接下訂</p>
<p><strong>註：從國外訂購 VR 設備需要一些手續<br>所以還得上網查攻略看怎麼買…</strong></p>
<p><strong>註：買之前可以上網看別人提供的推薦碼<br>這樣再買遊戲時可以有一些額外的折扣優惠</strong></p>
<p>當初入手價格是 $319 鎂<br>時間點落在 2021 年底</p>
<h3 id="硬體規格-1"><a href="#硬體規格-1" class="headerlink" title="硬體規格"></a>硬體規格</h3><table>
<thead>
<tr>
<th>硬體</th>
<th>儲存空間</th>
<th>光學</th>
</tr>
</thead>
<tbody><tr>
<td>All in One VR 系統</td>
<td>128GB</td>
<td>雙眼皆提供 1832 x 1920 解析度<br>支援 60、72、90 Hz 更新率</td>
</tr>
</tbody></table>
<h3 id="使用心得-1"><a href="#使用心得-1" class="headerlink" title="使用心得"></a>使用心得</h3><p>是一個很不錯的體驗<br>我也熱衷了一陣子<br>線上玩家多是講英文<br>英文熟悉的話趣味度會翻倍</p>
<p>不過不知道為何線下很難找有玩 VR 的朋友…</p>
<p>另外我認為玩 VR 前最重要的就是認識 VR 暈<br>造成 VR 暈的主因和移動方式有關還有個人體質<br>定點遊戲或是瞬移的移動模式不會造成 VR 暈<br>可以平移類型的遊戲就會有 VR 暈的情形</p>
<p>購買遊戲類型時<br>可以根據上面註記的舒適程度來評估</p>
<p><strong>貼心提醒：玩家有近視的話可以再買磁吸鏡片會比較方便</strong></p>
<p>底下分享一些我用的軟體：</p>
<ul>
<li>Beat Saber</li>
<li>REAL VR FISHING</li>
<li>THRILL OF THE FIGHT</li>
<li>Warplanes: Battles over Pacific</li>
<li>Netflix</li>
<li>Mondly:在 VR 中練習語言</li>
<li>Eleven Table Tennis</li>
<li>The Room VR: A Dark Matter</li>
<li>Zenith: The Last City</li>
</ul>
<p><strong>註：其中我最喜歡也最推的是 REAL VR FISHING</strong></p>
<h2 id="Switch-紅藍電力加強版"><a href="#Switch-紅藍電力加強版" class="headerlink" title="Switch 紅藍電力加強版"></a>Switch 紅藍電力加強版</h2><h3 id="購機緣由-2"><a href="#購機緣由-2" class="headerlink" title="購機緣由"></a>購機緣由</h3><p>完全就是口碑還有童年回憶！</p>
<p>家喻戶曉人手一台！</p>
<p>另外就是 Steam 的遊戲玩膩了<br>還有發現…現代太多遊戲都是虛有其表<br>絢麗的建模卻沒有太多深度的內容…</p>
<p>但任天堂的遊戲卻總是讓人回味無窮！<br>好玩！真的好玩！</p>
<h3 id="入手管道-2"><a href="#入手管道-2" class="headerlink" title="入手管道"></a>入手管道</h3><p>PC home 上面購買的，<br>2022 年底購入 NTD 7,980</p>
<p>話說買到機王(wifi 連不上)<br>買來還先拿去修…</p>
<h3 id="硬體規格-2"><a href="#硬體規格-2" class="headerlink" title="硬體規格"></a>硬體規格</h3><table>
<thead>
<tr>
<th>處理器</th>
<th>主機儲存空間</th>
<th>螢幕尺寸</th>
</tr>
</thead>
<tbody><tr>
<td>Nvidia Tegra X1</td>
<td>32 GB</td>
<td>6.2 吋(1280x720 pixels)</td>
</tr>
</tbody></table>
<h3 id="使用心得-2"><a href="#使用心得-2" class="headerlink" title="使用心得"></a>使用心得</h3><p>目前玩過：</p>
<ul>
<li>薩爾達傳說：曠野之息</li>
<li>薩爾達傳說：王國之淚</li>
<li>寶可夢紫</li>
<li>寶可夢阿爾宙斯</li>
</ul>
<p>都超好玩的！極推！</p>
<p><strong>註：薩爾達傳說：曠野之息和寶可夢紫已經全破！！</strong>  </p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/08/06/我的遊戲主機/">https://davidblog.github.io/2023/08/06/我的遊戲主機/</a> </p>
]]></content>
      <categories>
        <category>生活札記</category>
      </categories>
  </entry>
  <entry>
    <title>我的單眼相機</title>
    <url>/2023/08/07/%E6%88%91%E7%9A%84%E5%96%AE%E7%9C%BC%E7%9B%B8%E6%A9%9F/</url>
    <content><![CDATA[<p>首先來分享一個很棒的網站 <a href="https://www.dxomark.com/smartphones/" target="_blank" rel="noopener">DXOMARK</a><br>這個網站包含常見的手機, 相機, 鏡頭的排名<br>這樣一來你就可以很輕鬆的知道自己硬體設備的性能位階大該落在哪裡<br>以後要換設備或是添購新設備皆可以參考真的很方便</p>
<p>然後底下記錄一下我以前買過的單眼相機與鏡頭：</p>
<ul>
<li>Sony a6000</li>
<li>Sony rx100m5a</li>
</ul>
<a id="more"></a>

<h2 id="Sony-a6000"><a href="#Sony-a6000" class="headerlink" title="Sony a6000"></a>Sony a6000</h2><h3 id="購買緣由"><a href="#購買緣由" class="headerlink" title="購買緣由"></a>購買緣由</h3><p>突然有天靈光一閃<br>覺得拍照好像是一件很有趣的事<br>然後特別執著於淺景深的照片</p>
<blockquote>
<p>對焦在一個平面，然後讓其他所有東西都失焦。</p>
</blockquote>
<p>可是問題來了<br>用相機要拍淺景深<br>很困難呀</p>
<p>所以心裡就想說要買一台相機</p>
<p>當時矇矇懂懂又對相機不了解<br>所以上網查了一下<br>網站上說啥好我就認為啥好</p>
<p>當時上網查的資訊就是這台 Sony a6000<br>是一台新手入門級 APS-C 的微單眼</p>
<p>我就想！好！買了！<br>與其上網一直研究<br>不如直接買一台來認識會比較快～</p>
<p><strong>註：<br>我後來發現滿多人入門相機會選佳能Canon<br>聽說是拍人像會比較美白<br>所以想拍人像但又是第一次買相機的人可以研究看看</strong></p>
<h3 id="購買管道"><a href="#購買管道" class="headerlink" title="購買管道"></a>購買管道</h3><p>當時相機是在 Ewhat 億華數位科技買的水貨</p>
<blockquote>
<p>平行進口貨品（英語：parallel import），或平行輸入貨品，<br>一般俗稱水貨，為無經由正式代理商進口的貨品</p>
</blockquote>
<p>型號是：ILCE-6000L</p>
<blockquote>
<p>機身 + 16-50 mm 電動變焦鏡<br><a href="https://www.sony.com.tw/zh/electronics/interchangeable-lens-cameras/ilce-6000-body-kit/specifications" target="_blank" rel="noopener">官網資訊</a></p>
</blockquote>
<p>購入日期：2020/03/06<br>購入價格：-</p>
<h3 id="硬體規格"><a href="#硬體規格" class="headerlink" title="硬體規格"></a>硬體規格</h3><table>
<thead>
<tr>
<th>鏡頭接環</th>
<th>感光元件</th>
<th>像素</th>
<th>錄影格式</th>
<th>ISO 感光度</th>
<th>快門速度</th>
</tr>
</thead>
<tbody><tr>
<td>Sony E 接環鏡頭</td>
<td>APS-C 型 (23.5 x 15.6 mm)</td>
<td>2430 萬像素</td>
<td>AVCHD 2.0 / MP4</td>
<td>ISO 100-25600</td>
<td>1/4000 至 30 秒</td>
</tr>
</tbody></table>
<p>詳細規格可以參考 <a href="https://store.sony.com.tw/product/spec/T5YKAQusgTAAAAFEb98C6E1R" target="_blank" rel="noopener">Sony 官網</a></p>
<h3 id="鏡頭規格"><a href="#鏡頭規格" class="headerlink" title="鏡頭規格"></a>鏡頭規格</h3><h4 id="SELP1650-E-PZ-16-50mm-F3-5-5-6-OSS"><a href="#SELP1650-E-PZ-16-50mm-F3-5-5-6-OSS" class="headerlink" title="[SELP1650 - E PZ 16-50mm F3.5-5.6 OSS]"></a><a href="https://store.sony.com.tw/product/spec/2_4KAQuxSwcAAAE8YrcbcK5x" target="_blank" rel="noopener">[SELP1650 - E PZ 16-50mm F3.5-5.6 OSS]</a></h4><p>購入管道：Ewhat<br>購入時間：2020/03/06<br>購入價格：-<br>使用心得：kit 組內鏡頭，還不錯，可是不能望遠！<br>賣出管道：FB Marketplace<br>賣出時間：2021/09/22<br>賣出價格：NTD 2,000</p>
<h4 id="七工匠-7artisans-35mm-F1-2-E"><a href="#七工匠-7artisans-35mm-F1-2-E" class="headerlink" title="[七工匠 7artisans 35mm F1.2 E]"></a><a href="http://www.7artisans.com/prod_view.aspx?nid=3&typeid=104&id=403" target="_blank" rel="noopener">[七工匠 7artisans 35mm F1.2 E]</a></h4><p>購入管道：露天市場/數位達人<br>購入時間：2020/12/31<br>購入價格：NTD 3,810<br>使用心得：大光圈，可以拍淺景深，手動對焦。</p>
<h4 id="SEL55210-E55–210mm-F4-5–6-3-OSS"><a href="#SEL55210-E55–210mm-F4-5–6-3-OSS" class="headerlink" title="[SEL55210 - E55–210mm F4.5–6.3 OSS]"></a><a href="https://www.sony.com.tw/zh/electronics/camera-lenses/sel55210" target="_blank" rel="noopener">[SEL55210 - E55–210mm F4.5–6.3 OSS]</a></h4><p>購入管道：Ewhat<br>購入價格： -<br>使用心得：望遠鏡頭，可是不適合拍景！<br>賣出管道：FB Marketplace<br>賣出時間：2021/09/21<br>賣出價格：NTD 3,300</p>
<h4 id="SEL18200-E18-200mm-F3-5-6-3-OSS"><a href="#SEL18200-E18-200mm-F3-5-6-3-OSS" class="headerlink" title="[SEL18200 - E18-200mm F3.5-6.3 OSS]"></a><a href="https://store.sony.com.tw/product/spec/72MKAQuxKBwAAAEq_AALaNB7" target="_blank" rel="noopener">[SEL18200 - E18-200mm F3.5-6.3 OSS]</a></h4><p>購入管道：FB Marketplace<br>購入時間：2021/07/24<br>購入價格： -<br>使用心得：最後常用的旅遊鏡頭(因為發現單眼應換鏡頭很麻煩，但又想可以拍景以可以拍望遠！)</p>
<h3 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h3><p>用這台也嘗試拍過滿多類型的照片：</p>
<ul>
<li>動物</li>
<li>植物</li>
<li>風景</li>
<li>人像</li>
<li>月亮</li>
</ul>
<div style="display: flex;">
  <img src="/images/sony/cat-2.jpg"  />
  <img src="/images/sony/cat-1.jpg"  />
</div>

<p><strong>瑞芳猴硐貓村的貓咪們</strong></p>
<p>各種小結論：</p>
<ul>
<li>旅遊鏡還是最方便的</li>
<li>望遠鏡頭可以達到手機鏡頭作不到的效果，拍動物和月亮等等。</li>
<li>高速快門可以拍快速運動的照片不會糊掉</li>
<li>大光圈和望網鏡頭都可以拍淺景深的照片</li>
<li>焦距長拍淺景深會比較容易些，但畫面會有壓縮的效果。<blockquote>
<p>讓遠的景物和近的景物差不多大</p>
</blockquote>
</li>
<li>手機下載 sony 應用 wifi 就可以連手機傳照片很方便</li>
<li>這台螢幕不可以外翻，但自拍可以用 sony 的應用 wifi 控制相機</li>
<li>程式自動模式拍照還是最方便的，拍不出效果再用手動</li>
<li>光圈很重要，不然天色一暗就不好拍照了(調高 ISO 會犧牲畫質)</li>
<li>非常專業的相片效果還是需要經過後製處理(像是 lightroom)</li>
</ul>
<h2 id="Sony-rx100m5a"><a href="#Sony-rx100m5a" class="headerlink" title="Sony rx100m5a"></a>Sony rx100m5a</h2><h3 id="購買緣由-1"><a href="#購買緣由-1" class="headerlink" title="購買緣由"></a>購買緣由</h3><p>因為之前有先買過 sony a6000<br>後來很常在 youtube 上看一些拍照的教學<br>意外發現很多 YT 都推薦 rx100m5a<br>也是很多 YT 的入門相機<br>俗稱<strong>黑卡</strong></p>
<blockquote>
<p>索尼 RX 系列相機的暱稱。<br>黑卡具有高素質的蔡司鏡頭。<br>濃縮了許多 sony 高科技於一身的卡片相機。</p>
</blockquote>
<p>然後就很想體驗看看…<br>就買了…</p>
<h3 id="購買管道-1"><a href="#購買管道-1" class="headerlink" title="購買管道"></a>購買管道</h3><p>管道：Ewhat<br>日期：2020/08/06<br>價格：NTD 18,480</p>
<h3 id="硬體規格-1"><a href="#硬體規格-1" class="headerlink" title="硬體規格"></a>硬體規格</h3><table>
<thead>
<tr>
<th>鏡頭</th>
<th>感光元件</th>
<th>像素</th>
<th>ISO 感光度</th>
<th>快門速度</th>
</tr>
</thead>
<tbody><tr>
<td>ZEISS Vario-Sonnar T* 鏡頭</td>
<td>1.0 吋 Exmor RS® CMOS 感光元件</td>
<td>約 2,010 萬像素</td>
<td>ISO 125-12800</td>
<td>1/32000 至 30 秒</td>
</tr>
</tbody></table>
<p>詳細規格可以參考 <a href="https://www.sony.com.tw/zh/electronics/cyber-shot-compact-cameras/dsc-rx100m5a/specifications" target="_blank" rel="noopener">Sony 官網</a></p>
<table>
<thead>
<tr>
<th>光圈</th>
<th>焦距</th>
<th>對焦範圍</th>
</tr>
</thead>
<tbody><tr>
<td>F1.8 (廣角) - 2.8 (望遠)</td>
<td>f=8.8-25.7 mm</td>
<td>廣角︰ 約 5 cm 至無限遠，望遠︰ 約 30 cm 至無限遠</td>
</tr>
</tbody></table>
<h3 id="使用心得-1"><a href="#使用心得-1" class="headerlink" title="使用心得"></a>使用心得</h3><p>擁有蔡司鏡頭是不少人的夢想<br>然而買這台就實現了！</p>
<p>畫面會比一般鏡頭銳利些</p>
<p>那黑卡基本上就是黑卡<br>一台帶著走就很方便了  </p>
<p>另外續航力要留意一下<br>有需要可以多準備電池  </p>
<p>話雖如此</p>
<p>但我發現我還是需要望遠端<br>感覺望遠端的鏡頭可以給我帶來更大的樂趣<br>因為我還滿喜歡拍動物的<br>所以往後的代數可能對我而言會是更好的選擇</p>
<p><strong>註：<br>後面的代數是旅遊鏡的規格<br>可以同時滿足拍景與望遠<br>可是光圈會變小…</strong></p>
<p>但如果只是拍景或自拍這台的焦距和光圈都可以很好地滿足<br>就算是夜拍有很好的效果<br>因為光圈足夠大</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/08/07/我的單眼相機/">https://davidblog.github.io/2023/08/07/我的單眼相機/</a> </p>
]]></content>
      <categories>
        <category>生活札記</category>
      </categories>
  </entry>
  <entry>
    <title>前端技術雜談</title>
    <url>/2023/08/08/%E5%89%8D%E7%AB%AF%E5%B0%88%E6%A1%88%E6%8A%80%E8%A1%93%E9%9B%9C%E8%AB%87/</url>
    <content><![CDATA[<p>之前專案遇到可以談論的主題會先寫在日誌上<br>這樣部落格沒有靈感的話就可以直接取用 ʕ•̀ ω • ʔ<br>但有些想談論的主題沒有很深<br>無法單獨寫成一篇文章 ┑(￣ Д ￣)┍</p>
<p>所以想說可以用雜談的方式來聊：</p>
<ul>
<li>URL search 搜索字符串的常見參數與用途</li>
<li>.gitignore 忽略已追蹤過的檔案</li>
<li>傳統開發使用 polyfill 來模擬 ES6+ 的環境</li>
<li>CRA 專案預設的 eslint 規則</li>
</ul>
<a id="more"></a>

<h2 id="URL-search-搜索字符串的常見參數與用途"><a href="#URL-search-搜索字符串的常見參數與用途" class="headerlink" title="URL search 搜索字符串的常見參數與用途"></a>URL search 搜索字符串的常見參數與用途</h2><p>首先附上 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/search" target="_blank" rel="noopener">MDN 的文件介紹</a><br>還有它提供的代碼範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(</span><br><span class="line">  <span class="string">"https://developer.mozilla.org/zh-CN/docs/Web/API/URL/search?q=123"</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> queryString = url.search; <span class="comment">// Returns:"?q=123"</span></span><br></pre></td></tr></table></figure>

<p>URL search 是一個很方便且靈活的工具<br>很常被用來控制檢索畫面時的顯示訊息<br>基本上在各個大型網頁都會出現</p>
<p>所以設計網頁應用的過程<br>也可以多留意使用這個技巧</p>
<hr>
<p>底下列舉一些常用的參數與用途：</p>
<table>
<thead>
<tr>
<th>參數</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>modal</code></td>
<td>控制是否在模態框中打開搜索結果。</td>
<td><code>?modal=true</code> 或 <code>?modal=false</code></td>
</tr>
<tr>
<td><code>page</code></td>
<td>控制顯示的分頁。</td>
<td><code>?page=2</code></td>
</tr>
<tr>
<td><code>q</code></td>
<td>指定搜索的關鍵詞或查詢字符串。</td>
<td><code>?q=keyword</code></td>
</tr>
<tr>
<td><code>sort</code></td>
<td>指定搜索結果的排序方式。</td>
<td><code>?sort=date</code></td>
</tr>
<tr>
<td><code>lang</code></td>
<td>指定搜索結果的語言。</td>
<td><code>?lang=en</code></td>
</tr>
<tr>
<td><code>date</code></td>
<td>限制搜索結果在特定日期範圍內。</td>
<td><code>?date=2023-01-01..2023-07-31</code></td>
</tr>
</tbody></table>
<h2 id="gitignore-忽略已追蹤過的檔案"><a href="#gitignore-忽略已追蹤過的檔案" class="headerlink" title=".gitignore 忽略已追蹤過的檔案"></a>.gitignore 忽略已追蹤過的檔案</h2><p>.gitignore 基本上就是用來記錄不要加入版控的檔案<br>這個 .gitignore 通常會在專案搭建的一開始就定義好</p>
<p>不過處理專案的實務上<br>還是會遇到<br>噎…這個檔案不應該加在版控裡面呀<br>但是它已經被追縱過了<br>所以當你在.gitignore 新增已經追縱過的檔案時<br>就沒有作用了</p>
<p>解決方法可以用<code>git rm -r --cached .</code><br>來把本地緩存的紀錄給刪除<br>這樣再提交就沒問題了</p>
<h2 id="傳統開發使用-polyfill-來模擬-ES6-的環境"><a href="#傳統開發使用-polyfill-來模擬-ES6-的環境" class="headerlink" title="傳統開發使用 polyfill 來模擬 ES6+ 的環境"></a>傳統開發使用 polyfill 來模擬 ES6+ 的環境</h2><p>基本上現代專案開發都使用框架來搭建專案<br>一般來說可以不用自己去處理 webpack 和 babel 等腳手架設定<br>只需要專注在前端程式的開發就好</p>
<p>但有些簡單的畫面可能已經有設計人員切好版<br>你只需要直接撰寫程式即可</p>
<p>這種情況下<br>基於兼顧瀏覽器的相容性<br>你可以使用 jQuery 或是 ES5 來撰寫</p>
<p>另一種方式是可以引入 <a href="https://www.jsdelivr.com/package/npm/@babel/polyfill" target="_blank" rel="noopener">@babel/polyfill</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">https://cdn.jsdelivr.net/npm/@babel/polyfill@7.12.1/dist/polyfill.min.js</span></span></span><br><span class="line"><span class="tag"><span class="string">"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>這個版本的@babel/polyfill 可以模擬 ES6+ ~ ES10(ES2019)的環境<br><strong>註：@babel/polyfill 包含 core-js v2.x 和 regenerator-runtime</strong></p>
<p>但上網查在 Babel 某個版本之後 @babel/polyfill 已經被棄用了<br>而改用 core-js v3 和 regenerator-runtime 來進行一些更細部的操作和避免過去全局污染的潛在問題</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/core-js@3.20.1/dist/core.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/regenerator-runtime@0.13.7/runtime.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>這邊附註一下 core-js 與 regenerator-runtime 說明的參考資料：</p>
<table>
<thead>
<tr>
<th>特點</th>
<th>core-js</th>
<th>regenerator-runtime</th>
</tr>
</thead>
<tbody><tr>
<td>目的</td>
<td>用於填充 ECMAScript 功能的庫</td>
<td>用於異步生成器的運行時庫</td>
</tr>
<tr>
<td>兼容性</td>
<td>提供新的 ECMAScript API</td>
<td>專注於生成器/轉譯器需求</td>
</tr>
<tr>
<td>使用</td>
<td>通常用於所有 JavaScript 代碼</td>
<td>通常與 async/await 一起使用</td>
</tr>
<tr>
<td>填充範圍</td>
<td>涵蓋廣泛的新功能</td>
<td>專門針對生成器函數</td>
</tr>
<tr>
<td>大小</td>
<td>由於填充範圍更廣，所以較大</td>
<td>由於專注於特定用途，所以較小</td>
</tr>
<tr>
<td>異步/等待</td>
<td>不直接處理異步代碼</td>
<td>處理異步生成器函數</td>
</tr>
<tr>
<td>生成器支持</td>
<td>不提供生成器功能</td>
<td>增強異步生成器性能</td>
</tr>
<tr>
<td>導入方式</td>
<td>根據需要導入各個功能</td>
<td>作為整體導入，用於生成器功能</td>
</tr>
<tr>
<td>自定義性</td>
<td>提供選項以包括特定功能</td>
<td>自定義選項有限</td>
</tr>
</tbody></table>
<h2 id="CRA-專案預設的-eslint-規則"><a href="#CRA-專案預設的-eslint-規則" class="headerlink" title="CRA 專案預設的 eslint 規則"></a>CRA 專案預設的 eslint 規則</h2><p>如果你是用 create-react-app 來搭建專案<br>基本上專案裡頭就已經包含了 eslist 的設定<br>而這個預設的規則就是 <code>react-app</code><br>可以在 package.json 裡面看到：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"eslintConfig": &#123;</span><br><span class="line">  "extends": "react-app"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>但是如果想搭配 VS code 的 ESLint 插件來檢查語法<br>可能會用<code>eslint --init</code>來創建設定檔<br>不過在裡頭的 react 相關配置中沒有 <code>react-app</code><br>只有 <code>eslint:recommended</code> 和 <code>plugin:react/recommended</code></p>
<p>如果還是想用 CRA 預設的 eslint 規則可修改 <code>.eslintrc.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// extends: ["eslint:recommended", "plugin:react/recommended"],</span></span><br><span class="line">extends: [<span class="string">"react-app"</span>],</span><br></pre></td></tr></table></figure>

<hr>
<p>底下附註這幾項規則的參考資料：</p>
<table>
<thead>
<tr>
<th>特點</th>
<th>react-app</th>
<th>eslint:recommended</th>
<th>plugin:react/recommended</th>
</tr>
</thead>
<tbody><tr>
<td>規則來源</td>
<td>專為 React 項目設計</td>
<td>ESLint 官方推薦規則</td>
<td>React 插件官方推薦規則</td>
</tr>
<tr>
<td>覆蓋範圍</td>
<td>針對 React 相關規則</td>
<td>一般的 JavaScript 規則</td>
<td>React 特定規則</td>
</tr>
<tr>
<td>JSX 規則</td>
<td>包含 JSX 相關規則</td>
<td>無</td>
<td>包含 JSX 相關規則</td>
</tr>
<tr>
<td>異步渲染支持</td>
<td>不包含異步渲染規則</td>
<td>無</td>
<td>不包含異步渲染規則</td>
</tr>
<tr>
<td>類型檢查支持</td>
<td>不包含 TypeScript/Flow 等類型檢查規則</td>
<td>無</td>
<td>不包含類型檢查規則</td>
</tr>
<tr>
<td>特定框架功能檢查</td>
<td>檢查特定的 React 功能和最佳實踐</td>
<td>基本的 JavaScript 代碼質量檢查</td>
<td>檢查特定的 React 功能和最佳實踐</td>
</tr>
<tr>
<td>自定義性</td>
<td>有限，適用於大多數 Create React App 項目</td>
<td>可以根據項目需求進行配置</td>
<td>可以根據項目需求進行配置</td>
</tr>
<tr>
<td>適用場景</td>
<td>Create React App 項目中建議使用</td>
<td>通用 JavaScript 項目中建議使用</td>
<td>React 項目中建議使用</td>
</tr>
</tbody></table>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/08/08/前端專案技術雜談/">https://davidblog.github.io/2023/08/08/前端專案技術雜談/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>筆電拆解升級 RAM 和 SSD | Acer Aspire A715-75G</title>
    <url>/2023/09/06/%E7%AD%86%E9%9B%BB%E6%8B%86%E8%A7%A3%E5%8D%87%E7%B4%9A%20RAM%20%E5%92%8C%20SSD%20%7C%20Acer%20Aspire%20A715-75G/</url>
    <content><![CDATA[<p>舊筆電偶爾開機會遇上 <strong>No Bootable Device</strong> 的錯誤訊息<br>或是玩遊戲會藍屏<br>上網查了一些資訊可能和硬體有關<br>特別是 <strong>SSD</strong> 的部分</p>
<p>因為筆電已經過保了<br>想說就來手動升級<br>這樣不但可以修筆電<br>還可以順便提升性能<br>完全就是一石二鳥</p>
<p>第一次自行拆機升級也上網做了很多功課<br>就把這個過程紀錄在部落格裡吧</p>
<ul>
<li>購買及準備零件</li>
<li>製作 USB 開機碟</li>
<li>拆機更換零件</li>
<li>使用 USB 開機碟重新安裝作業系統</li>
<li>分割及合併硬碟</li>
</ul>
<a id="more"></a>

<h2 id="購買及準備零件"><a href="#購買及準備零件" class="headerlink" title="購買及準備零件"></a>購買及準備零件</h2><p>主要會用到的東西有：</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>功能</th>
<th>注意事項</th>
</tr>
</thead>
<tbody><tr>
<td>USB</td>
<td>用來製作開機碟</td>
<td>要先確認製作開機磁碟所需要的<strong>容量</strong><br />可以在搜尋欄點選<strong>修復磁碟機</strong>查看</td>
</tr>
<tr>
<td>螺絲起子</td>
<td>用來拆機</td>
<td>記得要選長柄的，我一開始買短柄的拆不動</td>
</tr>
<tr>
<td>翹片</td>
<td>拆機的輔助工具</td>
<td>呵呵，如果沒有用指甲也可以，但很辛苦。</td>
</tr>
<tr>
<td>RAM</td>
<td>提升記憶體</td>
<td>筆電的尺寸(<strong>SODIMM</strong>)和桌機是不一樣的，需要留意，另外<strong>時脈選擇可以參考原本的記憶體</strong>，因為有些主機板可能會有支援上的限制，這樣就算買了較高的時脈也無法享受到其性能。</td>
</tr>
<tr>
<td>SSD</td>
<td>提升硬碟容量</td>
<td>這邊要注意的是 SSD 的種類和尺寸</td>
</tr>
</tbody></table>
<p><strong>補充</strong></p>
<p>SSD 的種類其實還滿多的，<br>但最重要的就是確認其<strong>介面</strong>和<strong>尺寸</strong>。</p>
<p>這邊列一下 SSD 介面主要規格的資訊：</p>
<table>
<thead>
<tr>
<th>介面</th>
<th>描述</th>
<th>插槽尺寸</th>
<th>速度</th>
<th>主要用途</th>
</tr>
</thead>
<tbody><tr>
<td>SATA</td>
<td>傳統的硬盤驅動器介面，較慢</td>
<td>2.5 吋 或 M.2</td>
<td>最高約 6 Gbps</td>
<td>桌面和筆記型電腦，成本較低，適合存儲和一般任務</td>
</tr>
<tr>
<td>mSATA</td>
<td>迷你 SATA 介面，用於特定筆記型電腦</td>
<td>mSATA</td>
<td>最高約 6 Gbps</td>
<td>過去的筆記型電腦，現在較少使用</td>
</tr>
<tr>
<td>PCIe</td>
<td>使用 PCIe 插槽，提供高速數據傳輸</td>
<td>PCIe 插槽</td>
<td>速度取決於規格（4.0 / 5.0 等）</td>
<td>高性能桌面電腦，工作站，遊戲，虛擬化，專業應用等</td>
</tr>
<tr>
<td>M.2</td>
<td>小型、高性能 SSD 介面，支持 SATA 和 NVMe</td>
<td>M.2 插槽</td>
<td>取決於支援的協議</td>
<td>桌面和筆記型電腦，高性能要求，專業工作，遊戲等</td>
</tr>
</tbody></table>
<p><strong>然後我買的是：</strong></p>
<ul>
<li><p>RAM: Transcend - 8GB JM DDR4 2666 SO-DIMM 1Rx8 1.2V</p>
<table>
<thead>
<tr>
<th>項目</th>
<th>資訊</th>
</tr>
</thead>
<tbody><tr>
<td>品牌</td>
<td>Transcend</td>
</tr>
<tr>
<td>價格</td>
<td>NTD 529</td>
</tr>
<tr>
<td>規格</td>
<td>DDR4-2666MHz</td>
</tr>
<tr>
<td>尺寸</td>
<td>SO-DIMM</td>
</tr>
<tr>
<td>容量</td>
<td>8GB</td>
</tr>
<tr>
<td>Rank</td>
<td>1Rx8</td>
</tr>
<tr>
<td>DRAM</td>
<td>1Gx8</td>
</tr>
<tr>
<td>工作電壓</td>
<td>1.2V</td>
</tr>
</tbody></table>
</li>
<li><p>SSD: Kingston - KC3000 1024GB PCIe 4.0 NVMe M.2 (讀:7000MB/秒, 寫:6000MB/秒)</p>
<table>
<thead>
<tr>
<th>項目</th>
<th>資訊</th>
</tr>
</thead>
<tbody><tr>
<td>品牌</td>
<td>Kingston</td>
</tr>
<tr>
<td>價格</td>
<td>NTD 2,099</td>
</tr>
<tr>
<td>規格</td>
<td>PCIe 4.0 NVMe M.2</td>
</tr>
<tr>
<td>尺寸</td>
<td>M.2 2280</td>
</tr>
<tr>
<td>容量</td>
<td>1024GB</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="製作-USB-開機碟"><a href="#製作-USB-開機碟" class="headerlink" title="製作 USB 開機碟"></a>製作 USB 開機碟</h2><p>我的作業系統是 Windows 11<br>在 Windows 搜尋欄輸入<strong>修復磁碟機</strong>，然後點選<strong>開啟</strong><br>接下來就是插入 USB<br>並按照指引說明操作即可</p>
<p>話說我一開始上網查<br>普遍的資訊是製作 USB 開機碟會需要 16GB 的容量<br>所以我買了 32GB 的 USB 碟<br>想說這樣很夠用</p>
<p>然後到了導引的部分建議我 USB 要大於 32GB…<br>看了有點崩潰<br>不過我還是試著先用 32GB 的 USB 來製作<br>好在製作成功了<br>實際容量並沒有那麼大</p>
<p>現在很多資訊都會隨時代變化<br>上網查是一回事<br>實際遇到的情況又是一回事</p>
<h2 id="拆機更換零件"><a href="#拆機更換零件" class="headerlink" title="拆機更換零件"></a>拆機更換零件</h2><p>我的筆電是 Acer Aspire A715-75G<br>背板會有 13 顆螺絲<br>卸除螺絲後<br>慢慢撬開背板  </p>
<p><strong>註：3面撬開就可以卸下背板了</strong></p>
<p><img src="/images/laptop/a7.jpeg" alt=""></p>
<p>第一件事是先拆除電池以防安全<br>這一步驟是網上學來的  </p>
<p><img src="/images/laptop/battery.jpeg" alt=""></p>
<p>不過因為忘記了這件事  </p>
<p>我的操作順序是： 先加裝記憶體 -&gt; 啊！電池好像要先拆 -&gt; 風散看起來要清 -&gt; 換 SSD</p>
<p>風扇區積了很多灰塵<br>雖然不知道怎清<br>也沒特別做功課<br>但還是決定要清  </p>
<p><strong>註：過熱也會影響效能，所以散熱很重要</strong></p>
<p>我是用針去挑棉絮狀的灰塵<br>其他就不管了<br>因為也不是很懂硬體<br>在沒做充足功課下就先別亂動  </p>
<p><img src="/images/laptop/fan.jpeg" alt=""></p>
<p>最後來看一下都換好的樣子吧：  </p>
<p><img src="/images/laptop/a7-clean.jpeg" alt=""></p>
<h2 id="使用-USB-開機碟重新安裝作業系統"><a href="#使用-USB-開機碟重新安裝作業系統" class="headerlink" title="使用 USB 開機碟重新安裝作業系統"></a>使用 USB 開機碟重新安裝作業系統</h2><p>基本上把硬體的零件都換好後，<br>重新接上電池和電源，<br>插入USB開機碟並開機，<br>就會進到重設電腦的指引會面了。  </p>
<p><strong>註：如果沒有的話，可以按F12調整開機時啟用BIOS和USB的順序</strong>  </p>
<p>話說現在安裝 Windows 11 有一點滿機車的<br>就是一定要登入微軟帳號…  </p>
<p>不過上網查有小技巧可以跳過<br>那就是一開始選擇連網時先略過<br>這樣就可以本機直接登入  </p>
<p>或是直接輸入錯誤的帳密來登入<br>這樣也可以回到本機登入  </p>
<p>OS: 何必呢…</p>
<h2 id="分割及合併硬碟"><a href="#分割及合併硬碟" class="headerlink" title="分割及合併硬碟"></a>分割及合併硬碟</h2><p>一切準備就緒，<br>我就打開工作管理員和本機，<br>來檢查是不是硬體都安裝到位了。  </p>
<p>記憶體沒什麼問題，<br>原本就有8GB，<br>再加裝後就有16GB了！  </p>
<p>另外SSD 總共有1TB的容量，<br>容量是沒問題，<br>可是硬碟分割的槽卻很瞎。  </p>
<p>C槽 700多GB<br>D槽 200多GB  </p>
<p>因為C槽是系統槽，<br>我偏向是不安裝東西的，<br>所有遊戲和軟體都安裝在D槽，<br>這樣心裡感覺比較舒服  </p>
<p>所以我想把C槽的部分容量移給D槽，  </p>
<p>我一開始是使用內建的硬碟工具，<br>但遇到了一件更瞎的事，  </p>
<p>讓我認識了<strong>相鄰與不相鄰的硬碟分割區</strong>  </p>
<p>這是非常奇葩的規則<br>如果要合併硬碟上兩個未配置的空間<br>它們必須<strong>相鄰</strong></p>
<p>那我遇上的問題就是<br><strong>C分割區</strong>和<strong>D分割區</strong>中間卡一個<strong>修復磁碟區</strong></p>
<p>上網查了一下<br>據說可以刪掉<br>不影響使用<strong>但不能再使用修復磁碟機和系統還原</strong>的功能<br>(註：就是製作USB開機碟會用到的工具，但其實已經製作過就不是那麼影響，應該吧…)  </p>
<p>另一個分法是使用三方軟體來移動磁碟的分割區<br>後來我選這個 呵呵  </p>
<p>我用的是 <a href="https://www.diskpart.com/tw/free-partition-manager.html" target="_blank" rel="noopener">AOMIE 免費版本</a><br>在一番操作下終於成功把C槽大部分的空間移到D槽了 (撒花  </p>
<p>最後就是漫長的重新安裝需要用的軟體(柏德之門3 etc.)的過程哩…  </p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： [<a href="https://davidblog.github.io/2023/09/06/筆電拆解升級">https://davidblog.github.io/2023/09/06/筆電拆解升級</a> RAM 和 SSD | Acer Aspire A715-75G/](<a href="https://davidblog.github.io/2023/09/06/筆電拆解升級">https://davidblog.github.io/2023/09/06/筆電拆解升級</a> RAM 和 SSD | Acer Aspire A715-75G/) </p>
]]></content>
      <categories>
        <category>生活札記</category>
      </categories>
  </entry>
  <entry>
    <title>根據畫面剩餘高度建立滾動區域</title>
    <url>/2023/07/28/%E6%A0%B9%E6%93%9A%E7%95%AB%E9%9D%A2%E5%89%A9%E9%A4%98%E9%AB%98%E5%BA%A6%E5%BB%BA%E7%AB%8B%E6%BB%BE%E5%8B%95%E5%8D%80%E5%9F%9F/</url>
    <content><![CDATA[<p>這個應用場境是什麼時候會出現呢？<br>大概是製作<span style="color: lightcoral">手機版型的網頁</span>時會出現…</p>
<p>實現的方法具體來說很簡單<br>只需要用到兩個 CSS 的特性：</p>
<ul>
<li>flex</li>
<li>calc</li>
</ul>
<a id="more"></a>

<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>flex 應該還是目前比較主流的排版方式<br>手機的版型一般來說是縱向設計<br>所以會需要在容器的父元素加上：</p>
<ul>
<li><code>display=&quot;flex&quot;</code></li>
<li><code>flexDirection=&quot;column&quot;</code></li>
</ul>
<p>當然還有父元素高度要設定</p>
<ul>
<li><code>height=&quot;100vh&quot;</code></li>
</ul>
<p>再來就是讓需要建立滾動區塊的子元素佔滿剩餘可用空間：</p>
<ul>
<li><code>flex={1}</code></li>
<li><code>overflow=&quot;auto&quot;</code></li>
</ul>
<p>JSX 代碼範例可以參考下方：</p>
<p><strong>實際的寫法可以根據專案需求再做調整</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Box display=<span class="string">"flex"</span> flexDirection=<span class="string">"column"</span> height=<span class="string">"100vh"</span>&gt;</span><br><span class="line">  &lt;TopBar title=<span class="string">"頁面標題"</span> /&gt;</span><br><span class="line">  &lt;Tabs currentTab=&#123;currentTab&#125; setCurrentTab=&#123;setCurrentTab&#125; /&gt;</span><br><span class="line">  &#123;<span class="comment">/* 利用剩餘高度建立的滾動區塊 */</span>&#125;</span><br><span class="line">  &lt;Box flex=&#123;<span class="number">1</span>&#125; overflow=<span class="string">"auto"</span>&gt;</span><br><span class="line">    &lt;List /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Box&gt;</span></span><br><span class="line"><span class="regexp">  &lt;ButtonGroup /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/Box&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h2><p>根據不同專案的 layout 設計<br>可能會出現固定式的 TopBar 或 FooterBar  </p>
<p>萬一遇到這種情況要如何處理呢<br>可以用 calc 這個 css 特型來對高度進行輔助計算</p>
<p>這邊的場景是假設 layout 還包含了一個 position: fixed 的 FooterBar（80px）<br>這樣頁面父元素的高度可以改寫為：</p>
<ul>
<li><code>height=&quot;calc(100vh - 80px)&quot;</code></li>
</ul>
<p>改寫後 JSX 代碼範例可以參考下方：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Box display=<span class="string">"flex"</span> flexDirection=<span class="string">"column"</span> height=<span class="string">"calc(100vh - 80px)"</span>&gt;</span><br><span class="line">  &lt;TopBar title=<span class="string">"頁面標題"</span> /&gt;</span><br><span class="line">  &lt;Tabs currentTab=&#123;currentTab&#125; setCurrentTab=&#123;setCurrentTab&#125; /&gt;</span><br><span class="line">  &#123;<span class="comment">/* 利用剩餘高度建立的滾動區塊 */</span>&#125;</span><br><span class="line">  &lt;Box flex=&#123;<span class="number">1</span>&#125; overflow=<span class="string">"auto"</span>&gt;</span><br><span class="line">    &lt;List /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Box&gt;</span></span><br><span class="line"><span class="regexp">  &lt;ButtonGroup /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/Box&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/07/28/根據畫面剩餘高度建立滾動區域/">https://davidblog.github.io/2023/07/28/根據畫面剩餘高度建立滾動區域/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>活動網頁實用套件</title>
    <url>/2023/07/24/%E6%B4%BB%E5%8B%95%E7%B6%B2%E9%A0%81%E5%AF%A6%E7%94%A8%E5%A5%97%E4%BB%B6/</url>
    <content><![CDATA[<p>活動網頁和一般網頁差在哪裡呢?<br>答案是 <span style="color:gold;">登登登登登</span><br>許多<span style="color:lightcoral;">炫炮動畫</span></p>
<p>為了製作炫砲的動畫<br>開發者需要什麼製作工具呢<br>底下就列出幾種常見的套件給大家做為參考：</p>
<ul>
<li>animate.css</li>
<li>aos.js</li>
<li>swiper.js</li>
<li>remodal.js</li>
<li>parallax.js</li>
</ul>
<a id="more"></a>

<h2 id="animate-css"><a href="#animate-css" class="headerlink" title="animate.css"></a><a href="https://animate.style/" target="_blank" rel="noopener">animate.css</a></h2><p>這是家喻戶曉的 CSS 動畫庫<br>也是我最喜歡的動畫庫之一<br>裡面提供了很多基本的動畫效果<br>像是 fadeIn, fadeOut 等等<br>使用方法也非常簡單<br>只要引入套件後<br>在想要使用的元素上加上對應的 class 就可以了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"animate__animated animate__bounce"</span>&gt;</span>An animated element<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>除此之外還可以指定動畫播放得<strong>快慢</strong>與<strong>重複次數</strong></p>
<table>
<thead>
<tr>
<th>Class name</th>
<th>Default speed time</th>
</tr>
</thead>
<tbody><tr>
<td>animate__slow</td>
<td>2s</td>
</tr>
<tr>
<td>animate__slower</td>
<td>3s</td>
</tr>
<tr>
<td>animate__fast</td>
<td>800ms</td>
</tr>
<tr>
<td>animate__faster</td>
<td>500ms</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Class Name</th>
<th>Default iteration count</th>
</tr>
</thead>
<tbody><tr>
<td>animate__repeat-1</td>
<td>1</td>
</tr>
<tr>
<td>animate__repeat-2</td>
<td>2</td>
</tr>
<tr>
<td>animate__repeat-3</td>
<td>3</td>
</tr>
<tr>
<td>animate__infinite</td>
<td>infinite</td>
</tr>
</tbody></table>
<h2 id="aos-js"><a href="#aos-js" class="headerlink" title="aos.js"></a><a href="https://michalsnik.github.io/aos/" target="_blank" rel="noopener">aos.js</a></h2><p>aos.js也是用來呈現css動畫效果<br>不過更讚的是他能夠搭配畫面滾動來呈現效果<br>使用方法也很簡單<br>也是先引入庫<br>在想要使用其效果的元素上加上data-aos屬性即可  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-aos</span>=<span class="string">"fade-up"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="swiper-js"><a href="#swiper-js" class="headerlink" title="swiper.js"></a><a href="https://swiperjs.com/" target="_blank" rel="noopener">swiper.js</a></h2><p>一款專注於幻燈片效果的套件<br>提供了多種很棒的滑塊效果<br>另外也可以用此套件作出全屏滾動的效果<br>如果有特別需求是可以用來替代<a href="https://alvarotrigo.com/fullPage/" target="_blank" rel="noopener">FullPage</a>  </p>
<p><strong>註：FullPage is an Open Source application licensed under a GPLv3 license</strong></p>
<p>底下是官網提供的代碼範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">swiper-container</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>Slide 1<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>Slide 2<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>Slide 3<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>Slide ...<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper-container</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="remodal-js"><a href="#remodal-js" class="headerlink" title="remodal.js"></a><a href="https://vodkabears.github.io/remodal/" target="_blank" rel="noopener">remodal.js</a></h2><p>模態框幾乎在每個網站都會出現<br>主要是用來提供基本的互動效果與單獨的資訊內容  </p>
<p>底下是官網提供的基礎代碼：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"remodal"</span> <span class="attr">data-remodal-id</span>=<span class="string">"modal"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-remodal-action</span>=<span class="string">"close"</span> <span class="attr">class</span>=<span class="string">"remodal-close"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Remodal<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Responsive, lightweight, fast, synchronized with CSS animations, fully customizable modal window plugin with declarative configuration and hash tracking.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-remodal-action</span>=<span class="string">"cancel"</span> <span class="attr">class</span>=<span class="string">"remodal-cancel"</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-remodal-action</span>=<span class="string">"confirm"</span> <span class="attr">class</span>=<span class="string">"remodal-confirm"</span>&gt;</span>OK<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如要呼叫出這個modal有兩種方式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#modal"</span>&gt;</span>Call the modal with data-remodal-id="modal"<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">data-remodal-target</span>=<span class="string">"modal"</span>&gt;</span>Call the modal with data-remodal-id="modal"<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一種方式我特別喜歡也特別實用<br>只需要在網址列上使用hash的方式就可以直接呼叫出modal了  </p>
<h2 id="parallax-js"><a href="#parallax-js" class="headerlink" title="parallax.js"></a><a href="https://matthew.wagerfield.com/parallax/" target="_blank" rel="noopener">parallax.js</a></h2><p>一種視差引擎  </p>
<blockquote>
<p>維基百科：指在不同位置觀察遠近兩物體時，它們間發生相對位置變化的現象</p>
</blockquote>
<p>它可以用來製作佈景效果<br>讓網站的Banner提供有趣的互動<br>會因會鼠標在畫面上移動<br>讓佈景跟著一起移動  </p>
<p>底下為官網提供的代碼範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"scene"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-depth</span>=<span class="string">"0.2"</span>&gt;</span>My first Layer!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-depth</span>=<span class="string">"0.6"</span>&gt;</span>My second Layer!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scene = <span class="built_in">document</span>.getElementById(<span class="string">'scene'</span>);</span><br><span class="line"><span class="keyword">var</span> parallaxInstance = <span class="keyword">new</span> Parallax(scene);</span><br></pre></td></tr></table></figure>

<p><strong>註：data-depth屬性可以用來調控視差的幅度</strong></p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/07/24/活動網頁實用套件/">https://davidblog.github.io/2023/07/24/活動網頁實用套件/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>發佈 npm 套件的小細節</title>
    <url>/2023/07/26/%E7%99%BC%E4%BD%88-npm-%E5%A5%97%E4%BB%B6%E7%9A%84%E5%B0%8F%E7%B4%B0%E7%AF%80/</url>
    <content><![CDATA[<p>最近發佈了一個套件 <a href="https://www.npmjs.com/package/date-reminder" target="_blank" rel="noopener">date-reminder</a></p>
<p>起因是為了可以讓部落格<span style="color: blue">在特別的節日發出祝賀詞</span><br>但因為自己是懶人…<br>所以不可能自己在每個節日前手動更新網站<br>於是乎上網找了可以提醒的套件<br>結果…<span style="color: lightcoral">沒有！！！</span></p>
<p>就手動做了一個套件順便上傳  </p>
<p>底下講講發佈 npm 時我的遇到的問題與想法<br>還有首次製作 npm 時可以特別留意的小細節：</p>
<ul>
<li>撰寫 README.md</li>
<li>發佈 npm 時指定產品代碼與排除原始代碼</li>
<li>Webpack 打包時兼顧 Script Include 與 Script Module</li>
</ul>
<a id="more"></a>

<h2 id="撰寫-README-md"><a href="#撰寫-README-md" class="headerlink" title="撰寫 README.md"></a>撰寫 README.md</h2><p>替套件撰寫 README.md 應該是最重要的事</p>
<p>任何人要使用一個網路上的套件時<br>都會先看 README.md 寫的完不完整<br>能不能看完就理解套件是如何運作與使用<br>再來是看有沒有提供 Demo 與範例</p>
<p>當然還有更新日期與星星數等指標</p>
<p>總之就是要判斷這個套件好不好用<br>還有會不會有後續問題<br>才來決定要不要使用</p>
<p>我這邊先分享一個網站 <a href="https://readme.so/editor" target="_blank" rel="noopener">readme.so</a><br>這個網站提供了一些常用的範例<br>可以作為 readme 的架構</p>
<p>另外底下提供我認為比較通俗的範本：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="section"># Package Name (套件名稱)</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Description (說明)</span></span><br><span class="line"></span><br><span class="line">套件的主要用途與功能簡單說明</span><br><span class="line"></span><br><span class="line"><span class="section">## Installation (安裝方式)</span></span><br><span class="line"></span><br><span class="line">安裝說明</span><br><span class="line"></span><br><span class="line"><span class="section">## Usage (使用方式)</span></span><br><span class="line"></span><br><span class="line">需要包含代碼範例還有 API 文件</span><br><span class="line"></span><br><span class="line"><span class="section">## License (許可)</span></span><br><span class="line"></span><br><span class="line">許可說明</span><br></pre></td></tr></table></figure>

<h2 id="發佈-npm-時指定產品代碼與排除原始代碼"><a href="#發佈-npm-時指定產品代碼與排除原始代碼" class="headerlink" title="發佈 npm 時指定產品代碼與排除原始代碼"></a>發佈 npm 時指定產品代碼與排除原始代碼</h2><p>講這個是因為我首次</p>
<p><code>npm publish</code></p>
<p>就把專案上的所有東西一起推上去了 XD</p>
<p>但是用套件的人安裝下去<br>其實只需要打包後的產品代碼呀 哈哈</p>
<p>所以我後續做了一些補救措施<br>也就是排除原始代碼與指定發佈檔案</p>
<p>如果要排除發佈的檔案<br>可以在專案根目錄加上 .npmignore<br>把用不著的原始代碼都給忽略掉</p>
<p>像是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"></span><br><span class="line">!&#x2F;dist&#x2F;js&#x2F;</span><br><span class="line">!package.json</span><br><span class="line">!README.md</span><br></pre></td></tr></table></figure>

<p>這樣<code>npm publish</code>時就會根據文檔案的內容決定哪些要推送哪些不要</p>
<p><strong>另外一種方式我比較推薦：</strong></p>
<p>就是直接在 package.json 裡面設定 files 屬性<br>如果有設定這個屬性基本上<code>npm publish</code>就只會看這個來決定有哪些檔案是要發佈的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;files&quot;: [</span><br><span class="line">  &quot;dist&#x2F;js&#x2F;&quot;,</span><br><span class="line">  &quot;package.json&quot;,</span><br><span class="line">  &quot;README.md&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h2 id="Webpack-打包時兼顧-Script-Include-與-Script-Module"><a href="#Webpack-打包時兼顧-Script-Include-與-Script-Module" class="headerlink" title="Webpack 打包時兼顧 Script Include 與 Script Module"></a>Webpack 打包時兼顧 Script Include 與 Script Module</h2><p>Script Include 就是 js 傳統模組化方式<br>就是在 html 裡面用 sciprt 標籤引入代碼的這種方式</p>
<p>Script Module 就是 Es Module 的模組化方式<br>可以使用 <code>import</code> 和 <code>export</code> 來進行匯入與匯出</p>
<p>如果是用 webpack 來打包產品的話<br>為了能使用 Script Include 的模組方式<br>要特別在 output 設定 library</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, &quot;dist&quot;),</span><br><span class="line">  filename: &quot;js&#x2F;[name].js&quot;,</span><br><span class="line">  library: &quot;dateReminder&quot;,</span><br><span class="line">  libraryTarget: &quot;umd&quot;,</span><br><span class="line">  libraryExport: &#39;default&#39;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>屬性</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td>library</td>
<td>模組的函數名稱</td>
</tr>
<tr>
<td>libraryTarget</td>
<td>模組的目標環境</td>
</tr>
<tr>
<td>libraryExport</td>
<td>模組的匯出方式</td>
</tr>
</tbody></table>
<p>library 的名稱基本上就是暴露出來的接口名稱可以在當前的全域環境裡調用<br>libraryTarget umd（Universal Module Definition）可以讓模組同時支持瀏覽器環境與 node 環境</p>
<p>另外比較特別的是這個 <span style="color: lightcoral">libraryExport</span></p>
<p>如果入口文件最後使用 export default 預設匯出的方式<br>就要特別在 webpack 設定 libraryExport: ‘default’<br>不然無法在全局裡直接根據 library 名稱來調用</p>
<p>其它備註：</p>
<table>
<thead>
<tr>
<th><code>libraryTarget</code></th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;var&quot;</code></td>
<td>在瀏覽器環境中將模組作為一個變數。</td>
</tr>
<tr>
<td><code>&quot;assign&quot;</code></td>
<td>在瀏覽器環境中將模組分配給特定的全局變數。</td>
</tr>
<tr>
<td><code>&quot;this&quot;</code></td>
<td>在瀏覽器環境中將模組分配給 <code>this</code> 對象。</td>
</tr>
<tr>
<td><code>&quot;window&quot;</code></td>
<td>在瀏覽器環境中將模組分配給 <code>window</code> 對象。</td>
</tr>
<tr>
<td><code>&quot;global&quot;</code></td>
<td>在 Node.js 環境中將模組分配給 <code>global</code> 對象。</td>
</tr>
<tr>
<td><code>&quot;commonjs&quot;</code></td>
<td>使用 CommonJS 的 <code>module.exports</code> 將模組暴露給瀏覽器或 Node.js 環境。</td>
</tr>
<tr>
<td><code>&quot;commonjs2&quot;</code></td>
<td>使用 CommonJS2 的 <code>module.exports</code> 將模組暴露給瀏覽器或 Node.js 環境。</td>
</tr>
<tr>
<td><code>&quot;amd&quot;</code></td>
<td>將模組定義為 AMD (Asynchronous Module Definition) 的形式，供瀏覽器使用。</td>
</tr>
<tr>
<td><code>&quot;umd&quot;</code></td>
<td>支持在 AMD 和 CommonJS 環境中使用的通用模組定義（Universal Module Definition）。</td>
</tr>
<tr>
<td><code>&quot;umd2&quot;</code></td>
<td>類似於 UMD，但使用了 CommonJS2 的 <code>module.exports</code>，適用於瀏覽器和 Node.js 環境。</td>
</tr>
<tr>
<td><code>&quot;thisGlobal&quot;</code></td>
<td>在瀏覽器中使用 <code>this</code> 對象，在 Node.js 中使用 <code>global</code> 對象，以便在兩者中都可使用。</td>
</tr>
</tbody></table>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/07/26/發佈-npm-套件的小細節/">https://davidblog.github.io/2023/07/26/發佈-npm-套件的小細節/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>筆電與程式開發</title>
    <url>/2023/07/31/%E7%AD%86%E9%9B%BB%E8%88%87%E7%A8%8B%E5%BC%8F%E9%96%8B%E7%99%BC/</url>
    <content><![CDATA[<p>程式開發的筆電究竟需要什麼樣的規格？<br>或許每個人心中都有不同的答案<br>還有不同的預算 (￣▽￣)ノ</p>
<p>底下就來聊聊幾款我開發用過的筆電：</p>
<ul>
<li>Lenovo IdeaPad 110S - 11 吋</li>
<li>Macbook Air i5 2013 - 11 吋</li>
<li>Macbook Pro i5 2017 - 13 吋</li>
<li>Macbook Air M1 2021 - 13 吋</li>
</ul>
<a id="more"></a>

<h2 id="Lenovo-IdeaPad-110S-11-吋"><a href="#Lenovo-IdeaPad-110S-11-吋" class="headerlink" title="Lenovo IdeaPad 110S - 11 吋"></a>Lenovo IdeaPad 110S - 11 吋</h2><h3 id="規格"><a href="#規格" class="headerlink" title="規格"></a>規格</h3><table>
<thead>
<tr>
<th>CPU</th>
<th>RAM</th>
<th>Storage</th>
<th>OS</th>
</tr>
</thead>
<tbody><tr>
<td>Intel Pentium N3710 1.6GHz</td>
<td>4G DDR3L</td>
<td>64G EMMC</td>
<td>Windows 10 Home</td>
</tr>
</tbody></table>
<h3 id="使用緣由"><a href="#使用緣由" class="headerlink" title="使用緣由"></a>使用緣由</h3><p>Lenovo 是便宜的選擇當中規格最好的<br>所以完全是年輕沒錢又要買筆電時的最佳首選<br>就這麼的單純</p>
<p>這款筆電當初是從燦坤買的<br>只花了 <strong>NTD 9,999</strong><br>據說是燦坤和 Lenovo 訂製的特殊規格<br>所以同樣型號的實際規格會比網上查到的還好一些</p>
<h3 id="使用經歷"><a href="#使用經歷" class="headerlink" title="使用經歷"></a>使用經歷</h3><p>仔細想想這樣規格的筆電搞開發會有什麼問題嗎？<br>我當初有用它來開發一款電子旅遊商務網站</p>
<p>專案裡頭沒有使用到任何現代框架<br>走一個前後端分離的傳統開發路線</p>
<p>基本上只有使用編輯器： Visual Studio Code<br>還有 Preview on Web Server 的插件來開發<br>雖然看上去非常克難<br>但完全夠用</p>
<p>因為開發過程中其實只需要編輯代碼還有預覽畫面就可以了</p>
<h3 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h3><p>我用過這個牌子的筆電總共有兩台<br>只聊其中一台是因為剛好只有用一台開發過</p>
<p>那 Lenovo 的筆電我推薦嗎？<br>嗯… 除非和我當初一樣年輕沒錢…<br>不然… 不推薦！！！</p>
<p>因為我用過的兩台都有一個通病<br>就是一年半載後硬體的某個部件就會出問題…</p>
<p>印象中一台是顯示器出問題<br>一台是鍵盤模組出問題</p>
<p>所以這牌子的品質真的是有待加強…</p>
<h2 id="Macbook-Air-i5-2013-11-吋"><a href="#Macbook-Air-i5-2013-11-吋" class="headerlink" title="Macbook Air i5 2013 - 11 吋"></a>Macbook Air i5 2013 - 11 吋</h2><h3 id="規格-1"><a href="#規格-1" class="headerlink" title="規格"></a>規格</h3><table>
<thead>
<tr>
<th>CPU</th>
<th>RAM</th>
<th>Storage</th>
<th>OS</th>
</tr>
</thead>
<tbody><tr>
<td>1.7GHz Intel Core i5</td>
<td>4GB DDR3</td>
<td>128GB SSD</td>
<td>macOS Mojave 10.14.4</td>
</tr>
</tbody></table>
<h3 id="使用緣由-1"><a href="#使用緣由-1" class="headerlink" title="使用緣由"></a>使用緣由</h3><p>專案上的貴人贈與！<br>剛好我也很想試 macOS 就收了！</p>
<h3 id="使用經歷-1"><a href="#使用經歷-1" class="headerlink" title="使用經歷"></a>使用經歷</h3><p>這款筆電一樣是用來開發電子旅遊商務網站<br>但在開發上替換了原本的 Lenovo IdeaPad 110S</p>
<h3 id="使用心得-1"><a href="#使用心得-1" class="headerlink" title="使用心得"></a>使用心得</h3><p>第一次在 macOS 的使用上<br>就可以感受到一些明顯的優點<br>像是日常不用關機<br>熟悉觸控板可以取代滑鼠<br>系統使用上比較順暢<br>畫面色彩佳<br>硬體壽命長！</p>
<p>當然需要注意的就是：<br>操作 macOS 和 Windows 有滿多地方不太一樣<br>所以一開始切換會需要花一些時間熟悉<br>才能盡情享受使用 macOS 開發的好處</p>
<h2 id="Macbook-Pro-i5-2017-13-吋"><a href="#Macbook-Pro-i5-2017-13-吋" class="headerlink" title="Macbook Pro i5 2017 - 13 吋"></a>Macbook Pro i5 2017 - 13 吋</h2><h3 id="規格-2"><a href="#規格-2" class="headerlink" title="規格"></a>規格</h3><table>
<thead>
<tr>
<th>CPU</th>
<th>RAM</th>
<th>Storage</th>
<th>OS</th>
</tr>
</thead>
<tbody><tr>
<td>2.3GHz Intel Core i5</td>
<td>16GB</td>
<td>256G SSD</td>
<td>-</td>
</tr>
</tbody></table>
<h3 id="使用緣由-2"><a href="#使用緣由-2" class="headerlink" title="使用緣由"></a>使用緣由</h3><p>專案配發</p>
<h3 id="使用經歷-2"><a href="#使用經歷-2" class="headerlink" title="使用經歷"></a>使用經歷</h3><p>這台除了一般網頁應用的開發<br>還擔任了手機跨平台混合式應用的開發</p>
<p>手機跨平台混合式應用<br>雖然平常撰寫的代碼還是在 VS Code 上</p>
<p>但預覽畫面要用到模擬機還會開：</p>
<ul>
<li>Android Studio</li>
<li>Xcode</li>
</ul>
<p>基本上使用 IDE 的模擬機還滿吃效能的<br>不用開系統監控 聽聽風扇起飛的聲音就可以知道了</p>
<h3 id="使用心得-2"><a href="#使用心得-2" class="headerlink" title="使用心得"></a>使用心得</h3><p>這台是我第一次使用蝶式鍵盤的筆電<br>雖然一開始有點不習慣<br>但習慣之後發現<br>鍵盤敲打的觸感也滿好的<br>特別是按鍵清脆的聲音很有節奏感！</p>
<p>另外在開發上如果有要開比較吃效能的軟體<br>最好再搭配一個筆電架<br><strong>筆電架起來和直接放桌上的散熱效果差非常多！</strong></p>
<h2 id="Macbook-Air-M1-2021-13-吋"><a href="#Macbook-Air-M1-2021-13-吋" class="headerlink" title="Macbook Air M1 2021 - 13 吋"></a>Macbook Air M1 2021 - 13 吋</h2><h3 id="規格-3"><a href="#規格-3" class="headerlink" title="規格"></a>規格</h3><table>
<thead>
<tr>
<th>CPU</th>
<th>RAM</th>
<th>Storage</th>
<th>OS</th>
</tr>
</thead>
<tbody><tr>
<td>Apple M1</td>
<td>16GB</td>
<td>256GB SSD</td>
<td>macOS Ventura 13.2.1</td>
</tr>
</tbody></table>
<h3 id="使用緣由-3"><a href="#使用緣由-3" class="headerlink" title="使用緣由"></a>使用緣由</h3><p>被媒體燒到<br>覺得 M1 太屌了 一定要買這樣！</p>
<blockquote>
<p>Apple M1 系列是蘋果公司第一款基於 ARM 架構的自研處理器單晶片系統，<br>於 2020 年 11 月 10 日推出。</p>
</blockquote>
<p>M1 是 Apple 的獨家晶片<br>雖然效能很強<br>但因為新<br>所以並不是所有軟體都第一時間相容<br>我那時還是忍了一陣子觀望才買 XD</p>
<p>買之前一直在逛這個網站 <a href="https://isapplesiliconready.com/tw" target="_blank" rel="noopener">能在 Apple 晶片上使用了嗎？</a></p>
<p>另外也得知了一個 CPU 跑分網站 <a href="https://www.cpubenchmark.net/cpu_list.php" target="_blank" rel="noopener">PassMark Software</a></p>
<p>最後買了 16GB 規格的 Macbook Air<br>價格是 <strong>NTD 36,900</strong><br>買的時間應該落在是 M1 出來過了半年左右的時間 (2021 年 5 月)</p>
<p>話說如果是 8GB 的統一規格只要 <strong>NTD 30,900</strong><br>以蘋果產品的定位來說價格是非常的親民</p>
<h3 id="使用經歷-3"><a href="#使用經歷-3" class="headerlink" title="使用經歷"></a>使用經歷</h3><p>主要都拿來開發現代化框架的網頁應用居多</p>
<h3 id="使用心得-3"><a href="#使用心得-3" class="headerlink" title="使用心得"></a>使用心得</h3><p>筆電沒有風散但散熱良好<br>寂靜運行使用順暢<br>續航時間長  </p>
<p>我認為筆電的重要價值之一就是要能夠<strong>隨身攜帶</strong><br>Air 的輕薄定位剛好就在這裡<br>然後搭配 M1 的晶片比起過往的 Pro 又有更強的效能</p>
<p>讚！</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/07/31/筆電與程式開發/">https://davidblog.github.io/2023/07/31/筆電與程式開發/</a> </p>
]]></content>
      <categories>
        <category>學習歷程</category>
      </categories>
  </entry>
  <entry>
    <title>調用攝像鏡頭</title>
    <url>/2023/08/04/%E8%AA%BF%E7%94%A8%E6%94%9D%E5%83%8F%E9%8F%A1%E9%A0%AD/</url>
    <content><![CDATA[<p>調用硬體的攝像鏡頭可以實現許多有趣的功能<br>像是<strong>拍照</strong>或是<strong>掃描 QR code</strong></p>
<p>底下來說明<strong>調用攝像鏡頭</strong>的方法吧：</p>
<ul>
<li>認識 MediaDevices 的 getUserMedia 方法</li>
<li>使用 getUserMedia 來調用攝像鏡頭(啟動及關閉)</li>
</ul>
<a id="more"></a>

<h2 id="認識-MediaDevices-的-getUserMedia-方法"><a href="#認識-MediaDevices-的-getUserMedia-方法" class="headerlink" title="認識 MediaDevices 的 getUserMedia 方法"></a>認識 MediaDevices 的 getUserMedia 方法</h2><p>調用鏡頭會需要先認識 MediaDevices 這個瀏覽器物件<br>詳細可以參考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia" target="_blank" rel="noopener">MDN(Mozilla Developer Network)</a> 的文檔</p>
<p>這邊就先列一下幾個比較重要的代碼範例：</p>
<p>調用方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.mediaDevices</span><br><span class="line">  .getUserMedia(constraints)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;&#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>constraints 這個參數可以指定要調用的硬體設備<br>像是<strong>麥克風</strong>或是<strong>攝像頭</strong></p>
<p>調用攝像頭：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  video: <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>調用攝像頭並<strong>優先使用前鏡頭</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  video: &#123;</span><br><span class="line">    facingMode: <span class="string">"user"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>調用攝像頭並<strong>優先使用後鏡頭</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  video: &#123;</span><br><span class="line">    facingMode: <span class="string">"environment"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>調用攝像頭並<strong>強制使用後鏡頭</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  video: &#123;</span><br><span class="line">    facingMode: &#123;</span><br><span class="line">      exact: <span class="string">"environment"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="lightcoral">註： 我這邊實測沒有強制使用前鏡頭的設定，只有後鏡頭是可以強制設定的！</font></p>
<h2 id="使用-getUserMedia-來調用攝像鏡頭-啟動及關閉"><a href="#使用-getUserMedia-來調用攝像鏡頭-啟動及關閉" class="headerlink" title="使用 getUserMedia 來調用攝像鏡頭(啟動及關閉)"></a>使用 getUserMedia 來調用攝像鏡頭(啟動及關閉)</h2><p>啟動攝像鏡頭的方法比較單純<br>至於關閉攝像鏡頭則會需要先記住 mediaStream<br>這邊是使用閉包的方式讓啟動和關閉相機的函式都可訪問這個變數<br>並在停用相機時清除 mediaStream 的引用和 video.srcObject 的位置<br>讓其在不被需要時可以被正確回收記憶體</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> onCamera = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> video = <span class="built_in">document</span>.querySelector(<span class="string">"video"</span>);</span><br><span class="line">  <span class="keyword">let</span> mediaStream;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 開啟攝像頭</span></span><br><span class="line">  <span class="keyword">const</span> startCamera = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      mediaStream = <span class="keyword">await</span> navigator.mediaDevices.getUserMedia(&#123;</span><br><span class="line">        video: &#123; <span class="attr">facingMode</span>: <span class="string">"environment"</span>, <span class="attr">width</span>: <span class="number">300</span> &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">      video.srcObject = mediaStream;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"GetUserMedia Error:"</span>, err.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 關閉攝像頭</span></span><br><span class="line">  <span class="keyword">const</span> stopCamera = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (mediaStream) &#123;</span><br><span class="line">      <span class="keyword">const</span> videoTracks = mediaStream.getVideoTracks();</span><br><span class="line">      videoTracks.forEach(<span class="function">(<span class="params">track</span>) =&gt;</span> track.stop());</span><br><span class="line">      <span class="comment">// 釋放資源</span></span><br><span class="line">      mediaStream = <span class="literal">null</span>;</span><br><span class="line">      video.srcObject = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; startCamera, stopCamera &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; startCamera, stopCamera &#125; = onCamera();</span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/08/04/調用攝像鏡頭/">https://davidblog.github.io/2023/08/04/調用攝像鏡頭/</a> </p>
]]></content>
      <categories>
        <category>技術文章</category>
      </categories>
  </entry>
  <entry>
    <title>部落格大翻新</title>
    <url>/2023/07/22/%E9%83%A8%E8%90%BD%E6%A0%BC%E5%A4%A7%E7%BF%BB%E6%96%B0/</url>
    <content><![CDATA[<p><img src="/images/blog/preview.png" alt="部落格大翻新"></p>
<p>心血來潮把部落格給大翻新<br>這邊記錄一下到底發生了哪些事情：</p>
<ul>
<li>更換頭像(Stable Diffusion)</li>
<li>更換三級域名(Github)</li>
<li>更新 Google 服務(Google Search Console / Google Analytics)</li>
<li>客製化部落格版面(Next Theme)</li>
<li>優化網站速度(PageSpeed Insights)</li>
</ul>
<a id="more"></a>

<h2 id="更換頭像-Stable-Diffusion"><a href="#更換頭像-Stable-Diffusion" class="headerlink" title="更換頭像(Stable Diffusion)"></a>更換頭像(Stable Diffusion)</h2><p>身為一個不擅長繪圖與缺凡設計專長的普通人<br>製作個人網頁時最麻煩之一就是圖片要去哪裡找才不會有版權問題</p>
<p>以前很常使用<a href="https://unsplash.com/" target="_blank" rel="noopener">unsplash</a>網站的圖片<br>因為它提供了<a href="https://unsplash.com/license" target="_blank" rel="noopener">免費的許可</a><br>不過這個網站很知名也有很多人使用<br>所以容易撞衫…</p>
<p>但最近不是很紅 AI 嗎！？<br>特別是 AI 繪圖 (AIGC/AI Generated Content)</p>
<p>稍微研究了一下<br>發現有滿多的工具<br>最主要的兩大巨頭 (AI 繪圖平台)：</p>
<ul>
<li>Midjourney</li>
<li>Stable Diffusion</li>
</ul>
<p>我使用的是 Stable Diffusion<br>Stable Diffusion 是一個開源人工智能圖像生成軟體<br>它有非常多的使用方式<br>可以在本地運行也可以選擇網路上的服務</p>
<p>本地運行的話可以參考這個庫</p>
<p><a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui" target="_blank" rel="noopener">stable-diffusion-webui by AUTOMATIC1111</a></p>
<p>網路上的話有所謂的 Play Ground<br>可以讓人體驗 但沒有太多的功能</p>
<p><a href="https://stablediffusionweb.com/" target="_blank" rel="noopener">stablediffusionweb</a></p>
<p>根據上面的個網站提供的資訊<br>基本上可以了解 AI 繪圖的版權相關問題是很複雜的<br>不過這個網站下方有提到</p>
<blockquote>
<p>What is the copyright on images created through Stable Diffusion Online?</p>
<p>Images created through Stable Diffusion Online are fully open source, explicitly falling under the CC0 1.0 Universal Public Domain Dedication.</p>
</blockquote>
<p>CC0 安心使用</p>
<p>太棒啦<br>也因為如此我就用 AI 新生成的圖像換成我部落格的大頭貼！<br>告別了<strong>山羊</strong> 迎來了<strong>企鵝</strong></p>
<img src="/uploads/avatar.jpeg" width="200" height="200" alt="企鵝" />

<h2 id="更換三級域名-Github"><a href="#更換三級域名-Github" class="headerlink" title="更換三級域名(Github)"></a>更換三級域名(Github)</h2><p>因為把部落格的頭像給換了<br>就想說把 Github 的頭像也給換一下<br>結果在編輯頁面意外發現可以更換三級域名!!!</p>
<p>試了一下 發現了一個很貼切我 blog 的域名！！！<br>那就是 davidblog （撒花）</p>
<p>於是我現在的網址就是 <a href="https://davidblog.github.io">https://davidblog.github.io</a></p>
<p>真是太讚了</p>
<h2 id="更新-Google-服務-Google-Search-Console-Google-Analytics"><a href="#更新-Google-服務-Google-Search-Console-Google-Analytics" class="headerlink" title="更新 Google 服務(Google Search Console / Google Analytics)"></a>更新 Google 服務(Google Search Console / Google Analytics)</h2><h3 id="Google-Search-Console"><a href="#Google-Search-Console" class="headerlink" title="Google Search Console"></a>Google Search Console</h3><p><a href="https://search.google.com/search-console/about" target="_blank" rel="noopener">Search Console</a>是一個 Google 的服務<br>可以讓人主動提交網站資訊<br>並藉此提升網站被搜尋的效率<br>基本上就是先驗證網站屬於本人持有<br>然後提交網站網址與網站地圖(sitemap)<br>過幾天之後就可以讓爬蟲建立索引<br>並讓自己的網站在 Google 裡面被搜尋到</p>
<p>基本上如果有自己的網域爬蟲也會自己去爬<br>可是網站像是放在 github page 上<br>爬蟲就不會去爬<br>所以可以使用 Google Search Console 來主動提交網站建立索引</p>
<p>如果要知道自己的網站有沒有被 Google 收錄<br>可以在網址列上輸入 site://你的網址<br>在看搜尋結果就可以知道網站有沒有被收錄</p>
<p>像是 David’s Blog 就可以輸入以下：</p>
<p><code>site://davidblog.github.io</code></p>
<h3 id="Google-Analytics"><a href="#Google-Analytics" class="headerlink" title="Google Analytics"></a>Google Analytics</h3><p>主要是 Google 的一個追蹤分析服務<br>可以了解使用者在網站上的行為和來訪的次數<br>其他的像是來訪地區和使用裝置</p>
<p>使用方法也很簡單<br>基本是就是申請服務<br>並將 GA 程式碼放入網站上即可</p>
<h2 id="客製化部落格版面-Next-Theme"><a href="#客製化部落格版面-Next-Theme" class="headerlink" title="客製化部落格版面(Next Theme)"></a>客製化部落格版面(Next Theme)</h2><p>其實改得不多<br>但改的很關鍵<br>至少讓整格部落格有煥然一新的感覺</p>
<ul>
<li>背景色改為暗色</li>
<li>文章容器圓角化</li>
<li>新增了打字機效果<a href="https://mattboldt.com/demos/typed-js/" target="_blank" rel="noopener">typed.js</a></li>
</ul>
<p>Next 主題其實滿貼心的<br>都有預留一些 custom 的資料夾或檔案位置<br>讓使用這個框架的開發人員進行客製化</p>
<p>CSS 可以參考這個路徑</p>
<p><code>themes/next/source/css/_custom</code></p>
<p>JS 可以參考這個路徑</p>
<p><code>themes/next/layout/_custom/script.swing</code></p>
<p>至於 HTML 的話比較麻煩一點<br>因為裡面的模板都是 swing 檔案<br>老實說 看不太習慣<br>但真的要改還是可以<br>就是花點時間看怎麼改</p>
<h2 id="優化網站速度-PageSpeed-Insights"><a href="#優化網站速度-PageSpeed-Insights" class="headerlink" title="優化網站速度(PageSpeed Insights)"></a>優化網站速度(PageSpeed Insights)</h2><p>直接先來看優化完成的成果吧！</p>
<p>首先是電腦板的：</p>
<p><img src="/images/blog/speed-pc.png" alt="Speed-PC"></p>
<p>然後是手機版的：</p>
<p><img src="/images/blog/speed-mobile.png" alt="Speed-PC"></p>
<p>總之<br>帥呆了</p>
<p>除了桌機版效能幾乎滿分（99 分）<br>手機版也有 80 幾分</p>
<p>那原本是多少呢<br>因為沒有截到圖<br>這邊只能給印象的答案<br>印象還沒改好之前<br>桌機效能只有 60 幾分<br>手機效能只有 30 幾分</p>
<p>所以到底改了什麼這麼關鍵<br>效能有辦法直線上升的這麼誇張</p>
<p>底下就先簡單註記<br>之後有時間再另外細細分享</p>
<ul>
<li><strong>壓縮產品代碼</strong></li>
<li><strong>關閉不必要的動畫效果</strong></li>
<li><strong>避免 head 中使用的腳本暫停 HTML 解析</strong></li>
</ul>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/07/22/部落格大翻新/">https://davidblog.github.io/2023/07/22/部落格大翻新/</a> </p>
]]></content>
      <categories>
        <category>部落格歷史</category>
      </categories>
  </entry>
  <entry>
    <title>序</title>
    <url>/2020/05/31/%E5%BA%8F/</url>
    <content><![CDATA[<p>此 Blog 正式啟用, 採用 Hexo 框架搭配 NexT 模板, 建置於 Github Page 於 2020年05月31日  </p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/05/31/序/">https://davidblog.github.io/2020/05/31/序/</a> </p>
]]></content>
      <categories>
        <category>部落格歷史</category>
      </categories>
  </entry>
</search>
