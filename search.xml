<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Babel JS編譯器</title>
    <url>/2020/06/21/babel/</url>
    <content><![CDATA[<p>JavaScript 的語法主要由 ECMA 組織所訂定<br>而語法上的支援則由各家瀏覽器來實作</p>
<p>Babel 是 JavsScript 的編譯器<br>可以用來將 ES5+ 的版本轉譯為兼容各瀏覽器可運行的語法</p>
<p>工作實務上則是為了能讓腳本兼容低階瀏覽器所造成的問題</p>
<p>本篇介紹 babel 的簡單使用方式</p>
<p>內文</p>
<ul>
<li>babel 相依套件</li>
<li>babel 基本安裝</li>
<li>babel 基本設定</li>
<li>babel 基本使用</li>
</ul>
<a id="more"></a>

<h1 id="babel-相依套件"><a href="#babel-相依套件" class="headerlink" title="babel 相依套件"></a>babel 相依套件</h1><br>

<ul>
<li>babel-core</li>
</ul>
<p>babel 的核心模組</p>
<ul>
<li>babel-loader</li>
</ul>
<p>提供 webpack 在讀取腳本時, 使用 baebl 讀取</p>
<ul>
<li>babel-preset-env</li>
</ul>
<p>為轉譯的預設<br>決定 babel 如何轉譯<br>如果沒有設定 preset<br>轉譯的代碼會原封不動的複製一份</p>
<ul>
<li>babel-cli</li>
</ul>
<p>能夠在 CLI 上直接使用 babel</p>
<ul>
<li>babel-polyfill</li>
</ul>
<p>babel 主要只提供語法轉換<br>像是新版的 API (Promise, Array.from, Object.assign …)<br>則需要此套件來協助處理</p>
<h1 id="babel-基本安裝"><a href="#babel-基本安裝" class="headerlink" title="babel 基本安裝"></a>babel 基本安裝</h1><br>

<p>本篇介紹最基本的使用<br>只需要安裝以下兩項套件即可</p>
<ul>
<li>babel-cli</li>
<li>babel-preset-env</li>
</ul>
<p><code>npm i -D babel-cli babel-preset-env</code></p>
<h1 id="babel-基本設定"><a href="#babel-基本設定" class="headerlink" title="babel 基本設定"></a>babel 基本設定</h1><br>

<p>有多種方式可以設定 babel<br>底下介紹常用的兩種方式(選其中一種即可):</p>
<p><strong>第一種</strong></p>
<p>在 <code>package.json</code> 內新增以下設定</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"babel": &#123;</span><br><span class="line">    "presets": ["env"]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二種</strong></p>
<p>在專案目錄下新增 <code>.babelrc</code> 檔案並作以下設定</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="babel-基本使用"><a href="#babel-基本使用" class="headerlink" title="babel 基本使用"></a>babel 基本使用</h1><br>

<p>有多種使用方式<br>底下介紹常用的兩種方式</p>
<p><strong>直接在 CLI 下指令</strong></p>
<p><code>npx babel &lt;檔案&gt; --out-dir &lt;資料夾&gt;</code></p>
<p>p.s. 如果加上參數 –presets=babel-preset-env 則可以不用設定另外設定 preset</p>
<p><strong>在 package.json 中設定指令後提供 CLI 使用</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "build": "babel &lt;檔案&gt; --out-dir &lt;資料夾&gt;"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p><code>npm run build</code></p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/21/babel/">https://davidblog.github.io/2020/06/21/babel/</a> </p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>es5</tag>
        <tag>es6</tag>
        <tag>complier</tag>
        <tag>javascript</tag>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title>部落格近3週年久違的更新</title>
    <url>/2023/05/20/blogHistory/</url>
    <content><![CDATA[<p>回憶起這個部落格只有在建立初起比較常使用<br>後續就默默的擺著  </p>
<p>幾乎所有應用只要一陣子沒更新就會出問題<br>這個部落格也不例外</p>
<p>底下就來講講這裡曾經發生過的事吧</p>
<a id="more"></a>

<h1 id="部落格的歷史"><a href="#部落格的歷史" class="headerlink" title="部落格的歷史"></a>部落格的歷史</h1><p>最初建立這個部落格<br>除了想記錄自己的學習歷程<br>也想留下一個類似作品集的東西  </p>
<p>不過沒有選擇作品集而是部落格<br>是因為部落格更務實<br>而且使用上更方便  </p>
<p>這個部落格始終是放在 github page 上的<br>但當初為了讓這個網站看起來更專業<br>就去 GoDaddy 租了個兩年的網域<br>然後用 CloudFlare 來做網站託管<br>這樣就有一個專門的網址可以連到我的網站<br>也可以在 google 上搜尋到這格部落格裡的文章</p>
<p>CloudFlare 除了可以免費託管網站<br>還提供了免費的CDN和SSL憑證相當不錯</p>
<p>印象中這個部落格有出現過幾次問題</p>
<h2 id="Hexo-選用的主題不再更新-而導致版面出問題"><a href="#Hexo-選用的主題不再更新-而導致版面出問題" class="headerlink" title="Hexo 選用的主題不再更新 而導致版面出問題"></a>Hexo 選用的主題不再更新 而導致版面出問題</h2><p>這個部落格是用 Hexo 這個框架來做的<br>裡面有提供很多很棒的版型稱為主體<br>我當初選了一個挺熱門的主體滿多工程師在用的<br>不過後續這個主題沒有更新<br>版面就出現一些奇怪的問題<br>後來上網查很多人都有遇到這個問題<br>幸運的是有找到他們提供解決的辦法<br>不過我有點忘記solution是直接換一個主體<br>還是根據原本的主題進行了局部的修改才把它搞好…<br>總之現在的版面是一個叫 next 的主題</p>
<h2 id="網域沒有續約-網址失效-導致網站無法正常訪問"><a href="#網域沒有續約-網址失效-導致網站無法正常訪問" class="headerlink" title="網域沒有續約 網址失效 導致網站無法正常訪問"></a>網域沒有續約 網址失效 導致網站無法正常訪問</h2><p>當初是把部落格設置在github page主頁<br>另外有設置CNAME及一些自動轉址的功能<br>例如你從github page進來也會直接換到我的網域<br>讓人看不出這個網站是放在github上面<br>不過網域沒有續約就要把CNAME和自動轉址的功能拿掉<br>這樣才能在github page上正常的讓人訪問</p>
<h2 id="google-搜尋引擎找不到部落格的文章了"><a href="#google-搜尋引擎找不到部落格的文章了" class="headerlink" title="google 搜尋引擎找不到部落格的文章了"></a>google 搜尋引擎找不到部落格的文章了</h2><p>最近有在研究一些關於 seo 的東西<br>有發現我的部落格在 google 引擎上已經找不到了<br>據我目前搜集的資訊了解<br>是因為 google 爬蟲不會特別去爬 github 上的 github page<br>可是可以用 google 提供的 search console 主動提供網站資訊<br>讓爬蟲建立網站索引<br>所以我就小小的更新了一下 Blog 順便發篇文<br>順利的話之後這裡的文章也可以在 google 上直接找到囉~</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/05/20/blogHistory/">https://davidblog.github.io/2023/05/20/blogHistory/</a> </p>
]]></content>
      <categories>
        <category>網站維護</category>
      </categories>
      <tags>
        <tag>部落格</tag>
        <tag>seo</tag>
        <tag>網站維護</tag>
      </tags>
  </entry>
  <entry>
    <title>Bookmarklet 書籤小程式</title>
    <url>/2020/05/31/bml/</url>
    <content><![CDATA[<p>javascript 在客戶端瀏覽器上, 除了console內可以執行外, 也可以在網址列URL上執行, 只需要將協定的部分改為 <code>javascript:</code> 即可, 如: <code>javascript: alert(&#39;Hello Bookmarklet&#39;)</code>, 之前在工作上會寫給一些非開發人員做產品上簡單的測試, 如在CMS後台添加測試資料, 或是在前後台快速登入並執行相關功能, 通常會把書籤程式寫進匿名函式並壓縮成一行, 然後存在 chrome 的書籤裡, 接下來只要在程式要執行的頁面點擊書籤就可以執行程式了</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/05/31/bml/">https://davidblog.github.io/2020/05/31/bml/</a> </p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>bookmarklet</tag>
        <tag>協定</tag>
      </tags>
  </entry>
  <entry>
    <title>React Debounce 去抖動</title>
    <url>/2020/09/26/debounce/</url>
    <content><![CDATA[<p>最近在 app 上寫一個簡單的欄位試算功能<br>有用到去抖動這個小技巧<br>和大家簡單分享一下</p>
<p>內文:</p>
<ul>
<li>Debounce</li>
</ul>
<a id="more"></a>

<h1 id="Debounce"><a href="#Debounce" class="headerlink" title="Debounce"></a>Debounce</h1><br>
去抖動這個技巧
主要是用在避免短時間內重複觸發事件而造成過多不必要的運算

<p>可以利用 useEffect 在原件卸載時 執行 return function 把計時器清除<br>在 update 元件時 重新設定計時器要執行的代碼<br>代碼可參考如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ... 省略 ...</span></span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = amount * rate;</span><br><span class="line">      setResultAmount(result);</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearTimeout(timer);</span><br><span class="line">  &#125;, [amount]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 省略 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/09/26/debounce/">https://davidblog.github.io/2020/09/26/debounce/</a> </p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>hooks</tag>
        <tag>debounce</tag>
      </tags>
  </entry>
  <entry>
    <title>Frontend 前端免費資源匯集（ㄧ）</title>
    <url>/2020/06/27/free-sources/</url>
    <content><![CDATA[<p>工程師不造輪胎 一個好的開始 就是直接站在巨人的肩膀上 這樣最快 最輕鬆 最開心!!!<br>所以這篇文章主要是彙整一些 優質 好用 而且<strong>免費</strong>的前端資源 感謝網路上巨人們的貢獻!!!</p>
<p>p.s. 很多資源可以免費使用在商業上 但需不需要 credit 作者 記得還是先看一下 license</p>
<p>內文</p>
<ul>
<li>圖片</li>
<li>模板</li>
<li>字型</li>
<li>API</li>
<li>CSS Animation</li>
</ul>
<a id="more"></a>

<h1 id="圖片"><a href="#圖片" class="headerlink" title="圖片"></a>圖片</h1><h2 id="Unsplash"><a href="#Unsplash" class="headerlink" title="Unsplash"></a><a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a></h2><p>以前這個網站所有提供的圖片都是 CC0<br>真正的免費 可以完全任意的使用 無需標明出處來源 是一個非常受到歡迎的圖庫</p>
<p>現在呢 許可改為 Unsplash 自己的許可 多了一些限制</p>
<ul>
<li>不能以 Unsplash 的圖片和 Unsplash 競爭</li>
<li>圖片在未經過大幅度修改下不能直接進行販售</li>
</ul>
<p>但依然是可以進行商業或非商業使用 也無需標明出處來源<br>重點是品質都有相當高得水準 直接拿個一張圖片放在網頁上當 banner<br>你的網頁就直接昇華到了下一個檔次</p>
<p>缺點是因為免費高品質 容易有撞衫的機會</p>
<br>

<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="TEMPLATED"><a href="#TEMPLATED" class="headerlink" title="TEMPLATED"></a><a href="https://templated.co/" target="_blank" rel="noopener">TEMPLATED</a></h2><p>裡面超過 800 種版型 每種版型都包含了完整的 HTML, CSS 甚至是 RWD<br>可以做為商業與個人使用 主要的許可是 CC-by 簡單來說只要在網站上著名出處就可以了<br>如在 footer 上寫 <code>Designed by &lt;出處&gt;</code></p>
<p>細部點進去看 還會發現有一些其實是 CC0 !!! 超級棒 !!!</p>
<br>

<h1 id="字型"><a href="#字型" class="headerlink" title="字型"></a>字型</h1><h2 id="Google-Fonts"><a href="#Google-Fonts" class="headerlink" title="Google Fonts"></a><a href="https://fonts.google.com/" target="_blank" rel="noopener">Google Fonts</a></h2><p>字型推薦 Google Fonts<br>主要的許可是 Open Font License<br>可以自由地使用在產品 專案 及商業上 限制是不能直接去賣這個字型</p>
<p>字型的使用上非常的便利<br>可以用 CDN 或是下載</p>
<p>通常在網頁加上字型的話 可以大幅度的提升網頁的質感</p>
<p>p.s. 如果網站地區是在大陸的話 要注意 CDN 可能會連不到 建議直接下載</p>
<br>

<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="public-apis"><a href="#public-apis" class="headerlink" title="public-apis"></a><a href="https://github.com/public-apis/public-apis" target="_blank" rel="noopener">public-apis</a></h2><p>在 github 上有厲害的人們 彙整了相當多的 API<br>詳細可以直接閱讀 README 的部分<br>上面註明了是否需要授權以及可不可以跨域使用 etc.<br>另外 API 的種類還有分門別類 非常的用心</p>
<p>如果前端應用需要一些動態資源 很適合來這邊尋找靈感</p>
<br>

<h1 id="CSS-Animation"><a href="#CSS-Animation" class="headerlink" title="CSS Animation"></a>CSS Animation</h1><h2 id="animate-style"><a href="#animate-style" class="headerlink" title="animate.style"></a><a href="https://animate.style/" target="_blank" rel="noopener">animate.style</a></h2><p>Animated.css 一個老牌的動畫 Library<br>不知道這個網站什麼時候改版了<br>一開始進去還有點認不出來<br>但看到熟悉的動畫效果馬上就認出來了<br>裡面提供非常多好用的 CSS Animation<br>許可為 MIT License</p>
<p>以前只能使用 CDN 現在也提供了 npm 的使用方法<br>這個庫可以非常方便的在網頁上套用現成好看的動畫效果</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/27/free-sources/">https://davidblog.github.io/2020/06/27/free-sources/</a> </p>
]]></content>
      <categories>
        <category>免費資源</category>
      </categories>
      <tags>
        <tag>free sources</tag>
        <tag>api</tag>
        <tag>images</tag>
        <tag>cc0</tag>
        <tag>font</tag>
        <tag>css</tag>
        <tag>animation</tag>
        <tag>template</tag>
      </tags>
  </entry>
  <entry>
    <title>如何擁有一個網站</title>
    <url>/2020/09/13/createWebsite/</url>
    <content><![CDATA[<p>將一個<code>網頁</code>放到一個<code>網頁空間</code><br>再用一個<code>網域</code>指向你的<code>網頁空間</code>即可<br>現在你有一個網站了,只要在瀏覽器的網址列輸入網址,人人都可以連到你的網站囉!</p>
<p>內文</p>
<ul>
<li>如何擁有網頁</li>
<li>如何擁有網域</li>
<li>如何擁有網頁空間</li>
</ul>
<a id="more"></a>

<h1 id="如何擁有網頁"><a href="#如何擁有網頁" class="headerlink" title="如何擁有網頁"></a>如何擁有網頁</h1><p>網頁會是一個副檔名為html的檔案,<br>裡面通常會包含樣式檔css, 與腳本檔案js,<br>這會是組成一個基本網頁的三元素,</p>
<p>我們可以參考 <a href="https://templated.co/" target="_blank" rel="noopener">templated</a> 這個網站<br>裡面提供了非常多的免費模板可供使用, 許可通常是使用模板時在footer附註來源即可,<br>下載下來的模板已經完成了這個部分, 所以基本上可以直接使用,</p>
<p>如何編輯呢,<br>基本上可以使用電腦內建的文字編輯器就可以囉,<br>如果想學習基本網頁的寫法或修改模板內容可以參考 <a href="https://www.w3schools.com/" target="_blank" rel="noopener">w3cschools</a><br>這個網站提供了很棒的入門教學</p>
<h1 id="如何擁有網域"><a href="#如何擁有網域" class="headerlink" title="如何擁有網域"></a>如何擁有網域</h1><p>網域是網站的最重要要素之一,<br>像是一個地址可以讓每個人知道到何處拜訪你,</p>
<p>通常我們會註冊一個頂級域名(如: .com, .io, .org, .tw etc.)<br>然後我們就擁有了這個域名底下的一個二級域名 如 myweb.com<br>這樣你就可以用這個域名來指向你的網站<br>當然你會擁有這個二級域名底下的所有三級域名及N及域名<br>而每個域名你都可以指向一個網站<br>所以當你註冊了一個域名 你可以提供給無數的網站使用XD</p>
<p>底下介紹一個免費的網域註冊網站及一個付費的網域註冊網站</p>
<ul>
<li><a href="https://freenom.com" target="_blank" rel="noopener">freenom</a></li>
<li><a href="https://godaddy.com/" target="_blank" rel="noopener">GoDaddy</a></li>
</ul>
<p>免費的網域可以用來簡單為小網站做測試或練習,<br>但不建議當作正式網站的網域,<br>因為有可能有隨時被停用的風險,<br>或是不能被一些網頁空間作為CNAME使用</p>
<h1 id="如何擁有網頁空間"><a href="#如何擁有網頁空間" class="headerlink" title="如何擁有網頁空間"></a>如何擁有網頁空間</h1><p>網頁空間基本上也分為免費及付費的, 靜態的和動態的<br>如果是靜態網站要使用的, 基本上就是一個網頁伺服器(html server), 相對單純</p>
<p>免費的網頁空間, 通常會有CANME的限制(能不能設定自己的網域), 及可能會有其他廣告的狀況<br>所以申請時需要特別留意此空間的規範是否符合自身的需求</p>
<p>這部分這搜尋引擎上可以找大量的結果<br>所以這邊就不一一介紹了</p>
<p>當然如果熟悉終端機使用的話<br>就可以使用 <a href="https://github.com" target="_blank" rel="noopener">Github</a><br>這個網站是很多工程師常用的代碼倉 裡面也提供 github page 可以用來呈現靜態網站</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/09/13/createWebsite/">https://davidblog.github.io/2020/09/13/createWebsite/</a> </p>
]]></content>
      <categories>
        <category>教學</category>
      </categories>
      <tags>
        <tag>free sources</tag>
        <tag>html</tag>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>hosts 主機表</title>
    <url>/2020/06/08/hosts/</url>
    <content><![CDATA[<p>A: 網址好像連不對地方!?<br>B: 你要不要檢查一下你的主機表..</p>
<p>內文:</p>
<ul>
<li>主機表介紹</li>
<li>檔案位置</li>
</ul>
<a id="more"></a>

<h1 id="hosts-主機表"><a href="#hosts-主機表" class="headerlink" title="hosts 主機表"></a>hosts 主機表</h1><h2 id="主機表介紹"><a href="#主機表介紹" class="headerlink" title="主機表介紹"></a>主機表介紹</h2><br>

<blockquote>
<p>這隻檔案其實就是本地的 DNS,<br>主要記載著 IP 與 Domain 的對應關係,<br>當輸入網址時就會根據 hosts 上的紀錄做解析,<br>當遇到本地沒有的紀錄時, 電腦才會上 DNS server 作詢問,</p>
</blockquote>
<p>雖然說這隻檔案現在很少會用到,<br>但有些專案在開發過程中,<br>還是會將內部網路的 IP 設定在主機表裡,<br>以便專案開發與測試</p>
<p>下面附註檔案位置, 有興趣的話可以打開來看看</p>
<h2 id="檔案位置"><a href="#檔案位置" class="headerlink" title="檔案位置"></a>檔案位置</h2><p><strong>Mac</strong>: <code>/private/etc/hosts</code></p>
<p>在 CLI 上輸入 <code>sudo vim /private/etc/hosts</code><br>就可以用 vim 編輯器打開來了</p>
<p>以下是我mac打開主機表的內容, 給大家參考一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##</span><br><span class="line"># Host Database</span><br><span class="line">#</span><br><span class="line"># localhost is used to configure the loopback interface</span><br><span class="line"># when the system is booting.  Do not change this entry.</span><br><span class="line">##</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">255.255.255.255 broadcasthost</span><br><span class="line">::1             localhost</span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/08/hosts/">https://davidblog.github.io/2020/06/08/hosts/</a> </p>
]]></content>
      <categories>
        <category>域名解析</category>
      </categories>
      <tags>
        <tag>dns</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title>Data URL vs Blob URL</title>
    <url>/2023/06/08/Data-URL-vs-Blob-URL/</url>
    <content><![CDATA[<p>網頁應用常見的資源網址除了http URL外,<br>還有Data URL及Blob URL:  </p>
<ul>
<li>Data URL (資料網址)</li>
<li>Blob URL (二進制大型物件網址)</li>
</ul>
<p>這兩種類型的網址，也很常用在資源下載及顯示<br>內文將介紹這兩種URL 的基本使用方法</p>
<a id="more"></a>

<h1 id="Data-URL-vs-Blob-URL"><a href="#Data-URL-vs-Blob-URL" class="headerlink" title="Data URL vs Blob URL"></a>Data URL vs Blob URL</h1><h2 id="Data-URL"><a href="#Data-URL" class="headerlink" title="Data URL"></a>Data URL</h2><p>Data URL 可以使資源以文本格式直接鑲嵌在HTML中使用<br>如常見的圖片以base64置入於img標籤的src內<br>也可以將其放入a標籤的href內供使用者下載</p>
<p>Data URL 的基本編碼格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data:[media type][;編碼格式],編碼</span><br></pre></td></tr></table></figure>
<p>圖片範例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data:image&#x2F;png;base64,[base64代碼]</span><br></pre></td></tr></table></figure>
<p>純文字範例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data:text&#x2F;plain;charset&#x3D;utf-8,[字串符]</span><br></pre></td></tr></table></figure>
<p>圖片資源加載範例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;data:image&#x2F;png;base64,[base64代碼]&quot; alt&#x3D;&quot;圖片描述&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>圖片資源下載範例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;data:image&#x2F;png;base64,[base64代碼]&quot; download&#x3D;&quot;檔案名稱&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Blob-URL"><a href="#Blob-URL" class="headerlink" title="Blob URL"></a>Blob URL</h2><p>Blob URL 可以生成一個暫時的網址<br>並將其資源暫放在瀏覽器的記憶體中  </p>
<p>創建Blob URL範例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const string &#x3D; &#39;Hello Blob URL&#39;;</span><br><span class="line">const file &#x3D; new Blob([string], &#123;type: text&#x2F;plain&#125;);</span><br><span class="line">const BlobURL &#x3D; URL.createObjectURL(file); &#x2F;&#x2F; 這個就是Blob URL</span><br></pre></td></tr></table></figure>
<p>使用Blob URL下載檔案的範例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const link &#x3D; document.createElement(&#39;a&#39;);</span><br><span class="line">link.href &#x3D; BlobURL;</span><br><span class="line">link.download &#x3D; &#39;檔案名稱&#39;;</span><br><span class="line">link.click();</span><br></pre></td></tr></table></figure>
<p>清除下載連結及釋放記憶體</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link.href &#x3D; &quot;&quot;;</span><br><span class="line">URL.revokeObjectURL(BlobURL);</span><br></pre></td></tr></table></figure>

<h2 id="附註常見的MIME類型-（Media-Type）"><a href="#附註常見的MIME類型-（Media-Type）" class="headerlink" title="附註常見的MIME類型 （Media Type）"></a>附註常見的MIME類型 （Media Type）</h2><table>
<thead>
<tr>
<th>MIME 類型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>text/plain</td>
<td>純文本檔案的 MIME 類型</td>
</tr>
<tr>
<td>text/html</td>
<td>HTML 檔案的 MIME 類型</td>
</tr>
<tr>
<td>text/css</td>
<td>CSS 檔案的 MIME 類型</td>
</tr>
<tr>
<td>text/markdown</td>
<td>Markdown 檔案的 MIME 類型</td>
</tr>
<tr>
<td>application/javascript</td>
<td>JavaScript 檔案的 MIME 類型</td>
</tr>
<tr>
<td>application/json</td>
<td>JSON 檔案的 MIME 類型</td>
</tr>
<tr>
<td>application/xml</td>
<td>XML 檔案的 MIME 類型</td>
</tr>
<tr>
<td>image/jpeg</td>
<td>JPEG 圖像檔案的 MIME 類型</td>
</tr>
<tr>
<td>image/png</td>
<td>PNG 圖像檔案的 MIME 類型</td>
</tr>
<tr>
<td>image/gif</td>
<td>GIF 圖像檔案的 MIME 類型</td>
</tr>
<tr>
<td>audio/mpeg</td>
<td>MPEG 音訊檔案的 MIME 類型</td>
</tr>
<tr>
<td>audio/wav</td>
<td>WAV 音訊檔案的 MIME 類型</td>
</tr>
<tr>
<td>video/mp4</td>
<td>MP4 視訊檔案的 MIME 類型</td>
</tr>
<tr>
<td>video/mpeg</td>
<td>MPEG 視訊檔案的 MIME 類型</td>
</tr>
<tr>
<td>application/pdf</td>
<td>PDF 檔案的 MIME 類型</td>
</tr>
<tr>
<td>application/zip</td>
<td>ZIP 壓縮檔案的 MIME 類型</td>
</tr>
</tbody></table>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/06/08/Data-URL-vs-Blob-URL/">https://davidblog.github.io/2023/06/08/Data-URL-vs-Blob-URL/</a> </p>
]]></content>
      <categories>
        <category>URL</category>
      </categories>
      <tags>
        <tag>Data URL</tag>
        <tag>Blob URL</tag>
        <tag>MIME</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX 動態資料串接</title>
    <url>/2020/06/20/ajax/</url>
    <content><![CDATA[<p>A: 這個是用 ajax 作的嗎<br>B: ajax 還是 $.ajax 呢</p>
<p>AJAX 可以說是前端最重要的技術沒有之一<br>主要功用是在不重刷頁面下作局部資料的動態更新</p>
<p>底下介紹常用的 ajax 技術</p>
<p>內文</p>
<ul>
<li>xhr</li>
<li>$.ajax</li>
<li>fetch</li>
<li>axios</li>
</ul>
<a id="more"></a>

<h1 id="xhr"><a href="#xhr" class="headerlink" title="xhr"></a>xhr</h1><br>

<p>xhr 是最古老的 Ajax 技術 現在已經很少使用<br>但如果是為了支援一些古老的版本的瀏覽器 可以稍微認識一下<br>先來看一下簡單的代碼範例<br>此範例用於 get 方法請求取得隨機狗狗圖片的 JSON 資料</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宣告請求成功和失敗的函式 (此函式為請求成功或失敗後的 callback)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reqOnload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.responseText);</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reqError</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 XMLHttpRequest 物件 (在 console 裡 type 此物件即可以見當前狀態所有屬性內容)</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 設定方法與 url</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"https://dog.ceo/api/breeds/image/random"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 送出</span></span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line">xhr.onload = reqOnload;</span><br><span class="line">xhr.onerror = reqError;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;message: "https://images.dog.ceo/breeds/groenendael/n02105056_4591.jpg", status: "success"&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>補充 (設定標頭)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">"token"</span>, <span class="string">"wefuni2hu43f9hr"</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json; charset=utf-8"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>補充 (post 方法下設定 payload)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.send(<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">key</span>: <span class="string">"value"</span> &#125;));</span><br></pre></td></tr></table></figure>

<h1 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax"></a>$.ajax</h1><br>

<p>此方法為 jQuery 所提供的 ajax 方法 實際上由 xhr 所封裝的<br>如果專案下以有引用此 library<br>則可以直接使用此方法<br>底下為代碼的部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建立 請求物件</span></span><br><span class="line"><span class="keyword">const</span> requestOptions = &#123;</span><br><span class="line">  url: <span class="string">"https://dog.ceo/api/breeds/image/random"</span>,</span><br><span class="line">  type: <span class="string">"get"</span>, <span class="comment">//</span></span><br><span class="line">  dataType: <span class="string">"json"</span>, <span class="comment">// server的回傳格式</span></span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 請求成功的callback</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 請求失敗的callback</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 送出請求</span></span><br><span class="line">$.ajax(requestOptions);</span><br></pre></td></tr></table></figure>

<p><strong>補充(post 方法的 payload)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">requestOptions.type = <span class="string">"post"</span>; <span class="comment">// 請求方法</span></span><br><span class="line">requestOptions.data = payload; <span class="comment">// payload</span></span><br></pre></td></tr></table></figure>

<h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><br>

<p>fetch 是一個 HTML5 的 API 會回傳一個 es6 的 promise 物件<br>如果是在主流瀏覽器的執行環境下是可以直接使用的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">"https://dog.ceo/api/breeds/image/random"</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> res.json())</span><br><span class="line">  .then(<span class="function">(<span class="params">json</span>) =&gt;</span> <span class="built_in">console</span>.log(json))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>

<p><strong>補充 (加入其他 options)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  method: <span class="string">"POST"</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    email: <span class="string">"xxx@mail.com"</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fetch(url, options)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> res.json())</span><br><span class="line">  .then(<span class="function">(<span class="params">json</span>) =&gt;</span> <span class="built_in">console</span>.log(json))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>

<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><br>

<p>一個非常流行的三方套件<br>支持瀏覽器中發送 XMLHttpRequests 與 Promise API<br>底下為參考的代碼範例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  method: <span class="string">"get"</span>,</span><br><span class="line">  url: <span class="string">"https://dog.ceo/api/breeds/image/random"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">axios.request(options);</span><br></pre></td></tr></table></figure>

<p><strong>補充 (post payload)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">options.method = <span class="string">"post"</span>;</span><br><span class="line">options.headers = &#123; <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span> &#125;;</span><br><span class="line">options.data = payload;</span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/20/ajax/">https://davidblog.github.io/2020/06/20/ajax/</a> </p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ajax</tag>
        <tag>jQuery</tag>
        <tag>axios</tag>
        <tag>xhr</tag>
        <tag>fetch</tag>
      </tags>
  </entry>
  <entry>
    <title>圖片預覽 (FileReader/Data URL)</title>
    <url>/2023/07/12/fileReader/</url>
    <content><![CDATA[<p>之前介紹過 <a href="https://davidblog.github.io/2023/06/08/Data-URL-vs-Blob-URL/#more">Data URL</a><br>而這篇文章將補充一個常見的應用場景：圖片預覽</p>
<a id="more"></a>

<p>先說明圖片預覽的主要流程</p>
<ul>
<li>根據 input 元素 來上傳圖片</li>
<li>根據 FileReader 物件來讀取圖片的 Data URL</li>
<li>根據 Data URL 將圖片顯示在畫面上</li>
</ul>
<p>底下代碼主要以 JSX 為範例：</p>
<h2 id="根據-input-元素-來上傳圖片"><a href="#根據-input-元素-來上傳圖片" class="headerlink" title="根據 input 元素 來上傳圖片"></a>根據 input 元素 來上傳圖片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;label htmlFor&#x3D;&quot;file-upload&quot;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          id&#x3D;&quot;file-upload&quot;</span><br><span class="line">          accept&#x3D;&quot;image&#x2F;*&quot;</span><br><span class="line">          multiple&#x3D;&#123;true&#125;</span><br><span class="line">          type&#x3D;&quot;file&quot;</span><br><span class="line">          style&#x3D;&#123;&#123; display: &quot;none&quot; &#125;&#125;</span><br><span class="line">          onChange&#x3D;&#123;(e) &#x3D;&gt; &#123;</span><br><span class="line">            handleFileInputChange(e);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">        &lt;span&gt;新增圖片&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;label&gt;</span><br></pre></td></tr></table></figure>

<p>這裡用了一個小技巧隱藏原本的 input 欄位<br>並以 label 的點擊來觸發 input 的點擊效果(for 屬性可以觸發相同 id)<br><strong>備註：JSX 的 for 屬性需要寫成 htmlFor</strong></p>
<p>當選取圖片上傳便會觸發 onChange</p>
<h2 id="根據-FileReader-物件來讀取圖片的-Data-URL"><a href="#根據-FileReader-物件來讀取圖片的-Data-URL" class="headerlink" title="根據 FileReader 物件來讀取圖片的 Data URL"></a>根據 FileReader 物件來讀取圖片的 Data URL</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function handleFileInputChange(event) &#123;</span><br><span class="line">  const files &#x3D; event.target.files;</span><br><span class="line">  const convertedImages &#x3D; [];</span><br><span class="line"></span><br><span class="line">  for (let i &#x3D; 0; i &lt; files.length; i++) &#123;</span><br><span class="line">    const file &#x3D; files[i];</span><br><span class="line">    const reader &#x3D; new FileReader();</span><br><span class="line"></span><br><span class="line">    reader.onload &#x3D; function (e) &#123;</span><br><span class="line">      const dataURL &#x3D; e.target.result;</span><br><span class="line">      convertedImages.push(dataURL);</span><br><span class="line"></span><br><span class="line">      if (convertedImages.length &#x3D;&#x3D;&#x3D; files.length) &#123;</span><br><span class="line">        setPhotoList(convertedImages);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上就是根據迴圈 搭配 FileReader 讀取每個檔案的 Data URL<br>並根據 setPhotoList 將轉換好的 URL 陣列放入 photoList 來重新渲染視圖<br><strong>如果有防呆邏輯也可以在這裡加上(如上傳圖片數量限制等等…)</strong></p>
<h2 id="根據-Data-URL-將圖片顯示在畫面上"><a href="#根據-Data-URL-將圖片顯示在畫面上" class="headerlink" title="根據 Data URL 將圖片顯示在畫面上"></a>根據 Data URL 將圖片顯示在畫面上</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;photoList.map((url, index) &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;img key&#x3D;&#123;index&#125; src&#x3D;&#123;url&#125; alt&#x3D;&quot;&quot; &#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;)&#125;</span><br></pre></td></tr></table></figure>

<p>最後一步很單純<br>在專案需要的地方將 photoList 給渲染出來就好了</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/07/12/fileReader/">https://davidblog.github.io/2023/07/12/fileReader/</a> </p>
]]></content>
      <categories>
        <category>URL</category>
      </categories>
      <tags>
        <tag>Data URL</tag>
        <tag>FileReader</tag>
      </tags>
  </entry>
  <entry>
    <title>PWA 偽裝術</title>
    <url>/2020/06/07/pwa2/</url>
    <content><![CDATA[<p>A: 你看我做了一個 APP!<br>B: 那是 WEB 好嗎?<br>A: 露餡了…</p>
<p>內文:</p>
<ul>
<li>隱藏 PWA 在手機上的縮放</li>
<li>隱藏跳出的 GOOGLE 翻譯</li>
<li>BONUS: 更新快取內容</li>
</ul>
<a id="more"></a>

<h1 id="PWA-偽裝術"><a href="#PWA-偽裝術" class="headerlink" title="PWA 偽裝術"></a>PWA 偽裝術</h1><br>

<blockquote>
<p>即便 PWA 可以安裝在手機上,<br>打開後沒有網址列,<br>但畢竟還是一個網頁,<br>故使用上會出現一些網頁的特有行為,<br>為了讓網頁在手機上的體驗更像原生 APP,<br>底下提供一些實用的小 tips</p>
</blockquote>
<h2 id="隱藏-PWA-在手機上的縮放"><a href="#隱藏-PWA-在手機上的縮放" class="headerlink" title="隱藏 PWA 在手機上的縮放"></a>隱藏 PWA 在手機上的縮放</h2><p>meta 標籤位於 html 檔的 head 標籤裡頭,<br>主要功能是記載著網頁內的相關資訊,<br>我們可以使用 meta viewport 來解決網頁可根據使用者自由縮放的問題,<br>只需要將底下代碼即可:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=no"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下來說明 content 屬性內容作用</p>
<ul>
<li><code>width=device-width</code>: 將畫面寬度設定為符合裝置畫面寬度</li>
<li><code>initial-scale=1</code>: 畫面初始的縮放比例</li>
<li><code>shrink-to-fit=no</code>:<br>針對 iOS9 畫面自適應寬度需要加上, 否則 Safari 在畫面上會發生 scale down (縮小)</li>
<li><code>user-scalable=no</code>: <font color="#ff0000">解決畫面可縮放問題</font></li>
</ul>
<h2 id="隱藏跳出的-GOOGLE-翻譯"><a href="#隱藏跳出的-GOOGLE-翻譯" class="headerlink" title="隱藏跳出的 GOOGLE 翻譯"></a>隱藏跳出的 GOOGLE 翻譯</h2><p>這個問題主要是針對 Android 會發生的,<br>如果網頁內是用到其他語言,<br>一樣利用 meta 標籤可以解決此問題,<br>這此我們所使用的是 meta google 這個標籤,<br>以下為代碼, 加上即可:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"google"</span> <span class="attr">content</span>=<span class="string">"notranslate"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>content 內容從字面上即可看出來是不用翻譯的意思</p>
<h2 id="BONUS-更新快取內容"><a href="#BONUS-更新快取內容" class="headerlink" title="BONUS: 更新快取內容"></a>BONUS: 更新快取內容</h2><p>首先需要先簡單講一下 service-worker 主要的幾個事件,</p>
<ul>
<li>register<blockquote>
<p>註冊 service-worker (sw)</p>
</blockquote>
</li>
<li>install<blockquote>
<p>當 sw 成功註冊後, 即會觸發此事件, 在背景執行安裝, 白話就是快取設定的內容</p>
</blockquote>
</li>
<li>active<blockquote>
<p>當完成安裝後, 即為啟動狀態, 這裡可以設定清除舊快取 (filter 快取名稱來 clean)</p>
</blockquote>
</li>
<li>fetch<blockquote>
<p>當在 sw scope 下發生任何請求都會觸發此事件, 並從快取中檢查是否已有相同項目</p>
</blockquote>
</li>
</ul>
<p>基本上 sw 在檢查所有快取上都是依照 CACHE NAME 來判定的,<br>而 CACHE NAME 基本上是我們一開始命名的字串變數,<br>所以要讓 PWA 自動更新, 最簡單快速的方法就是將 CACHE NAME 重新命名即可</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/07/pwa2/">https://davidblog.github.io/2020/06/07/pwa2/</a> </p>
]]></content>
      <categories>
        <category>PWA</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>PWA</tag>
        <tag>Progressive Web App</tag>
        <tag>service work</tag>
        <tag>manifest</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 如何重構代碼（一）</title>
    <url>/2020/06/15/refactor/</url>
    <content><![CDATA[<p>這個主題打算寫系列文<br>先簡單介紹三個 if else 的重構方法</p>
<p>內文</p>
<ul>
<li>更好的 if else 寫法 (三元運算子)</li>
<li>更好的 if else 寫法（return）</li>
<li>更好的 if else 寫法（物件）</li>
</ul>
<a id="more"></a>

<h1 id="更好的-if-else-三元運算子"><a href="#更好的-if-else-三元運算子" class="headerlink" title="更好的 if else (三元運算子)"></a>更好的 if else (三元運算子)</h1><h2 id="if-else-寫法"><a href="#if-else-寫法" class="headerlink" title="if else 寫法"></a>if else 寫法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (id === <span class="number">1</span>) &#123;</span><br><span class="line">  alert(<span class="string">"ID 是 1"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">"ID 不是 1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三元運算子"><a href="#三元運算子" class="headerlink" title="三元運算子"></a>三元運算子</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">id === <span class="number">1</span> ? alert(<span class="string">"ID 是 1"</span>) : alert(<span class="string">"ID 不是 1"</span>);</span><br></pre></td></tr></table></figure>

<h1 id="更好的-if-else（return-寫法）"><a href="#更好的-if-else（return-寫法）" class="headerlink" title="更好的 if else（return 寫法）"></a>更好的 if else（return 寫法）</h1><h2 id="if-else-寫法-1"><a href="#if-else-寫法-1" class="headerlink" title="if else 寫法"></a>if else 寫法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (id === <span class="number">1</span>) &#123;</span><br><span class="line">  alert(<span class="string">"ID 是 1"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (id === <span class="number">2</span>) &#123;</span><br><span class="line">  alert(<span class="string">"ID 是 2"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (id === <span class="number">3</span>) &#123;</span><br><span class="line">  alert(<span class="string">"ID 是 3"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">"ID 不是 1, 2, 3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="retrun"><a href="#retrun" class="headerlink" title="retrun"></a>retrun</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (id === <span class="number">1</span>) <span class="keyword">return</span> alert(<span class="string">"ID 是 1"</span>);</span><br><span class="line">  <span class="keyword">if</span> (id === <span class="number">2</span>) <span class="keyword">return</span> alert(<span class="string">"ID 是 2"</span>);</span><br><span class="line">  <span class="keyword">if</span> (id === <span class="number">3</span>) <span class="keyword">return</span> alert(<span class="string">"ID 是 3"</span>);</span><br><span class="line">  <span class="keyword">return</span> alert(<span class="string">"ID 不是 1, 2, 3"</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h1 id="更好的-if-else（物件寫法）"><a href="#更好的-if-else（物件寫法）" class="headerlink" title="更好的 if else（物件寫法）"></a>更好的 if else（物件寫法）</h1><h2 id="if-else-寫法-2"><a href="#if-else-寫法-2" class="headerlink" title="if else 寫法"></a>if else 寫法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (id === <span class="number">1</span>) &#123;</span><br><span class="line">  alert(<span class="string">"ID 是 1"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (id === <span class="number">2</span>) &#123;</span><br><span class="line">  alert(<span class="string">"ID 是 2"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (id === <span class="number">3</span>) &#123;</span><br><span class="line">  alert(<span class="string">"ID 是 3"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">"ID 不是 1, 2, 3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="物件"><a href="#物件" class="headerlink" title="物件"></a>物件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"ID 不是 1, 2, 3"</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">"ID 是 1"</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">"ID 是 2"</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">"ID 是 3"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> selectedID = obj[id] || obj[<span class="number">0</span>];</span><br><span class="line">alert(selectedID);</span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/15/refactor/">https://davidblog.github.io/2020/06/15/refactor/</a> </p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>refactor</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 Nginx 上面部署 React App</title>
    <url>/2023/07/11/nginx/</url>
    <content><![CDATA[<p>Nginx 是常見的網頁伺服器<br>預設的情況下會將客戶端的所有請求轉發到後端的真實路徑<br>部署多頁式的網頁應用並沒有什麼問題 但是如果是單頁式應用呢</p>
<p>React 是典型的單頁式應用 SPA (Single App Application)<br>React Router 提供多種類型的路由 如 BrowserRouter, HashRouter, MemoryRouter etc.<br>其中 React Router 官方最推薦的 Router 就是 <a href="https://reactrouter.com/en/main/routers/create-browser-router" target="_blank" rel="noopener">BrowserRouter</a></p>
<p>BrowserRouter 會根據每次路徑的變化都和後端發送請求</p>
<p>但實際上 React 只會有一個 index.html 位於 Nginx 的網站根目錄<br>此時如果 Nginx 嘗試將每個前端路由的的請求都轉發到後端的真實路徑<br>就會因為找不到實際的檔案可以回傳 而發生 404 Not Found</p>
<p>底下就來說明如何解決這個問題</p>
<a id="more"></a>

<p>首先 要先打開 Nginx 的配置檔案<br>預設位置為 /etc/nginx/conf.d/default.conf<br>內容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    listen  [::]:80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要將 try_files 加入 location / 下<br>代碼如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    listen  [::]:80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        # url 切換時始终返回index.html</span><br><span class="line">        try_files $uri &#x2F;index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時你在馬上打開網站<br>你會發先還是 404 Not Found</p>
<p>記得當修改完配置要在執行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<p>這樣才能重新讀取並套用新的配置<br>然後在開網站 就正常囉～</p>
<p>另外如果發現 React 有些頁面抓不到靜態資源<br>可以檢查專案下的 package.json<br>並確認 homepage 設定是否正確<br>如果專案是部署在網站根目錄下 設定如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;homepage&quot;: &quot;&#x2F;&quot;</span><br></pre></td></tr></table></figure>

<p>以上就是將 React App 部署在 Nginx 網頁伺服器的方法哩</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/07/11/nginx/">https://davidblog.github.io/2023/07/11/nginx/</a> </p>
]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>deploy</tag>
        <tag>nginx</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title>前端路由之導航狀態 (React Hook - useNavigate)</title>
    <url>/2023/07/12/navigate/</url>
    <content><![CDATA[<p>導航狀態常用於頁面間的資料傳遞<br>特別適合單向的數據傳遞(只管數據帶到下一頁,不管帶回上一頁)<br>使用上直觀且簡單<br>另外現代瀏覽器多半有緩存機制可以保存各頁面的狀態<br>即便客戶端進行 Reload, 或點擊上下頁依然可以保存狀態</p>
<p>應用上像是商品目錄頁進到商品內頁<br>可以藉由導航狀態先將部分資訊帶入內頁渲染<br>剩餘的資訊再藉由動態請求補齊<br>可以有效提升使用者體驗</p>
<p>底下以 React Router v6 為例<br>來說明導航狀態的實際應用</p>
<a id="more"></a>

<p>這是一個頁面級別的元件代碼範例<br>包含接收來自上一頁的 state<br>和將 state 帶入新頁面的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Page &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const navigate &#x3D; useNavigate();</span><br><span class="line">  const location &#x3D; useLocation();</span><br><span class="line">  const &#123; state &#125; &#x3D; location;</span><br><span class="line">  const [viewModel, setViewModel] &#x3D; useState(state || &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  const onNextPageClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const state &#x3D; &#123; data: &#39;example&#39; &#125;;</span><br><span class="line">    navigate(&quot;頁面路徑&quot;, &#123; state &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const fetchPageData &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">       const res &#x3D; await fetch(&quot;url&quot;);</span><br><span class="line">       const json &#x3D; await res.json();</span><br><span class="line">       const &#123; data &#125; &#x3D; json;</span><br><span class="line">       setViewModel(p &#x3D;&gt; (&#123;...p, ...data&#125;))</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">       console.log(err.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    fetchPageData()</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  return (頁面JSX代碼);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>從上面的代碼可以看到導航狀態來自於 location 的 state<br>可將其作為 viewModel 的預設值 之後主要用來更新視圖<br>當元件掛載完成後 便會觸發 fetchPageData 進行動態數據請求和視圖更新</p>
<p>如果需要將狀態帶入新頁面 則可以參考 onNextPageClick 函式</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/07/12/navigate/">https://davidblog.github.io/2023/07/12/navigate/</a> </p>
]]></content>
      <categories>
        <category>state</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>router</tag>
        <tag>hook</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 實用的小技巧（一）</title>
    <url>/2020/06/13/js-tips/</url>
    <content><![CDATA[<p>這個主題打算寫系列文章<br>主要是記錄 javascript 一些實用的小技巧</p>
<p>內文</p>
<ul>
<li>取數字千分位</li>
<li>建立時間戳記</li>
<li>將字串轉為數字</li>
<li>數字加總</li>
<li>去除陣列重複項目</li>
<li>科學計數法</li>
<li>陣列內項目隨機交換</li>
<li>處理貨幣單位</li>
<li>取得陣列中最大值與最小值</li>
<li>建立連續數字陣列</li>
</ul>
<a id="more"></a>

<p><strong>JavaScript 十個實用的小技巧（一）</strong></p>
<h1 id="取數字千分位"><a href="#取數字千分位" class="headerlink" title="取數字千分位"></a>取數字千分位</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> number = <span class="number">1000000</span>;</span><br><span class="line">number.toLocaleString();</span><br><span class="line"><span class="comment">// "1,000,000"</span></span><br></pre></td></tr></table></figure>

<h1 id="建立時間戳記"><a href="#建立時間戳記" class="headerlink" title="建立時間戳記"></a>建立時間戳記</h1><p>常用時間戳記為至今距離 1970年 1 月 1 日 的毫秒數<br>為什麼是 1970年 1 月 1 日<br>根據維基百科說明: 1970 年 為 Unix 紀元<br>也就是紀念 Unix 誕生的元年 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// 1592030768175</span></span><br></pre></td></tr></table></figure>

<h1 id="將字串轉為數字"><a href="#將字串轉為數字" class="headerlink" title="將字串轉為數字"></a>將字串轉為數字</h1><p>提供一個比 parseInt 更簡潔的寫法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">"1000000"</span>;</span><br><span class="line">+string;</span><br><span class="line"><span class="comment">// 1000000</span></span><br></pre></td></tr></table></figure>

<h1 id="數字加總"><a href="#數字加總" class="headerlink" title="數字加總"></a>數字加總</h1><p>寫法一</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="built_in">eval</span>(array.join(<span class="string">"+"</span>));</span><br><span class="line"><span class="comment">// 55</span></span><br></pre></td></tr></table></figure>

<p>寫法二</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">array.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// 55</span></span><br></pre></td></tr></table></figure>

<h1 id="去除陣列重複項目"><a href="#去除陣列重複項目" class="headerlink" title="去除陣列重複項目"></a>去除陣列重複項目</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"banana"</span>, <span class="string">"apple"</span>, <span class="string">"banana"</span>];</span><br><span class="line">[...new <span class="built_in">Set</span>(array)];</span><br><span class="line"><span class="comment">// ["apple", "banana"]</span></span><br></pre></td></tr></table></figure>

<h1 id="科學計數法"><a href="#科學計數法" class="headerlink" title="科學計數法"></a>科學計數法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1e6</span>;</span><br><span class="line"><span class="comment">// 1000000</span></span><br></pre></td></tr></table></figure>

<h1 id="陣列內項目隨機交換"><a href="#陣列內項目隨機交換" class="headerlink" title="陣列內項目隨機交換"></a>陣列內項目隨機交換</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">array.sort(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br><span class="line"><span class="comment">// [3, 7, 9, 4, 2, 5, 6, 8, 10, 1]</span></span><br></pre></td></tr></table></figure>

<h1 id="處理貨幣單位"><a href="#處理貨幣單位" class="headerlink" title="處理貨幣單位"></a>處理貨幣單位</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">1e6</span>).toLocaleString(<span class="string">"zh-tw"</span>, &#123; <span class="attr">style</span>: <span class="string">"currency"</span>, <span class="attr">currency</span>: <span class="string">"TWD"</span> &#125;);</span><br><span class="line"><span class="comment">// "$1,000,000.00"</span></span><br></pre></td></tr></table></figure>

<h1 id="取得陣列中最大值與最小值"><a href="#取得陣列中最大值與最小值" class="headerlink" title="取得陣列中最大值與最小值"></a>取得陣列中最大值與最小值</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="built_in">Math</span>.max(...array);</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">Math</span>.min(...array);</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h1 id="建立連續數字陣列"><a href="#建立連續數字陣列" class="headerlink" title="建立連續數字陣列"></a>建立連續數字陣列</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="number">10</span>)</span><br><span class="line">  .fill()</span><br><span class="line">  .map(<span class="function">(<span class="params">i, id</span>) =&gt;</span> id + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/13/js-tips/">https://davidblog.github.io/2020/06/13/js-tips/</a> </p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell Script 程式化指令碼</title>
    <url>/2020/05/31/sh/</url>
    <content><![CDATA[<p>在一些架構較大的專案中, 會時常使用到 <code>command line</code> 來執行相關的指令, 如: 啟動開發伺服器, 打包檔案, 部署檔案 etc. 通常會將單一功能的命令寫在 <code>package.json</code> 內的 <code>scripts</code> 裡, 但如果一次需要執行的命令不只一條, 其實可以將相關指令寫成腳本(.sh)放在專案根目錄下, 往後只要執行這隻檔案, 就可以按照腳本順序來執行一連串的相關指令, 以達到程式自動化的效果, 優點是減少重複行為並下錯指令的可能性</p>
<p>另外建立的腳本檔案會需要修改權限才能執行<br>以下備註檔案修改權限的方法:</p>
<a id="more"></a>

<h1 id="將檔案執行權限打開"><a href="#將檔案執行權限打開" class="headerlink" title="將檔案執行權限打開"></a>將檔案執行權限打開</h1><p><strong><code>chmod 777 文件名</code></strong></p>
<ul>
<li><h2 id="chmod-為修改文件權限的指令"><a href="#chmod-為修改文件權限的指令" class="headerlink" title="chmod 為修改文件權限的指令"></a>chmod 為修改文件權限的指令</h2></li>
<li><h2 id="第一個參數為操作文件的用戶權限"><a href="#第一個參數為操作文件的用戶權限" class="headerlink" title="第一個參數為操作文件的用戶權限"></a>第一個參數為操作文件的用戶權限</h2><p>三個數字分別代表:</p>
<blockquote>
<p>文件所有用戶<br>群組用戶<br>其他用戶</p>
</blockquote>
<p>每一個數字表示該用戶的權限:</p>
<blockquote>
<p>r: 讀取權限 (4)<br>w: 撰寫權限 (2)<br>x: 執行權限 (1)</p>
<blockquote>
<p>e.g. r(4)+w(2)+x(1) = rwx(7)</p>
</blockquote>
</blockquote>
</li>
<li><h2 id="第二個參數表示欲修改權限的檔案"><a href="#第二個參數表示欲修改權限的檔案" class="headerlink" title="第二個參數表示欲修改權限的檔案"></a>第二個參數表示欲修改權限的檔案</h2></li>
</ul>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/05/31/sh/">https://davidblog.github.io/2020/05/31/sh/</a> </p>
]]></content>
      <categories>
        <category>自動化</category>
      </categories>
      <tags>
        <tag>shell script</tag>
        <tag>linux</tag>
        <tag>command line</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 實用的小技巧（二）</title>
    <url>/2020/07/04/tips2/</url>
    <content><![CDATA[<p>耶 第二彈 !!</p>
<p>內文</p>
<ul>
<li>取連續陣列 方法一</li>
<li>取連續陣列 方法二</li>
<li>log 開關</li>
<li>undefined 簡寫</li>
<li>取外部 IP</li>
</ul>
<a id="more"></a>

<h1 id="取連續陣列-方法一"><a href="#取連續陣列-方法一" class="headerlink" title="取連續陣列 方法一"></a>取連續陣列 方法一</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...Array(<span class="number">10</span>).keys()];</span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>

<h1 id="取連續陣列-方法二"><a href="#取連續陣列-方法二" class="headerlink" title="取連續陣列 方法二"></a>取連續陣列 方法二</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="built_in">Array</span>(<span class="number">10</span>), (item, id) =&gt; id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>

<h1 id="log-開關"><a href="#log-開關" class="headerlink" title="log 開關"></a>log 開關</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ifDebug = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> oldLog = <span class="built_in">console</span>.log;</span><br><span class="line"><span class="built_in">console</span>.log = <span class="function"><span class="params">()</span> =&gt;</span> ifDebug &amp;&amp; oldLog.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>

<h1 id="undefined-簡寫"><a href="#undefined-簡寫" class="headerlink" title="undefined 簡寫"></a>undefined 簡寫</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>undefined 不是保留字 可以重新被賦值<br>故用 void 0 來取代 undefined 會更嚴謹</p>
<p>void 後面接任何代碼都會執行 但只回 undefined</p>
<h1 id="取外部-IP"><a href="#取外部-IP" class="headerlink" title="取外部 IP"></a>取外部 IP</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">"https://api.ipify.org?format=json"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>補充</strong></p>
<p>終端機取法 (Mac OS)</p>
<p>外部 IP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl ifconfig.me</span><br></pre></td></tr></table></figure>

<p>內部 IP </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<p><strong>內部 ip 會寫在 en0 那邊</strong></p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/07/04/tips2/">https://davidblog.github.io/2020/07/04/tips2/</a> </p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 古老編輯器的簡明使用方法</title>
    <url>/2020/06/13/vim/</url>
    <content><![CDATA[<p>A: 這裡是哪裡???為什麼進得去出不來?!<br>B: <code>:q</code><br>A: 那我每次都 <code>:q</code> 可以嗎?<br>B: 恩… 也是可以…</p>
<p>內文</p>
<ul>
<li>基本操作</li>
</ul>
<a id="more"></a>

<h1 id="Vim-古老編輯器的簡明使用方法"><a href="#Vim-古老編輯器的簡明使用方法" class="headerlink" title="Vim 古老編輯器的簡明使用方法"></a>Vim 古老編輯器的簡明使用方法</h1><br>

<blockquote>
<p>如果你有使用 git 的話<br>你一定見過 vim<br>像是 merge 別人的分支<br>或是 commit 的時候</p>
</blockquote>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>以下介紹:</p>
<h3 id="如何使用-vim-開啟文檔"><a href="#如何使用-vim-開啟文檔" class="headerlink" title="如何使用 vim 開啟文檔"></a>如何使用 vim 開啟文檔</h3><p>使用 vim 開啟文檔的方法非常簡單,<br>只需要在 CLI 上輸入以下指令即可:</p>
<p><code>vim /&lt;path&gt;/&lt;file&gt;</code></p>
<p>for instance:</p>
<p>打開所在目錄下 file.txt 文檔</p>
<p><code>vim file.txt</code></p>
<h3 id="模式切換與編輯文件"><a href="#模式切換與編輯文件" class="headerlink" title="模式切換與編輯文件"></a>模式切換與編輯文件</h3><p>一開始進入 vim 編輯器的時候為<strong>普通模式</strong><br>在任何模式下按<code>esc</code>皆可以退至<strong>普通模式</strong></p>
<p>在<strong>普通模式</strong>按下<code>i</code>可以進入<strong>插入模式</strong><br>此模式可以開始進行文檔上的編輯</p>
<p>在<strong>普通模式</strong>下按下 <code>:</code> 可以進入<strong>指令模式</strong><br>此模式可以退出文檔</p>
<h3 id="編輯器離開方式"><a href="#編輯器離開方式" class="headerlink" title="編輯器離開方式"></a>編輯器離開方式</h3><p>離開前必須進入指令模式<br>相關指令如下:</p>
<ul>
<li><code>q</code> : 離開編輯器</li>
<li><code>q!</code> : 不存檔強制離開編輯器</li>
<li><code>w</code> : 存檔</li>
<li><code>wq</code> : 存檔離開編輯器</li>
</ul>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/13/vim/">https://davidblog.github.io/2020/06/13/vim/</a> </p>
]]></content>
      <categories>
        <category>編輯器</category>
      </categories>
      <tags>
        <tag>編輯器</tag>
        <tag>vim</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>序</title>
    <url>/2020/05/31/%E5%BA%8F/</url>
    <content><![CDATA[<p>此 Blog 正式啟用, 採用 Hexo 框架搭配 NexT 模板, 建置於 Github Page 於 2020年05月31日  </p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/05/31/序/">https://davidblog.github.io/2020/05/31/序/</a> </p>
]]></content>
  </entry>
  <entry>
    <title>WebView 內崁式瀏覽器</title>
    <url>/2020/06/25/webview/</url>
    <content><![CDATA[<p>前兩週有遇到 webview 的問題 還沒來得及紀錄一下<br>(其實一直以來都有遇到各式各樣的坑… 隕石坑…)</p>
<p>內文就先來簡單介紹一下 webview 是什麼</p>
<p>內文</p>
<ul>
<li>webview 介紹</li>
<li>webview 版本</li>
<li>webview 如何除錯</li>
</ul>
<a id="more"></a>

<h1 id="webview-介紹"><a href="#webview-介紹" class="headerlink" title="webview 介紹"></a>webview 介紹</h1><br>

<p>webview 主要應用在手機上作為內崁瀏覽器<br>以便在使用任何 APP 點開外連網址時可以不用跳出去<br>優點是使用 APP 的驗感佳 缺點是外連網站的體驗感不佳 XD<br>因為 webview 使用的瀏覽器往往不是主流瀏覽器 所以語法支持上較差…</p>
<p>底下先筆記重點:</p>
<ul>
<li>webview 不是手機上默認的瀏覽器</li>
<li>webview 不是手機上自帶的瀏覽器</li>
</ul>
<p><strong>webview 是手機上的系統瀏覽器</strong></p>
<h1 id="webview-版本"><a href="#webview-版本" class="headerlink" title="webview 版本"></a>webview 版本</h1><br>

<p>在對 webview 有了基本的認識以後 接下來要談到如何分別版本<br>分辨版本對於 webview 除錯有相當大的幫助</p>
<p>先講重點:</p>
<p><strong>Android 和 iOS 是不一樣的路線</strong></p>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>Android 在 Android 5 以後 webview 從核心系統裡獨立出來<br>一般手機可能可以在: 設定 -&gt; 應用程式 -&gt; 全部 -&gt; 裡面找到 <code>Android System WebView</code><br>(實際上要看你手機是哪一個牌子… 才能知道他在哪裏 XD)</p>
<p><code>Android System WebView</code> 就是 Android 的系統瀏覽器啦<br>主要是跟隨 Chrome 的核心技術 用的是基於 Chromium 的瀏覽器 (google 下開源的項目)<br>點開此應用就可以看到版本了 但是版本前顯示的不一定是 Chromium/googel/chrome 相關字樣<br>而是顯示 package name , 此 package name 和廠商訂定有關<br>如需升級版本也需要找到對應 package name 的更高版本才行</p>
<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><p>單純很多</p>
<ul>
<li>iOS2 ~ iOS7 : UIWebView</li>
<li>iOS8+ : WKWebView</li>
</ul>
<p>如果本地開 Server 讓手機打開 webview 連線<br>其實從終端機其實就可以看到設備的瀏覽器版本資訊了<br>顯示的內容就和平常瀏覽器讀取<code>navigator.userAgent</code> 是一樣的</p>
<p>底下 iPhone 上示範</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Mozilla&#x2F;5.0 (iPhone; CPU iPhone OS 13_5_1 like Mac OS X) AppleWebKit&#x2F;605.1.15 (KHTML, like Gecko) Version&#x2F;13.1.1 Mobile&#x2F;15E148 Safari&#x2F;604.1&quot;</span><br></pre></td></tr></table></figure>

<p>底下 Chrome 上示範</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;83.0.4103.106 Safari&#x2F;537.36&quot;</span><br></pre></td></tr></table></figure>

<p>在這邊 Andorid 和 iOS 都是一樣的<br>不難看出使用者的設備與使用的瀏覽器版本</p>
<h1 id="webview-如何除錯"><a href="#webview-如何除錯" class="headerlink" title="webview 如何除錯"></a>webview 如何除錯</h1><br>

<p>這個答案要看 webview 連到哪邊</p>
<p>如果是連到三方有問題 就是三方的問題 請相關人士去處理 XD</p>
<p>如果連到的網站屬於需要自行維護範圍內的網站 就得自行處理 Orz..</p>
<p>可以先在 APP 端將 webview 連到 localhost 打包成 apk / ipa 另訂版本號<br>或直接使用 adb 連手機安裝應用</p>
<p>接下來連本地 Server 查看對應的 webview 版本<br>確認版本後 就可以上網找到對應的版本下載<br>然後開始在本地 console 除錯</p>
<p>通常就是 ES 版本問題, polyfill 加上的墊片不夠或沒有加到關鍵的墊片 XD</p>
<p>最後用手機 webview 連 localhost 做最後的結果確認<br>沒問題就可以把 webview 線上的網址給改回去了 (撒花)</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/25/webview/">https://davidblog.github.io/2020/06/25/webview/</a> </p>
]]></content>
      <categories>
        <category>瀏覽器</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>webview</tag>
        <tag>app</tag>
        <tag>react native</tag>
        <tag>android</tag>
        <tag>ios</tag>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title>Wget 強大的檔案下載工具</title>
    <url>/2020/06/26/wget/</url>
    <content><![CDATA[<p>最近有一個需求 需要把瀏覽的整個網站給抓下來</p>
<p>在瀏覽器上打開開發人員工具 點選 Sources<br>你可以看到 Server 下面 滿滿的資料夾與各種靜態資源</p>
<p>但怎麼抓呢 那就是用… <strong>Wget</strong></p>
<p>內文</p>
<ul>
<li>Wget 介紹</li>
<li>如何安裝 Wget</li>
<li>如何使用 Wget</li>
</ul>
<a id="more"></a>

<h1 id="Wget-介紹"><a href="#Wget-介紹" class="headerlink" title="Wget 介紹"></a>Wget 介紹</h1><br>

<p>Wget 全名 : <strong>World Wide Web Get</strong></p>
<p>在 Linux 作業系統上為內建的指令之一<br>是一個功能非常強大的檔案自動下載工具<br>雖然你知道 curl 也可以用來下載檔案<br>但有別於 curl 的地方在於 Wget 可以進行遞迴下載<br>所以特別適合抓取整個網站 以取得所有目錄及其檔案</p>
<p>但 Mac 本身並未預設安裝此工具<br>所以如需使用需要另行安裝</p>
<p>底下介紹安裝方式</p>
<h1 id="如何安裝-Wget"><a href="#如何安裝-Wget" class="headerlink" title="如何安裝 Wget"></a>如何安裝 Wget</h1><br>

<p>首先 安裝 MacOS 的套件管理工具 <a href="https://brew.sh/index_zh-tw" target="_blank" rel="noopener">Homebrew</a></p>
<p>安裝方式 CLI 輸入以下指令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;bash -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure>

<p>Homebrew 是什麼呢<br>如官網所提的 他就是 <strong>macOS 缺少套件的管理工具</strong></p>
<p>你可以使用這個套件管理工具來安裝您 Mac 所需要用到的軟體<br>如 google chrome, adobe, nvm, 當然包括 <strong>Wget</strong> etc.</p>
<ul>
<li>確認你想安裝的軟體</li>
</ul>
<p><code>brew search wget</code></p>
<ul>
<li>安裝 Wget</li>
</ul>
<p><code>brew install wget</code></p>
<p>OK 這樣就安裝完成了</p>
<p>最後來說明使用 Wget 的方式</p>
<h1 id="如何使用-Wget"><a href="#如何使用-Wget" class="headerlink" title="如何使用 Wget"></a>如何使用 Wget</h1><br>

<p>Wget 的用法如下</p>
<p><code>wget &lt;Options&gt; &lt;URL&gt;</code></p>
<p>假設我要抓取 google 的網站到桌面</p>
<p>那我就分別輸入以下指令</p>
<p><code>cd ~/Desktop</code></p>
<p><code>wget -r www.google.com</code></p>
<p>最後介紹常用的參數</p>
<ul>
<li>-r (-recursive) : 用來表示遞迴下載</li>
<li>-np (–no-parent) : 用來表示不向上遞迴下載</li>
</ul>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/26/wget/">https://davidblog.github.io/2020/06/26/wget/</a> </p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>brew</tag>
        <tag>homebrew</tag>
        <tag>wget</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH 金鑰與遠端連線</title>
    <url>/2020/06/09/ssh/</url>
    <content><![CDATA[<p>遠端推送不用帳密了!! (撒花</p>
<p>內文</p>
<ul>
<li>SSH 介紹</li>
<li>如何產生金鑰</li>
<li>金鑰檔案位置</li>
</ul>
<a id="more"></a>

<h1 id="SSH-金鑰與遠端連線"><a href="#SSH-金鑰與遠端連線" class="headerlink" title="SSH 金鑰與遠端連線"></a>SSH 金鑰與遠端連線</h1><h2 id="SSH-介紹"><a href="#SSH-介紹" class="headerlink" title="SSH 介紹"></a>SSH 介紹</h2><br>

<blockquote>
<p>一種加密的網路傳輸協定,<br>常見的用途為遠端登入</p>
</blockquote>
<p>使用方法為先在本地產生一對金鑰,<br>將公鑰放上遠端的 server,<br>私鑰則留在本地電腦妥善保管,<br>當開始進行 ssh 連線時,<br>遠端公鑰則會和本地私鑰進行比對,<br>比對成功即可連線</p>
<h2 id="如何產生金鑰"><a href="#如何產生金鑰" class="headerlink" title="如何產生金鑰"></a>如何產生金鑰</h2><p>CLI 輸入以下指令即可:<br><code>ssh-keygen</code></p>
<p>或是可以加上參數:<br><code>ssh-keygen -t rsa -C &lt;comment&gt;</code></p>
<p>參數說明:</p>
<ul>
<li>-t 指定生成密鑰的類型</li>
<li>-C 提供一個新註釋</li>
</ul>
<h2 id="金鑰檔案位置"><a href="#金鑰檔案位置" class="headerlink" title="金鑰檔案位置"></a>金鑰檔案位置</h2><p><strong>Mac</strong>: <code>/Users/&lt;使用者名稱&gt;/.ssh/</code></p>
<p>在金鑰產生後 .ssh 資料夾下會有兩隻檔案</p>
<ul>
<li>公鑰: <code>id_rsa.pub</code></li>
<li>私鑰: <code>id_rsa</code></li>
</ul>
<p><strong>最後把公鑰放上遠端 server 即可完成 ssh 連線前設定</strong></p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/09/ssh/">https://davidblog.github.io/2020/06/09/ssh/</a> </p>
]]></content>
      <categories>
        <category>遠端連線</category>
      </categories>
      <tags>
        <tag>協定</tag>
        <tag>linux</tag>
        <tag>遠端連線</tag>
        <tag>安全加密</tag>
      </tags>
  </entry>
  <entry>
    <title>PWA 漸進式網頁應用程式</title>
    <url>/2020/06/03/pwa/</url>
    <content><![CDATA[<p>讓你的 Web 直接變 APP?! …當然沒那麼誇張, 但除了一些限制外, 看起來就和 APP 一樣…</p>
<p><strong>內文備註：</strong></p>
<ul>
<li>基本設定</li>
<li>插件推薦</li>
<li>Tips</li>
</ul>
<a id="more"></a>

<h1 id="Progressive-Web-App"><a href="#Progressive-Web-App" class="headerlink" title="Progressive Web App"></a>Progressive Web App</h1><h2 id="基本設定"><a href="#基本設定" class="headerlink" title="基本設定"></a>基本設定</h2><p>這裏你只需放兩隻檔案在網頁根目錄並在 html 檔中引入相關設定即可完成</p>
<p><strong>檔案說明</strong></p>
<ul>
<li><code>manifest.json</code><blockquote>
<p>作用: 網頁加入手機桌面的必要資訊<br>引入: <code>&lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot; /&gt;</code></p>
</blockquote>
</li>
<li><code>service-worker.js</code><blockquote>
<p>作用: 離線快取機制<br>引入:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">if</span> (<span class="string">"serviceWorker"</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">     <span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, () =&gt; &#123;</span><br><span class="line">       navigator.serviceWorker.register(<span class="string">"./service-worker.js"</span>).then(</span><br><span class="line">         (registration) =&gt; &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(</span><br><span class="line">             <span class="string">`ServiceWorker registration successful with scope: <span class="subst">$&#123;registration.scope&#125;</span>`</span></span><br><span class="line">           );</span><br><span class="line">         &#125;,</span><br><span class="line">         (error) =&gt; &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">`ServiceWorker registration failed: <span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">         &#125;</span><br><span class="line">       );</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>至於這兩隻檔案怎麼寫呢???</strong><br>除了 Google 一下基本範例來自己寫…<br>底下提供好用插件可以直接產出這兩隻檔案!!!</p>
<h2 id="插件推薦"><a href="#插件推薦" class="headerlink" title="插件推薦"></a>插件推薦</h2><p><a href="https://www.npmjs.com/package/create-pwa" target="_blank" rel="noopener">create-pwa</a></p>
<blockquote>
<p>照裡面的文件使用就對了<br>好了, 現在你已經有所有該具備的檔案了<br>接下來就可以試試安裝在電腦桌面或手機桌面上了</p>
</blockquote>
<p><strong>什麼?!.. 安裝不了?!…</strong><br>底下附註一些 Tips 幫你解決常見的問題</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>基本上安裝不了,主要和三個地方有關係, 檢查過後就可以安裝了!!!</p>
<ol>
<li>pwa 在 localhost 或 https 下, 才能安裝</li>
<li>快取檔案路徑不正確</li>
<li>ios 手機只能用 safari 隱晦的方式加入桌面</li>
</ol>
<p><strong>什麼?!.. 安裝好了可是沒有東西?!…</strong></p>
<p>別緊張, 檢查一下 manifest.json 內的 start_url 是否正確</p>
<blockquote>
<p>其位置為 manifest.json 所在目錄的相對路徑</p>
</blockquote>
<p><strong>好了, 恭喜!!! 現在你有一個 PWA 了</strong></p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/03/pwa/">https://davidblog.github.io/2020/06/03/pwa/</a> </p>
]]></content>
      <categories>
        <category>PWA</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>PWA</tag>
        <tag>Progressive Web App</tag>
        <tag>service work</tag>
        <tag>manifest</tag>
      </tags>
  </entry>
  <entry>
    <title>上拉加載</title>
    <url>/2023/06/17/%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BC%89/</url>
    <content><![CDATA[<p>上拉加載 下拉更新 原本是 APP 很常見的功能<br>現在 Web 也很常見 因為越來越多的 Web 得做得和 APP 越來越像 …</p>
<p>今天這篇先講上拉加載的部分</p>
<a id="more"></a>

<p>實現加載的關鍵就在滾動事件  </p>
<p>當長清單列表的元素滾動到底部時<br>得觸發一個 Callback function 來獲取新的資料<br>並將此資料加入原清單列表的陣列當中  </p>
<p>這邊先看一下偵測滾動到底部的代碼：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const detectScrollToBottom &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const &#123; clientHeight, scrollHeight, ScrollTop &#125; &#x3D; document.querySelector(&#39;#el&#39;);</span><br><span class="line">    if(clientHeight + ScrollTop &gt;&#x3D; scrollHeight) &#123;</span><br><span class="line">        console.log(&#39;已滑動至底部&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.querySelector(&#39;#el&#39;).addEventListener(&#39;scroll&#39;, () &#x3D;&gt; detectScrollToBottom());</span><br></pre></td></tr></table></figure>

<p>首先解釋一下元素解構出來的這幾個屬性意思</p>
<table>
<thead>
<tr>
<th>scrollHeight</th>
<th>clientHeight</th>
<th>scrollTop</th>
</tr>
</thead>
<tbody><tr>
<td>元素可視與不可視區的高度</td>
<td>元素可視區的高度</td>
<td>元素可視區頂部到元素不可視區頂部的距離</td>
</tr>
</tbody></table>
<p>基本上 scrollHeight 與 clientHeight 都是固定的高度<br>只有 scrollTop 會隨著滾動而改變數值<br>當 clientHeight + ScrollTop 的數值 大於等於 scrollHeight 就表示到了底部</p>
<p><strong>但實際上</strong></p>
<p>這樣寫會有問題<br>因為scrollTop 在滾動時會有浮點數(0.5)<br>而浮點數可能會造成計算的不精準<br>像是明明已經滑動到底部了<br>但是因為差0.5而沒有偵測到底部去觸發回函  </p>
<p>所以這邊可以加上 1 來作為緩衝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const detectScrollToBottom &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const &#123; clientHeight, scrollHeight, ScrollTop &#125; &#x3D; document.querySelector(&#39;#el&#39;);</span><br><span class="line">    if(clientHeight + ScrollTop + 1 &gt;&#x3D; scrollHeight) &#123;</span><br><span class="line">        console.log(&#39;已滑動至底部&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.querySelector(&#39;#el&#39;).addEventListener(&#39;scroll&#39;, () &#x3D;&gt; detectScrollToBottom());</span><br></pre></td></tr></table></figure>

<p>或是多加一些 range 可以讓元素快到底部時就觸發回函</p>
<p><strong>但是… 這樣又會有一些問題</strong></p>
<p>因為加上了緩衝的range就有可能讓回函重複觸發</p>
<p><strong>所以</strong></p>
<p>為了避免事件重複觸發而不斷請求資料<br>可以加上一個 isLoading 的 Flag 來防呆<br>如果已經偵測到底部並請求資料時<br>就必須等到 timeout 或資料獲取完畢才能夠再觸發請求的回函</p>
<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2023/06/17/上拉加載/">https://davidblog.github.io/2023/06/17/上拉加載/</a> </p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>scroll</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 如何重構代碼（二）</title>
    <url>/2020/06/28/refactor2/</url>
    <content><![CDATA[<p>重構代碼第二彈!!!<br>在沒有寫第二彈前…<br>我ㄧ直在想會不會所有規劃好的系列文 都只有一回…XD</p>
<p>內文</p>
<ul>
<li>更好的 function (參數給予預設值)</li>
<li>更好的 array callback（ function 獨立拆出並給予命名）</li>
<li>更好的 邏輯運算子 || (改用陣列過濾)</li>
</ul>
<a id="more"></a>

<h1 id="更好的-function-參數給予預設值"><a href="#更好的-function-參數給予預設值" class="headerlink" title="更好的 function (參數給予預設值)"></a>更好的 function (參數給予預設值)</h1><br>

<blockquote>
<p>處理動態資料時<br>將 function 給予預設值是一個好選擇<br>以免 API 未回傳正確資料時 APP 閃退<br>或發生各種不必要的悲劇</p>
</blockquote>
<p>當參數遇到 <strong>undefined</strong> 時則會給予預設值</p>
<h2 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getAPlusB = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line">getAPlusB();</span><br><span class="line"><span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="Better-寫法一"><a href="#Better-寫法一" class="headerlink" title="Better 寫法一"></a>Better 寫法一</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getAPlusB = <span class="function">(<span class="params">a = <span class="number">0</span>, b = <span class="number">0</span></span>) =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line">getAPlusB();</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="Better-寫法二"><a href="#Better-寫法二" class="headerlink" title="Better 寫法二"></a>Better 寫法二</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getAPlusB = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  a = a || <span class="number">0</span>;</span><br><span class="line">  b = b || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getAPlusB();</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h1 id="更好的-array-callback（-function-獨立拆出並給予命名）"><a href="#更好的-array-callback（-function-獨立拆出並給予命名）" class="headerlink" title="更好的 array callback（ function 獨立拆出並給予命名）"></a>更好的 array callback（ function 獨立拆出並給予命名）</h1><br>

<blockquote>
<p>當 array 方法裡面的 callback function 較複雜的時候<br>將其獨立出來給予命名是一個好選擇<br>因為可以更直觀的了解其作用與功能</p>
</blockquote>
<h2 id="Normal-1"><a href="#Normal-1" class="headerlink" title="Normal"></a>Normal</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">array.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item * <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Better"><a href="#Better" class="headerlink" title="Better"></a>Better</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> doubleEachNumber = <span class="function">(<span class="params">number</span>) =&gt;</span> number * <span class="number">2</span>;</span><br><span class="line">array.map(doubleEachNumber);</span><br></pre></td></tr></table></figure>

<h1 id="更好的-邏輯運算子-改用陣列過濾"><a href="#更好的-邏輯運算子-改用陣列過濾" class="headerlink" title="更好的 邏輯運算子 || (改用陣列過濾)"></a>更好的 邏輯運算子 || (改用陣列過濾)</h1><br>

<blockquote>
<p>這邊範例是用 indexOf 來重構<br>但實際上用 includes 會更直觀<br>但使用上需要注意 indexOf 存在於 ES5<br>而 includes 則為 ES6 所加上的</p>
</blockquote>
<h2 id="Normal-2"><a href="#Normal-2" class="headerlink" title="Normal"></a>Normal</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getIdInfo = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (id === <span class="number">1</span> || id === <span class="number">2</span> || id === <span class="number">3</span> || id === <span class="number">4</span> || id === <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"id 介於 1 到 5 之間"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id === <span class="number">6</span> || id === <span class="number">7</span> || id === <span class="number">8</span> || id === <span class="number">9</span> || id === <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"id 介於 6 到 10 之間"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"id 不存在"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Better-1"><a href="#Better-1" class="headerlink" title="Better"></a>Better</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayOne = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arrayTwo = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getIdInfo = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (arrayOne.indexOf(id) !== <span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"id 介於 1 到 5 之間"</span>);</span><br><span class="line">  <span class="keyword">if</span> (arrayTwo.indexOf(id) !== <span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"id 介於 6 到 10 之間"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"id 不存在"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/28/refactor2/">https://davidblog.github.io/2020/06/28/refactor2/</a> </p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>refactor</tag>
      </tags>
  </entry>
  <entry>
    <title>CORS 跨域</title>
    <url>/2020/06/29/cors/</url>
    <content><![CDATA[<p>A: 預檢不過 …<br>B: … postman 沒問題啊<br>A: Ummm…瀏覽器不太一樣…</p>
<p>內文</p>
<ul>
<li>關於跨域<ul>
<li>同源政策</li>
<li>請求類型</li>
<li>preflight</li>
</ul>
</li>
<li>如何解決跨域<ul>
<li>設置正確標頭</li>
<li>使用套件</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h1 id="關於跨域"><a href="#關於跨域" class="headerlink" title="關於跨域"></a>關於跨域</h1><br>

<blockquote>
<p>瀏覽器基於安全性的考量<br>有所謂的同源政策<br>即以 Ajax 發送請求時 默認情況只有同域名下才能互相存取<br>若 port 不同, 子域名不同或協定不同 皆屬於跨域</p>
</blockquote>
<p>一般來說跨域只發生在瀏覽器<br>用伺服器直接發 Request 是沒問題的 (除非 API 本身就有問題 XD)</p>
<p>所以跨域實際上要解決的問題是瀏覽器機制的問題<br>為了解決此問題 我們會需要先知道瀏覽器發送 Request 的機制</p>
<p>當在瀏覽器發送 Request 時<br>主要分兩種類型的請求:</p>
<ul>
<li>簡單請求</li>
<li>複雜請求</li>
</ul>
<p>簡單請求包含以下兩點要素</p>
<ul>
<li>方法為<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
</ul>
</li>
</ul>
<br>

<ul>
<li>只含有簡單請求的標頭<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-type:<ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>

<p>除了簡單請求<br>…<strong>就是複雜請求</strong></p>
<p>而簡單請求與非簡單請求最大的差別就在於…!?</p>
<p><strong>Preflight</strong></p>
<p>如果是複雜請求的話<br>需要特別留意瀏覽器在正式請求前<br>會先發送一個 HTTP OPTIONS 的選項請求<br>當對應的標頭都正確無誤才會發送正式的 Request<br>這個行為被稱為 <strong>預檢</strong></p>
<h1 id="如何解決跨域"><a href="#如何解決跨域" class="headerlink" title="如何解決跨域"></a>如何解決跨域</h1><br>

<p>根據簡單請求與非簡單請求有不同處理方式<br>底下以 node express 來做示範</p>
<ul>
<li>簡單請求跨域:<ul>
<li>API 設定 Access-Control-Allow-Origin 的跨域來源</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>); <span class="comment">// "*" 表示皆開放</span></span><br><span class="line">  res.send(<span class="string">"Success!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`App listening on port <span class="subst">$&#123;port&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>非簡單請求跨域:<ul>
<li>API 設定 Access-Control-Allow-Origin 的跨域來源</li>
<li>外加設定 OPTIONS 的端口<ul>
<li>設定 “Access-Control-Allow-Origin”</li>
<li>設定 “Access-Control-Allow-Headers” (加上額外的 header)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.options(<span class="string">"/test"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type"</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">"/test"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  res.send(<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">token</span>: <span class="string">"Z29vZG1hbg=="</span> &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`App listening on port <span class="subst">$&#123;port&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用套件 cors (簡單請求與複雜請求都可以)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">"cors"</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.use(cors());</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">"/test"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">token</span>: <span class="string">"Z29vZG1hbg=="</span> &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`App listening on port <span class="subst">$&#123;port&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p><strong>本文作者</strong>： David Huang <br /><strong>本文地址</strong>： <a href="https://davidblog.github.io/2020/06/29/cors/">https://davidblog.github.io/2020/06/29/cors/</a> </p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>browser</tag>
        <tag>cors</tag>
        <tag>瀏覽器</tag>
        <tag>preflight</tag>
        <tag>postman</tag>
      </tags>
  </entry>
</search>
